{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Quick Start Code on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>XDiag is a library for performing Exact Diagonalizations of quantum many-body systems. Key features include optimized combinatorical algorithms for navigating Hilbert spaces, iterative linear algebra algorithms,  shared and distributed memory parallelization. It consist of two packages:</p> <ul> <li>The core C++ library xdiag</li> <li>The convenient Julia wrapper library XDiag.jl</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Please support our work by citing XDiag and the implemented algorithms if it is used in your published research.</p> <pre><code>@article{Wietek2018,\n  title = {Sublattice coding algorithm and distributed memory parallelization for large-scale exact diagonalizations of quantum many-body systems},\n  author = {Wietek, Alexander and L\\\"auchli, Andreas M.},\n  journal = {Phys. Rev. E},\n  volume = {98},\n  issue = {3},\n  pages = {033309},\n  numpages = {10},\n  year = {2018},\n  month = {Sep},\n  publisher = {American Physical Society},\n  doi = {10.1103/PhysRevE.98.033309},\n  url = {https://link.aps.org/doi/10.1103/PhysRevE.98.033309}\n}\n</code></pre>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"contributing/","title":"Contributing to XDiag","text":"<p>Thank you for considering contributing to xdiag! We welcome contributions from everyone. This document outlines the process and guidelines for contributing to this project.</p>"},{"location":"contributing/#major-contributions","title":"Major contributions","text":"<p>Our goal is to have regular software publications in SciPost Physics Codebases with updated major versions. We offer co-authorship for developers who provide major contributions. These include:</p> <ul> <li>Advanced new features: This may include implementation of a new block type, a new iterative algorithm, or novel operators and measurements</li> <li>Major contributions to the documentations: This would include writing extended tutorials, or contributing a significant number of examples. </li> </ul> <p>We recommend to propose a major new feature in the Discussions first, such that we can give feedback to a possible enhancement.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Ensure the bug was not already reported by searching on GitHub under Issues. If you're unable to find an open issue addressing the problem, open a new one. Be sure to include a title and clear description, as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.</p>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>Open an issue with the label enhancement and describe your suggestion in detail. Explain why this enhancement would be useful to the project and how it can be implemented.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li>Fork the repository and create your branch from main.</li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> <li>Ensure the test suite passes.</li> <li>Issue that pull request!</li> </ul>"},{"location":"contributing/#code-review-process","title":"Code Review Process","text":"<p>All submissions, including submissions by project members, require review. Focus on the following aspects during the review: - Design: Is the code well-designed and appropriate for the use case? - Functionality: Does the code behave as expected? - Complexity: Could the code be made simpler? - Tests: Does the code have appropriate tests? - Documentation: Is the code well-documented?</p>"},{"location":"contributing/#community","title":"Community","text":"<p>Join our Discussions to engage with the community, ask questions, and share ideas.</p> <p>This guide provides a comprehensive overview of how to contribute to the xdiag project. If you have any questions or need further assistance, feel free to reach out to the maintainers or the community. Happy contributing!</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-examples","title":"Basic examples","text":"<ul> <li> <p> Groundstate energy</p> <p>Computes the ground state energy of a simple Heisenberg spin \\(S=1/2\\) chain</p> <p>source </p> </li> <li> <p> Groundstate correlators</p> <p>Computes ground state correlators of a simple Heisenberg spin \\(S=1/2\\) chain with the help of symmetries.</p> <p>source </p> </li> <li> <p> Entanglement Entropy Groundstate</p> <p>Computes ground state entanglement entropy of an XXZ spin \\(S=1/2\\) chain.</p> <p>source </p> </li> </ul>"},{"location":"examples/#full-ed","title":"Full ED","text":"<ul> <li> <p> Specific Heat random t-J model</p> <p>Computes the specific heat of the random t-J model via full ED over multiple disorder realizations.</p> <p>source </p> </li> <li> <p> Spin chain level statistics</p> <p>Demonstrates Poissonian and Wigner-Dyson level statistics of integrable and non-integrable spin chains, respectively.</p> <p>source </p> </li> </ul>"},{"location":"examples/#tower-of-states","title":"Tower of States","text":"<ul> <li> <p> TOS \\(\\alpha \\text{XX}\\) chain</p> <p>Performs a tower of states analyzis for the \\(\\alpha \\text{XX}\\) chain.</p> <p>source </p> </li> </ul>"},{"location":"examples/#dynamical-spectral-functions","title":"Dynamical spectral functions","text":"<ul> <li> <p> Spin structure factor</p> <p>Computes the dynamical structure factor of a spin \\(S=1/2\\) chain</p> <p>source </p> </li> <li> <p> Green's function</p> <p>Computes the Green's function in a 2D Hubbard model</p> <p>source </p> </li> </ul>"},{"location":"examples/#time-evolution","title":"Time Evolution","text":"<ul> <li> <p> Domain Wall Dynamics</p> <p>Demonstrates the time evolution of a domain wall in the \\(S=1/2\\) XXZ chain.</p> <p>source </p> </li> </ul>"},{"location":"examples/#thermodynamcis-with-thermal-pure-quantum-states","title":"Thermodynamcis with Thermal Pure Quantum States","text":"<ul> <li> <p> Specific Heat with TPQ</p> <p>Computes the specific heat using the TQP states for the Shastry Sutherland model.</p> <p>source </p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#julia-installation","title":"Julia Installation","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and type: <pre><code>add XDiag\n</code></pre></p> <p>That's it!</p>"},{"location":"installation/#c-compilation","title":"C++ Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. Here we explain how to compile the library.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul>"},{"location":"installation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building the Julia wrapper locally</p> <p>First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> </li> </ul>"},{"location":"installation/#building-documentation","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To work on it locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#julia","title":"Julia","text":"<p>To install XDiag, enter the package mode in the Julia REPL using <code>]</code> and type</p> <pre><code>add XDiag\n</code></pre> <p>That's it! Now we are ready to perform our first exact diagonalization. We compute the ground state energy of the \\(S=1/2\\) Heisenberg chain on a periodic chain lattice in one dimension. The Hamiltonian is given by</p> \\[ H = J\\sum_{\\langle i,j \\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j\\] <p>where \\(\\mathbf{S}_i = (S_i^x, S_i^y, S_i^z)\\) are the spin \\(S=1/2\\) operators and \\(\\langle i,j \\rangle\\) denotes summation over nearest-meighbor sites \\(i\\) and \\(j\\).</p> <pre><code>using XDiag\n\nlet\n    say_hello()\n    N = 16\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    set_verbosity(2)            # set verbosity for monitoring progress\n    e0 = eigval0(ops, block)    # compute ground state energy\n\n    println(\"Ground state energy: $e0\")\nend\n</code></pre> <p>For more examples, see our Example Collection.</p>"},{"location":"quick_start/#c","title":"C++","text":"<p>Using XDiag with C++, we first need to compile the XDiag library, see the Library compilation instructions. Then, our application code looks like this:</p> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <p>The <code>try / catch</code> clause implements an error trace mechanism, which we recommend for every XDiag application. The application is then compiled as well, see Application compilation instructions, resulting in our final executable.</p> <p>The C++ versions offers the opportunity to optimize compilation the code for the target architecture, see C++ optimization</p>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#v031","title":"v0.3.1","text":"<p>Feb. 11, 2025</p> <p>New API and operator logic</p> <ul> <li>Updated to a new streamlined API</li> <li>Implemented operator logic including symmetries</li> <li>Completed wrapper for Julia</li> <li>w = apply(ops, v) works now</li> </ul>"},{"location":"releases/#v023","title":"v0.2.3","text":"<p>Sep. 9, 2024</p> <p>Introduced 1-indexing everywhere in Julia version</p> <ul> <li>only changes to XDiag.jl, C++ untouched</li> <li>XDiag_jll.jl remains at v0.2.2</li> </ul>"},{"location":"releases/#v022","title":"v0.2.2","text":"<p>Aug. 27, 2024</p> <p>Lanczos routines and multicolumn States</p> <ul> <li>wrapped eigs_lanczos, eigvals_lanczos</li> <li>implemented apply for States with multiple columns</li> <li>changed wrapping of std::vectors of Op and Permutation</li> </ul>"},{"location":"releases/#v021","title":"v0.2.1","text":"<p>Aug. 16, 2024</p> <p>Small patch release providing small utility functions</p> <ul> <li>wrapped say_hello, print_version, and set_verbosity</li> <li>resorted to compiling wrapper with conventional OpenMP on aarch64 apple</li> <li>Fixed faulty behaviour of OpenMP on aarch64 apple</li> </ul>"},{"location":"releases/#v020","title":"v0.2.0","text":"<p>Aug. 15, 2024</p> <p>Basic functionality for three Hilbert space types, Spinhalf, tJ, and Electron, has been implemented. Features are:</p> <ul> <li>Algebra with and without permutation symmetries</li> <li>Parallelization with OpenMP and MPI</li> <li>CMake has been properly set up</li> <li>Iterative algorithms present, Lanczos, Arnoldi, time evolution</li> <li>A minimal Julia wrapper has been written</li> <li>The Julia wrapper compiles on several target 64bit systems using BinaryBuilder</li> </ul>"},{"location":"user_guide/","title":"User guide","text":"<p>A step-by-step guide to using XDiag</p>"},{"location":"user_guide/#installation","title":"Installation","text":""},{"location":"user_guide/#julia","title":"Julia","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and type: <pre><code>add XDiag\n</code></pre></p> <p>That's it!</p>"},{"location":"user_guide/#c","title":"C++","text":"<p>For using the C++ version, we need to compile the library first. To do so, we first download the code using git, </p> <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre> <p>and then compile the library using CMake,</p> <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre> <p>The resulting library is now installed at <code>/path/to/where/xdiag/should/be/install</code>. There are various options when compiling, including optimizations which can be used. For more details on the compilation process, we refer to the Compilation guide.</p>"},{"location":"user_guide/#first-steps","title":"First steps","text":""},{"location":"user_guide/#writing-code","title":"Writing code","text":"<p>Let us set up our first program using the <code>xdiag</code> library. </p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nsay_hello()\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information which exact XDiag version is used. In Julia this is all there is to it.</p> <p>What is maybe a bit unfamiliar is the <code>try / catch</code> block in C++. XDiag implements a traceback mechanism for runtime errors, which is activated by the <code>error_trace</code> function. While not stricly necessary here, it is a good practice to make use of this.</p>"},{"location":"user_guide/#compilation","title":"Compilation","text":"<p>In C++, now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(hello_world)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/where/xdiag/should/be/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>/path/to/where/xdiag/should/be/install</code> with the appropriate directory where your XDiag library is installed after compilation. We then compile the application code,</p> <p><pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> and finally run our first XDiag application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"user_guide/#hilbert-spaces","title":"Hilbert spaces","text":"<p>We are now ready to run our first actual calculation using XDiag. Our immediate goal will be to determine the ground state energy of a \\(S=1/2\\) Heisenberg model on a 1D chain lattice with periodic boundary conditions,</p> \\[ H = J \\sum_{\\langle i, j\\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j,\\] <p>where \\(\\mathbf{S}_i = (S^x_i, S^y_i, S^z_i)\\) denotes the vector of spin matrices at a given site \\(i\\). The notation \\(\\langle i, j\\rangle\\) refers to summatation over neighboring sites \\(i\\) and \\(j\\).</p> <p>The first thing to define before any computation, is the Hilbert space our model will be defined on. For the present example, we use the Hilbert space class Spinhalf. Further possible Hilbert spaces include tJ and Electron, see Blocks. We consider a chain lattice with \\(N=8\\) sites and create a \\(S=1/2\\) Hilbert space:</p> C++Julia <pre><code>using namespace xdiag;\nint N = 8;\nauto hspace = Spinhalf(N);\n</code></pre> <pre><code>N = 8\nhspace = Spinhalf(8)\n</code></pre> <p>We would like to know which spin configurations, the Hilbert space is made up of. To do so, we can iterate over the Hilbert space and print out the spin configurations. </p> C++Julia <pre><code>for (auto spins : hspace) {\n  Log(\"{}\", to_string(spins));\n}\n</code></pre> <pre><code>for spins in hspace\n    println(to_string(spins))\nend\n</code></pre> <p>This produces an output similar to the following:</p> <pre><code>\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\n\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2191\n\u2193\u2193\u2193\u2193\u2193\u2193\u2191\u2193\n\u2193\u2193\u2193\u2193\u2193\u2193\u2191\u2191\n\u2193\u2193\u2193\u2193\u2193\u2191\u2193\u2193\n\u2193\u2193\u2193\u2193\u2193\u2191\u2193\u2191\n\u2193\u2193\u2193\u2193\u2193\u2191\u2191\u2193\n...\n</code></pre> <p>Here we already see several things at work. XDiag features a convenient way to write logs in C++, with the Log class. The first argument to <code>Log()</code> is a format string. In C++ we use the fmt library, to be able to write structured format and format our output. The second argument turns our <code>spins</code> into a string. <code>spins</code> is of type ProductState, whose configuration on each site can be individually addressed. </p> <p>Further, we notice that all \\(2^N\\) spin configurations are included in this Hilbert space. However, the Heisenberg model conserves the total \\(S^z = \\sum_i S^z_i\\), and thus we could limit ourselves to a block of the Hilbert space, which only contains configurations of a certain magnetization: </p> C++Julia <pre><code>int nup = 4;\nauto block = Spinhalf(N, nup);\nfor (auto spins : block) {\n  Log(\"{}\", to_string(spins));\n}\n</code></pre> <pre><code>nup = 4;\nblock = Spinhalf(N, nup);\nfor spins in block\n    println(to_string(spins))\nend\n</code></pre> <p>This produces an output similar to: <pre><code>\u2193\u2193\u2193\u2193\u2191\u2191\u2191\u2191\n\u2193\u2193\u2193\u2191\u2193\u2191\u2191\u2191\n\u2193\u2193\u2193\u2191\u2191\u2193\u2191\u2191\n\u2193\u2193\u2193\u2191\u2191\u2191\u2193\u2191\n\u2193\u2193\u2193\u2191\u2191\u2191\u2191\u2193\n\u2193\u2193\u2191\u2193\u2193\u2191\u2191\u2191\n\u2193\u2193\u2191\u2193\u2191\u2193\u2191\u2191\n...\n</code></pre></p> <p>We see that the block now only contains configurations, where the total number of spins pointing up is 4. We can now quickly check the dimension of the Hilbert spaces, and confirm that the dimension of the block is reduced from \\(2^8=256\\) to \\(\\begin{pmatrix} 8 \\\\ 4 \\end{pmatrix} = 70\\),</p> C++Julia <pre><code>XDIAG_SHOW(size(hspace));\nXDIAG_SHOW(size(block));\n</code></pre> <pre><code>@show size(hspace)\n@show size(block)\n</code></pre> <p>which should print: <pre><code>size(hspace):\n256\nsize(block):\n70\n</code></pre></p> <p>Here, we introduced another functionality of XDiag in C++, the XDIAG_SHOW macro which can be used for quick debug printing of XDiag objects.</p>"},{"location":"user_guide/#operators","title":"Operators","text":"<p>Next, we define our Hamiltonian. We do so by using an OpSum object. These encode sums of operators of the form </p> \\[ \\mathcal{O} = \\sum_i c_i \\mathcal{O}_i. \\] <p>Here, \\(\\mathcal{O}_i\\) denote single operators described as Op objects and \\(c_i\\) are the coupling constants. These can either be a real or complex number, or a string which later needs to be replaced. THe Hamiltonian of the spin \\(S=1/2\\) Heisenberg chain is created like this:</p> C++Julia <pre><code>auto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n</code></pre> <pre><code>ops = OpSum()\nfor i in 1:N\n    ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\nend\nops[\"J\"] = 1.0\n</code></pre> <p>We first create an empty OpSum and then add additional terms to it. The first part of the product denotes the coupling constant, here given as a string. Alternatively, one could have directly used real / complex numbers here. The second part of the product is a single Op object. It is created with two inputs:</p> <ol> <li>The type, here <code>SdotS</code> denoting an operator of the form \\(\\mathbf{S}_i\\cdot\\mathbf{S}_j\\). XDiag features a wide variety of operator types, see Operator types.</li> <li>An array defining which site the operator lives on. Notice, that in julia we start counting the sites from 1, while in C++ we start counting the sites from 0.</li> </ol>"},{"location":"user_guide/#ground-states","title":"Ground states","text":"<p>Now our Hamiltonian is defined, we can directly compute the ground state and its energy using the function eig0:</p> C++Julia <pre><code>auto [e0, psi0] = eig0(ops, block);\nLog(\"e0: {:.12f}\", e0);\n</code></pre> <pre><code>e0, psi0 = eig0(ops, block)\nprintln(\"e0:\", e0)\n</code></pre> <p>Here, <code>e0</code> is a double precision real number and <code>psi0</code> is a State object. The eig0 uses an iterative algorithms to compute the ground state by applying the Hamiltonian in a matrix-free manner, and is thus very useful for large system sizes. It is based on a Lanczos algorithm, which can also be called directly using eigs_lanczos which offers more control on the behavior of the algorithm.</p> <p>Alternatively, we can also perform a full diagonalization by computing the full Hamiltonian matrix using the matrix function.</p> C++Julia <pre><code>arma::mat H = matrix(ops, block); \narma::vec evals;\narma::mat evecs;\narma::eig_sym(evals, evecs, H);\nLog(\"e0: {:.12f}, e1: {:.12f}\", evals[0], evals[1]);\n</code></pre> <pre><code>H = matrix(ops, block); \n(evals, evecs) = eigen(Symmetric(H))\nprintln(\"e0:\", evals[1], \"e1:\", evals[2]);\n</code></pre> <p>Notice, that we are using the Armadillo library with the <code>arma</code> namespace in C++. This library serves as the linear algebra backend of XDiag and can be used to perform further calculations. In Julia, the <code>eigen</code> and <code>Symmetric</code> functions are part of the <code>LinearAlgebra</code> standard library.</p>"},{"location":"user_guide/#measurements","title":"Measurements","text":"<p>Finally, we might be interested in measuring some observables of the ground state. We compute the static spin correlation \\(S^z_0 S^z_j\\):</p> C++Julia <pre><code>for (int i=1; i&lt;N; ++i) {\n  auto op = Op(\"SzSz\", {0, i});\n  double corr = inner(op, psi0);\n  Log(\"&lt;Sz_0 Sz_{}&gt; = {:.12f}\", i, corr);\n}\n</code></pre> <pre><code>for i in 2:N\n    op = Op(\"SzSz\", [1, i])\n    corr = inner(op, psi0)\n    println(\"&lt;Sz_0 Sz_$i&gt; = \", corr)\nend\n</code></pre> <p>Here, we are using the inner function to compute an expectation value of the form \\(\\langle \\psi_0 |\\mathcal{O}| \\psi_0 \\rangle\\) with \\(\\mathcal{O} = S^z_0 S^z_j\\).</p>"},{"location":"user_guide/#input-output","title":"Input / Output","text":"<p>Julia features a variety of packages facilitating input and output of data. For C++, XDiag provides convenient functionality for TOML and HDF5 files. </p>"},{"location":"user_guide/#reading-from-toml","title":"Reading from TOML","text":"<p>While defining a Hamiltonian or other operators in code as above can be done, it is often preferable to define operators in a file and read it in. In XDiag, we use the TOML language to define input. The Hamiltonian of the \\(N=8\\) site Heisenberg chain we created above can be written in a TOML file as a list like this:</p> <pre><code>Interactions = [\n  ['J', 'SdotS', 0, 1],\n  ['J', 'SdotS', 1, 2],\n  ['J', 'SdotS', 2, 3],\n  ['J', 'SdotS', 3, 4],\n  ['J', 'SdotS', 4, 5],\n  ['J', 'SdotS', 5, 6],\n  ['J', 'SdotS', 6, 7],\n  ['J', 'SdotS', 7, 0]\n]\n</code></pre> <p>The first entry in every list element is the coupling constant <code>J</code>, the second enty is the type <code>SdotS</code>, and the following two entries are the sites of the operator. To read in such a Hamiltonian from a toml file we can use the FileToml object together with the read_opsum Function,</p> C++Julia <pre><code>auto fl = FileToml(XDIAG_DIRECTORY \"/examples/user_guide/spinhalf_chain.toml\");\nauto ops = read_opsum(fl, \"Interactions\");\n</code></pre> <pre><code>fl = FileToml(\"spinhalf_chain.toml\")\nops = read_opsum(fl, \"Interactions\")\n</code></pre> <p>XDiag also features the functions read_permutation_group and read_representation to conventiently read PermutationGroup and Representation objects used to describe symmetries from file, see further below.</p>"},{"location":"user_guide/#writing-results-to-hdf5","title":"Writing results to hdf5","text":"<p>After a simulation, we want to store results to file. A standard scientific data format is the hdf5 format. Julia supports input and output to hdf5 with the HDF5.jl package. </p> <p>For C++ we provide a convenient way of writing results to hdf5 files. In general all numerical data, including scalar real/complex numbers as well as armadillo vectors and matrices can be easily written to file using the FileH5 object.</p> C++ <pre><code>auto fl = FileH5(XDIAG_DIRECTORY \"/examples/user_guide/output.h5\", \"w!\");\nfl[\"e0\"] = e0;\nfl[\"evals\"] = evals;\nfl[\"evecs\"] = evecs; \n</code></pre> <p>The second argument <code>\"w!\"</code> specifies the access mode to the file. <code>\"w!\"</code> is the forced write mode, where preexisting files are overwritten. </p>"},{"location":"user_guide/#symmetries","title":"Symmetries","text":""},{"location":"user_guide/#permutations","title":"Permutations","text":"<p>Key functionality of XDiag comprises symmetry-adapted calculations, in particular with permutation symmtries which can be translation symmetries on a lattice. The Heisenberg chain with periodic boundary conditions is invariant under the translation operator</p> \\[ T: i \\rightarrow i+1 \\] <p>To represent such symmetries, we use the Permutation object. For example, on the \\(8\\)-site chain lattice, the symmetry which maps the sites, </p> \\[ \\{0,1,2,3,4,5,6,7\\} \\rightarrow \\{1,2,3,4,5,6,7,0\\} \\] <p>can be represented via: </p> C++Julia <pre><code>auto T = Permutation({1, 2, 3, 4, 5, 6, 7, 0});\n</code></pre> <pre><code>T = Permutation([2, 3, 4, 5, 6, 7, 8, 1])\n</code></pre> <p>Notice, that also here we start counting from 1 in Julia, and from 0 in C++. Permutation objects can be multiplied, inverted, and raised to a power. We can use them to define a PermutationGroup object in the following way:</p> C++Julia <pre><code>auto group = PermutationGroup({pow(T, 0), pow(T, 1), pow(T, 2), pow(T, 3),\n                               pow(T, 4), pow(T, 5), pow(T, 6), pow(T, 7)});\n</code></pre> <pre><code>group = PermutationGroup([T^0, T^1, T^2, T^3, T^4, T^5, T^6, T^7])\n</code></pre>"},{"location":"user_guide/#representations","title":"Representations","text":"<p>One-dimensional representations of a PermutationGroup are described by the Representation object. As one-dimensional irreducible representations (irreps) are given by their characters \\(\\chi(g)\\) which is simply a list of (complex) numbers for every symmetry element \\(g\\). A representation can be created by handing the group and the list of characters: </p> C++Julia <pre><code>auto irrep_k_0 = Representation(group, arma::vec{1.0, 1.0, 1.0, 1.0,\n                         1.0, 1.0, 1.0, 1.0});\nauto irrep_k_pi = Representation(group, arma::vec{1.0, -1.0, 1.0, -1.0,\n                          1.0, -1.0, 1.0, -1.0});\n</code></pre> <pre><code>irrep_k_0 = Representation(group, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])\nirrep_k_pi = Representation(group, [1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0])\n</code></pre> <p>Upon creation of a representation, XDiag checks whether the group axioms as well as the homomorphism property of the characters is fulfilled, i.e.,</p> \\[ f * g = h  \\Rightarrow \\chi(f) \\cdot \\chi(g) = \\chi(h).\\] <p>Representations can then be used to create symmetry adapted blocks, which can then be diagonalized independently:</p> C++Julia <pre><code>auto block_k_0 = Spinhalf(N, nup, irrep_k_0);\nauto block_k_pi = Spinhalf(N, nup, irrep_k_pi);\ndouble e0_k_0 = eigval0(ops, block_k_0);\ndouble e0_k_pi = eigval0(ops, block_k_pi);\nLog(\"e0: k=0: {:.12f}, k=pi: {:.12f}\", e0_k_0, e0_k_pi);\n</code></pre> <pre><code>block_k_0 = Spinhalf(N, nup, irrep_k_0)\nblock_k_pi = Spinhalf(N, nup, irrep_k_pi)\ne0_k_0 = eigval0(ops, block_k_0)\ne0_k_pi = eigval0(ops, block_k_pi)\nprintln(\"e0: k=0: $e0_k_0, k=pi: $e0_k_pi\")\n</code></pre> <p>Also, permutation groups and representations can be defined in a TOML file and read in. Please refer to the read_permutation_group and read_representation documentation on the specific format required. </p> <p>Using symmetries, thus, can give enhanced physical insights to the system, but also reduces the computational costs significantly. A common analysis tool for understanding quantum many-body systems is the Tower of states analysis. For an introduction, see e.g. </p> <p>Studying Continuous Symmetry Breaking using Energy Level Spectroscopy  Alexander Wietek, Michael Schuler, Andreas M. L\u00e4uchli  arXiv:1704.08622 [cond-mat.str-el] DOI: 10.48550/arXiv.1704.08622</p>"},{"location":"user_guide/#further-features","title":"Further features","text":"<p>Some further features of XDiag include:</p> <ul> <li> <p>Besides the Spinhalf, further blocks include the tJ and Electron</p> </li> <li> <p>Distributed blocks like SpinhalfDistributed and tJDistributed allow for distributed memory parallelization in C++.</p> </li> <li> <p>Real and imaginary time evolutions can be performed using the functions time_evolve, imaginary_time_evolve.</p> </li> <li> <p>Operators can be symmetrized using the symmetrize function. </p> </li> <li> <p>Product states and random states can be created using the functions product_state and random_state.</p> </li> <li> <p>Timing of certain parts of the code in C++ can be conventiently performed using the Timing utilities.</p> </li> </ul>"},{"location":"documentation/","title":"Documentation","text":"<p>XDiag uses the C++ library Armadillo as a linear algebra backend. Documentation for linear algebra operations can, therefore, be found in the Armadillo Documentation.</p>"},{"location":"documentation/#algebra","title":"Algebra","text":"Name Description Language matrix Creates the full matrix representation of an operator on a block apply Applies an operator to a state \\(\\vert \\phi \\rangle = O \\vert \\psi\\rangle\\) dot Computes the dot product between two states inner Computes an expectation value \\(\\langle \\psi \\vert O \\vert \\psi \\rangle\\) norm Computes the 2-norm of a state norm1 Computes the 1-norm of a state norminf Computes the \\(\\infty\\)-norm of a state"},{"location":"documentation/#algorithms","title":"Algorithms","text":"<p>Diagonalization</p> Name Description Language eigval0 Computes the lowest lying eigenvalue of an operator eig0 Computes the lowest lying eigenvalue and eigenvector of an operator eigvals_lanczos Performs an iterative eigenvalue calculation using the Lanczos algorithm eigs_lanczos Performs an iterative eigenvalue calculation building eigenvectors using the Lanczos algorithm <p>Time evolution</p> Name Description Language time_evolve Performs a real-time evolution \\(e^{ -iHt} \\vert \\psi \\rangle\\) of a State with a given Hermitian operator \\(H\\) imaginary_time_evolve Performs a imaginary-time evolution \\(e^{ -\\tau H}\\vert\\psi\\rangle\\) of a State with a given Hermitian operator \\(H\\) evolve_lanczos Computes the exponential $e^{z H}\\vert\\psi\\rangle $ of a Hermitian operator times a State for a real or complex \\(z\\) using the Lanczos algorithm time_evolve_expokit Performs a real-time evolution \\(e^{ -iHt} \\vert \\psi \\rangle\\) using a highly accurate Lanczos algorithm"},{"location":"documentation/#blocks","title":"Blocks","text":"<p>Shared memory</p> Name Description Language Spinhalf Block of a spin \\(S=1/2\\) type Hilbert space tJ Block of a \\(t-J\\) type Hilbert space Electron Block of a Electron type Hilbert space <p>Distributed memory</p> Name Description Language SpinhalfDistributed Block of a spin \\(S=1/2\\) type Hilbert space (distributed computing) tJDistributed Block of a \\(t-J\\) type Hilbert space  (distributed computing)"},{"location":"documentation/#building","title":"Building","text":"Name Description Language Compilation Advanced settings for compilation of the C++ library using CMake Documentation How to build and work on the documentation locally Julia Wrapper How to build and develop the Julia wrapper locally"},{"location":"documentation/#input-output","title":"Input / Output","text":"<p>TOML</p> Name Description Language FileToml A file handler for TOML files read_opsum reads an OpSum from a TOML file read_permutation_group reads a PermutationGroup from a TOML file read_representation reads a Representation from a TOML file <p>HDF5</p> Name Description Language FileH5 A file handler for hdf5 files"},{"location":"documentation/#operators","title":"Operators","text":"Operator types A summary of all the operator types defined in XDiag Name Description Language Op A linear operator acting on the Hilbert space OpSum Sum of couplings times operators hc Returns the hermitian conjugate of an Op or OpSum. symmetrize Symmetrizes an operator with a PermutationGroup or Representation"},{"location":"documentation/#states","title":"States","text":"Name Description Language State A generic state describing a quantum wave function ProductState A product state of local configurations RandomState A random state with normal distributed coefficients fill Fill a state with a given model state product_state Creates a filled product state random_state Create a filled random state with normal distributed coefficients zero_state Create a filled state with all zero entries zero Set all coefficients of a given state to zero"},{"location":"documentation/#symmetries","title":"Symmetries","text":"Name Description Language Permutation Permutations of indices or lattice sites PermutationGroup A group of permutations Representation A (1D) irreducible representation of a finite group"},{"location":"documentation/#utilities","title":"Utilities","text":"Name Description Language set_verbosity Sets how much information is printed during computations say_hello Prints a nice welcome message with version number print_version Prints the plain version number Logging Controling what is written to standard output Timing Measurng wall time straightforwardly XDIAG_SHOW Macro for printing debugging information"},{"location":"documentation/algebra/algebra/","title":"Algebra routines","text":"<p>Several basic algebraic operations for states and operators.</p> <p>Sources algebra.hpp algebra.cpp algebra.jl</p>"},{"location":"documentation/algebra/algebra/#dot","title":"dot","text":"<p>Computes the dot product \\(\\langle v \\vert w \\rangle\\) between two states \\(\\vert v \\rangle\\) and \\(\\vert w \\rangle\\). In C++, please use the dotC function if one of the two states is expected to be complex.</p> C++Julia <pre><code>double dot(State const &amp;v, State const &amp;w);\ncomplex dotC(State const &amp;v, State const &amp;w);\n</code></pre> <pre><code>dot(v::State, w::State)\n</code></pre>"},{"location":"documentation/algebra/algebra/#inner","title":"inner","text":"<p>Computes the expectation value \\(\\langle v | O |v \\rangle\\) of an operator \\(O\\) and a state \\(|v\\rangle\\). The operator can either be an Op or an OpSum object. In C++, please use the innerC function if either the operator or the state are complex.</p> C++Julia <pre><code>double inner(Op const &amp;op, State const &amp;v);\ndouble inner(OpSum const &amp;ops, State const &amp;v);\ncomplex innerC(Op const &amp;op, State const &amp;v);\ncomplex innerC(OpSum const &amp;ops, State const &amp;v);\n</code></pre> <pre><code>inner(op::Op, v::State)\ninner(ops::OpSum, v::State)\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm","title":"norm","text":"<p>Computes the 2-norm \\(\\parallel |v \\rangle \\parallel_2\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_2 = \\sum_n |\\langle n | v \\rangle |^2, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norm(State const &amp;v);\n</code></pre> <pre><code>norm(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm1","title":"norm1","text":"<p>Computes the 1-norm \\(\\parallel |v \\rangle \\parallel_1\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_1 = \\sum_n |\\langle n | v \\rangle |, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norm1(State const &amp;v);\n</code></pre> <pre><code>norm1(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#norminf","title":"norminf","text":"<p>Computes the \\(\\infty\\)-norm \\(\\parallel |v \\rangle \\parallel_\\infty\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_\\infty = \\max_n |\\langle n | v \\rangle |, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norminf(State const &amp;v);\n</code></pre> <pre><code>norminf(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#usage-examples","title":"Usage Examples","text":"C++Julia <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\n\nXDIAG_SHOW(norm(psi));\nXDIAG_SHOW(norm1(psi));\nXDIAG_SHOW(norminf(psi));\n\nXDIAG_SHOW(dot(psi, psi));\nXDIAG_SHOW(e0);\nXDIAG_SHOW(inner(ops, psi));\n\nauto phi = random_state(block);\nXDIAG_SHOW(phi.vector());\nXDIAG_SHOW(psi.vector());\nXDIAG_SHOW((psi + 2.0*phi).vector());\nXDIAG_SHOW((psi*complex(0,3.0) + phi/2.0).vectorC());\n</code></pre> <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    e0, psi = eig0(ops, block);\n\n    @show norm(psi)\n    @show norm1(psi)\n    @show norminf(psi)\n    @show dot(psi, psi)\n    @show e0, inner(ops, psi)\n\n    phi = random_state(block)\n    display(vector(phi))\n    display(vector(psi))\n    display(vector(psi + 2.0*phi))\n    display(vector(psi*3.0im + phi/2.0))\nend\n</code></pre>"},{"location":"documentation/algebra/apply/","title":"apply","text":"<p>Applies an operator given as an Op or OpSum to a State \\(\\vert w \\rangle = \\mathcal{O} \\vert v\\rangle\\).</p> <p>Sources apply.hpp apply.cpp apply.jl</p>"},{"location":"documentation/algebra/apply/#definition","title":"Definition","text":"<p>An operator \\(\\mathcal{O}\\) can be applied to a state \\(\\vert v\\rangle\\) in two ways:</p> <ol> <li> <p>Only the input state on which the operator acts is defined is given. The block of the output state is calculated and eventually created automatically.</p> C++Julia <pre><code>State apply(Op const &amp;op, State const &amp;v);\nState apply(OpSum const &amp;ops, State const &amp;v);\n</code></pre> <pre><code>apply(op::Op, v::State)\napply(ops::OpSum, v::State)\n</code></pre> </li> <li> <p>The output state is also handed as an argument which is overwritten. The compatibility of quantum numbers is checked. This way the output block is not created automatically and, thus, can be used to save computation time if the output block appears repeatedly in the computation.</p> C++Julia <pre><code>void apply(Op const &amp;op, State const &amp;v, State &amp;w);\nvoid apply(OpSum const &amp;ops, State const &amp;v, State &amp;w);\n</code></pre> <pre><code>apply(op::Op, v::State, w::State)\napply(ops::OpSum, v::State, w::State)\n</code></pre> </li> </ol>"},{"location":"documentation/algebra/apply/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator v Input State $\\vert v\\rangle  $ w Output State \\(\\vert w \\rangle = O \\vert v\\rangle\\)"},{"location":"documentation/algebra/apply/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto phi = apply(Op(\"S+\", 2), psi);\nXDIAG_SHOW(inner(ops, psi));\nXDIAG_SHOW(inner(ops, phi));\n</code></pre> <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    e0, psi = eig0(ops, block);\n    phi = apply(Op(\"S+\", 2), psi)\n    @show inner(ops, psi)\n    @show inner(ops, phi)\nend\n</code></pre>"},{"location":"documentation/algebra/matrix/","title":"matrix","text":"<p>Creates a numerical matrix with real (<code>matrix</code>) or complex (<code>matrixC</code>) coefficients given an Op or OpSum on a certain block. </p> <p>Sources matrix.hpp matrix.cpp matrix.jl</p>"},{"location":"documentation/algebra/matrix/#definition","title":"Definition","text":"<p>A matrix can be created in two ways:</p> <ol> <li> <p>Only the input block on which the operator is defined is given. The output block is calculated and eventually created automatically.</p> C++Julia <pre><code>arma::mat matrix(Op const &amp;op, Block const &amp;block);\narma::mat matrix(OpSum const &amp;ops, Block const &amp;block);\narma::cx_mat matrixC(Op const &amp;op, Block const &amp;block);\narma::cx_mat matrixC(OpSum const &amp;ops, Block const &amp;block);\n</code></pre> <pre><code>matrix(op::Op, block::Block)\nmatrix(ops::OpSum, block::Block)\n</code></pre> </li> <li> <p>The output block is also handed as an argument. The compatibility of quantum numbers is checked. This way the output block is not created automatically and, thus, can be used to save computation time if the output block appears repeatedly in the computation.</p> C++Julia <pre><code>arma::mat matrix(Op const &amp;op, Block const &amp;block_in, Block const &amp;block_out);\narma::mat matrix(OpSum const &amp;ops, Block const &amp;block_in, Block const &amp;block_out);\narma::cx_mat matrixC(Op const &amp;op, Block const &amp;block_in, Block const &amp;block_out);\narma::cx_mat matrixC(OpSum const &amp;ops, Block const &amp;block_in, Block const &amp;block_out);\n</code></pre> <pre><code>matrix(op::Op, block_in::Block, block_out::Block)\nmatrix(ops::OpSum, block_in::Block, block_out::Block)\n</code></pre> </li> </ol> <p>Comment: In Julia, depending on whether a real/complex matrix is generated also a  real/complex matrix is returned. The C++ version has to return a fixed type. If a real matrix is desired, use the function <code>matrix</code>. If a complex matrix is desired, use the function <code>matrixC</code>.</p>"},{"location":"documentation/algebra/matrix/#parameters","title":"Parameters","text":"Name Description ops OpSum or Op defining the operator block / block_in input block on which the operator is defined block_out output block the operator maps the input block to"},{"location":"documentation/algebra/matrix/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>// Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\nint N = 4;\nint nup = 3;\nint ndn = 2;\n\n// Define a Hubbard chain model\nauto ops = OpSum();\nfor (int i=0; i&lt; N; ++i){\n  ops += \"T\" * Op(\"Hop\", {i, (i+1) % N});\n}\nops+= \"U\" * Op(\"HubbardU\");\nops[\"T\"] = 1.0;\nops[\"U\"] = 5.0;\n\n// Create the a permutation group\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1.0, -1.0, 1.0, -1.0});\nauto block = Electron(N, nup, ndn, irrep);\nauto H = matrix(ops, block);\nH.print();\n</code></pre> <pre><code>let\n    # Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\n    N = 4\n    nup = 3\n    ndn = 2\n\n    # Define a Hubbard chain model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"T\" * Op(\"Hop\", [i, mod1(i+1, N)])\n    end\n    ops += \"U\" * Op(\"HubbardU\")\n    ops[\"T\"] = 1.0;\n    ops[\"U\"] = 5.0;\n\n    # Create the a permutation group\n    p = Permutation([2, 3, 4, 1])\n    group = PermutationGroup([p^0, p^1, p^2, p^3])\n    irrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\n    block = Electron(N, nup, ndn, irrep)\n\n    H = matrix(ops, block)\n    display(H)\nend\n</code></pre>"},{"location":"documentation/algorithms/eig0/","title":"eig0","text":"<p>Computes the groud state energy and the ground state of a Hermitian operator on a block by using an iterative Lanczos algorithm. This function is a shortcut for the eigs_lanczos function. We refer to eigs_lanczos for further details on the algorithm and the convergence criterion.</p> <p>Sources sparse_diag.hpp sparse_diag.cpp sparse_diag.jl</p>"},{"location":"documentation/algorithms/eig0/#definition","title":"Definition","text":"C++Julia <pre><code>std::tuple&lt;double, State&gt; eig0(OpSum const &amp;ops, Block const &amp;block,\n    double precision = 1e-12, int64_t max_iterations = 1000, \n    int64_t random_seed = 42);\n</code></pre> <pre><code>eig0(ops::OpSum, block::Block;  precision::Float64 = 1e-12, \n     max_iterations::Int64 = 1000, random_seed::Int64 = 42)\n</code></pre>"},{"location":"documentation/algorithms/eig0/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining a Hermitian operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eig0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue of <code>ops</code> State groundstate"},{"location":"documentation/algorithms/eig0/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\nauto [e0, gs] = eig0(ops, block);\n</code></pre> <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n    e0, gs = eig0(ops, block);\nend\n</code></pre>"},{"location":"documentation/algorithms/eigs_lanczos/","title":"eigs_lanczos","text":"<p>Performs an iterative eigenvalue calculation building eigenvectors using the Lanczos algorithm. Returns the tridiagonal matrix, eigenvalues, number of iterations and the stopping criterion. The Lanczos interations are performed twice, where at the second run the eigenvectors are built.</p> <p>Sources eigs_lanczos.hpp eigs_lanczos.cpp eigs_lanczos.jl</p>"},{"location":"documentation/algorithms/eigs_lanczos/#definition","title":"Definition","text":"<p>The Lanczos algorithm can be run in two distinct ways:</p> <ol> <li> <p>A random intial state \\(|\\psi_0\\rangle = |r\\rangle\\) with normal distributed entries is used.</p> C++Julia <pre><code>EigsLanczosResult\neigs_lanczos(OpSum const &amp;ops, Block const &amp;block, int64_t neigvals = 1,\n             double precision = 1e-12, int64_t max_iterations = 1000,\n             double deflation_tol = 1e-7, int64_t random_seed = 42);\n</code></pre> <pre><code>eigs_lanczos(ops::OpSum, block::Block; neigvals::Int64 = 1,\n             precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n             deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified</p> C++ <p><pre><code>EigsLanczosResult \neigs_lanczos(OpSum const &amp;ops, State const &amp;psi0, int64_t neigvals = 1,\n             double precision = 1e-12, int64_t max_iterations = 1000,\n             double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigs_lanczos(ops::OpSum, psi0::State; neigvals::Int64 = 1,\n             precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n             deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre></p> </li> </ol>"},{"location":"documentation/algorithms/eigs_lanczos/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining the bonds of the operator block block on which the operator is defined psi0 Initial State from which the Lanczos algorithm is started neigvals number of eigenvalues to converge 1 precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigs_lanczos/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description alphas diagonal elements of the tridiagonal matrix betas off-diagonal elements of the tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix eigenvectors State of shape $D \\times $<code>neigvals</code> holding all low-lying eigenvalues up to <code>neigvals</code> niterations number of iterations performed criterion string denoting the reason why the algorithm stopped"},{"location":"documentation/algorithms/eigs_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm terminates if the \\(k\\)-th (\\(k\\) is the argument <code>neigvals</code>) approximate eigenvalue changes only by a fraction smaller than \\(\\epsilon\\) (\\(k\\) is the argument <code>precision</code>), i.e.</p> \\[ (\\tilde{e}_k^{(n)} - \\tilde{e}_k^{(n-1)}) / \\tilde{e}_k^{(n)} &lt; \\epsilon.\\] <p>Here, \\(\\tilde{e}_k^{(n)}\\) denotes the Lanczos approximation to the \\(k\\)-th eigenvalue after \\(n\\) iterations.</p>"},{"location":"documentation/algorithms/eigs_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n\n// With random intial state\nauto res = eigs_lanczos(ops, block);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\nXDIAG_SHOW(res.eigenvectors);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    # With random intial state\n    res = eigs_lanczos(ops, block)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\n    @show res.eigenvectors\nend\n</code></pre>"},{"location":"documentation/algorithms/eigval0/","title":"eigval0","text":"<p>Computes the groud state energy of a Hermitian operator on a block by using an iterative Lanczos algorithm. This function is a shortcut for the eigvals_lanczos function. We refer to eigvals_lanczos for further details on the algorithm and the convergence criterion.</p> <p>Sources sparse_diag.hpp sparse_diag.cpp sparse_diag.jl</p>"},{"location":"documentation/algorithms/eigval0/#definition","title":"Definition","text":"C++Julia <pre><code>double eigval0(OpSum const &amp;ops, Block const &amp;block, double precision = 1e-12,\n               int64_t max_iterations = 1000, int64_t random_seed = 42);\n</code></pre> <pre><code>eigval0(ops::OpSum, block::Block;   precision::Float64 = 1e-12, \n        max_iterations::Int64 = 1000, random_seed::Int64 = 42)::Float64\n</code></pre>"},{"location":"documentation/algorithms/eigval0/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining a Hermitian operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigval0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue of <code>ops</code>"},{"location":"documentation/algorithms/eigval0/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\ndouble e0 = eigval0(ops, block);\n</code></pre> <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n    e0 = eigval0(ops, block);\nend\n</code></pre>"},{"location":"documentation/algorithms/eigvals_lanczos/","title":"eigvals_lanczos","text":"<p>Performs an iterative eigenvalue calculation using the Lanczos algorithm. Returns the tridiagonal matrix, eigenvalues, number of iterations and the stopping criterion.</p> <p>Sources eigvals_lanczos.hpp eigvals_lanczos.cpp eigvals_lanczos.jl</p>"},{"location":"documentation/algorithms/eigvals_lanczos/#definition","title":"Definition","text":"<p>The Lanczos algorithm can be run in thre distinct ways:</p> <ol> <li> <p>A random intial state \\(|\\psi_0\\rangle = |r\\rangle\\) with normal distributed entries is used.</p> C++Julia <pre><code>EigvalsLanczosResult\neigvals_lanczos(OpSum const &amp;ops, Block const &amp;block, int64_t neigvals = 1,\n                double precision = 1e-12, int64_t max_iterations = 1000,\n                double deflation_tol = 1e-7, int64_t random_seed = 42);\n</code></pre> <pre><code>eigvals_lanczos(ops::OpSum, block::Block; neigvals::Int64 = 1, \n                precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified. </p> C++Julia <pre><code>EigvalsLanczosResult \neigvals_lanczos(OpSum const &amp;ops, State psi0, int64_t neigvals = 1,\n                double precision = 1e-12, int64_t max_iterations = 1000,\n                double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigvals_lanczos(ops::OpSum, psi0::State; neigvals::Int64 = 1, \n                precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                deflation_tol::Float64 = 1e-7)\n</code></pre> <p>Notice this version copies the initial state, which requires memory but keeps the orginal state intact.</p> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified and overwritten in the process. This version can save memory, but the initial state  \\(|\\psi_0\\rangle\\) cannot be used later.</p> C++Julia <pre><code>EigvalsLanczosResult \neigvals_lanczos_inplace(OpSum const &amp;ops, State &amp;psi0, int64_t neigvals = 1,\n                        double precision = 1e-12, int64_t max_iterations = 1000,\n                        double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigvals_lanczos_inplace(ops::OpSum, psi0::State; neigvals::Int64 = 1, \n                        precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                        deflation_tol::Float64 = 1e-7)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/eigvals_lanczos/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining the bonds of the operator block block on which the operator is defined psi0 Initial State from which the Lanczos algorithm is started neigvals number \\(k\\) of eigenvalue to converge 1 precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigvals_lanczos/#returns","title":"Returns","text":"<p>A struct of type <code>EigvalsLanczosResult</code> with the following entries.</p> Entry Description alphas diagonal elements of the tridiagonal matrix betas off-diagonal elements of the tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix niterations number of iterations performed criterion string denoting the reason why the algorithm stopped"},{"location":"documentation/algorithms/eigvals_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm terminates if the \\(k\\)-th (\\(k\\) is the argument <code>neigvals</code>) approximate eigenvalue changes only by a fraction smaller than \\(\\epsilon\\) (\\(k\\) is the argument <code>precision</code>), i.e.</p> \\[ (\\tilde{e}_k^{(n)} - \\tilde{e}_k^{(n-1)}) / \\tilde{e}_k^{(n)} &lt; \\epsilon.\\] <p>Here, \\(\\tilde{e}_k^{(n)}\\) denotes the Lanczos approximation to the \\(k\\)-th eigenvalue after \\(n\\) iterations.</p>"},{"location":"documentation/algorithms/eigvals_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n\n// With random intial state\nauto res = eigvals_lanczos(ops, block);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\n\n// With specific initial state\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\nauto res2 = eigvals_lanczos(ops, psi0);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    # With random intial state\n    res = eigvals_lanczos(ops, block)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\n\n    # With specific initial state\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    res2 = eigvals_lanczos(ops, psi0)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\nend\n</code></pre>"},{"location":"documentation/algorithms/evolve_lanczos/","title":"evolve_lanczos","text":"<p>Computes the exponential of a Hermitian operator \\(H\\) with an arbitrary real or complex prefactor \\(z\\) applied to a State \\(\\vert \\psi_0\\rangle\\), </p> \\[\\vert \\psi(z) \\rangle = e^{z(H - \\delta)} \\vert \\psi_0\\rangle.\\] <p>Here, \\(\\delta\\) denotes a real number shifting the spectrum of \\(H\\). The algorithm implemented is described in the following publication.</p> <p>On Krylov Subspace Approximations to the Matrix Exponential Operator Marlis Hochbruck and Christian Lubich SIAM Journal on Numerical Analysis, Vol. 34, Iss. 5 (1997) DOI: 10.1137/S0036142995280572</p> <p>Sources evolve_lanczos.hpp evolve_lanczos.cpp evolve_lanczos.jl</p>"},{"location":"documentation/algorithms/evolve_lanczos/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>EvolveLanczosResult\nevolve_lanczos(OpSum const &amp;H, State psi, double t, double precision = 1e-12,\n               double shift = 0., bool normalize = false,\n               int64_t max_iterations = 1000, double deflation_tol = 1e-7);\n\nEvolveLanczosResult\nevolve_lanczos(OpSum const &amp;H, State psi, complex z, double precision = 1e-12,\n               double shift = 0., bool normalize = false,\n               int64_t max_iterations = 1000, double deflation_tol = 1e-7);\n</code></pre> <pre><code>evolve_lanczos(H::OpSum, psi::State, t::Float64; precision::Float64 = 1e-12,\n               shift::Float64=0.0, normalize::Bool=false,\n               max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n\nevolve_lanczos(H::OpSum, psi::State, z::ComplexF64; precision::Float64 = 1e-12,\n               shift::Float64=0.0, normalize::Bool=false,\n               max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n</code></pre> </li> <li> <p>An inplace variant <code>evolve_lanczos_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>evolve_lanczos</code>.</p> C++Julia <pre><code>EvolveLanczosInplaceResult\nevolve_lanczos_inplace(OpSum const &amp;H, State &amp;psi, double t, \n                       double precision = 1e-12, double shift = 0.,\n                       bool normalize = false, int64_t max_iterations = 1000, \n                       double deflation_tol = 1e-7);\n\nEvolveLanczosInplaceResult\nevolve_lanczos_inplace(OpSum const &amp;H, State &amp;psi, complex z, \n                       double precision = 1e-12, double shift = 0.,\n                       bool normalize = false, int64_t max_iterations = 1000, \n                       double deflation_tol = 1e-7);\n</code></pre> <pre><code>evolve_lanczos_inplace(H::OpSum, psi::State, t::Float64; precision::Float64 = 1e-12,\n                       shift::Float64=0.0, normalize::Bool=false,\n                       max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n\nevolve_lanczos_inplace(H::OpSum, psi::State, z::ComplexF64; precision::Float64 = 1e-12,\n                       shift::Float64=0.0, normalize::Bool=false,\n                       max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/evolve_lanczos/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(\\tau\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(t) \\rangle\\) 1e-12 shift the offset \\(\\delta\\) when computing \\(\\vert \\psi(t) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle\\) 0.0 normalize flag whether or not the evolved state should be normalized false max_iterations maximum number of Lanczos iterations performed 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 <p>The parameter <code>shift</code> can be used to turn all eigenvalues of the matrix \\(H - \\delta \\;\\textrm{Id}\\) positive whenever \\(\\delta &lt; E_0\\), where \\(E_0\\) denotes the ground state energy of \\(H\\).</p>"},{"location":"documentation/algorithms/evolve_lanczos/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description alphas diagonal elements of the Lanczos tridiagonal matrix betas off-diagonal elements of the Lanczos tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix niterations number of iterations performed criterion string denoting the reason why the Lanczosalgorithm stopped state time-evolved State \\(\\vert \\psi(t)\\rangle\\) (not defined for inplace variant)"},{"location":"documentation/algorithms/evolve_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm is estimating the following error,</p> \\[ \\varepsilon = \\parallel \\vert \\tilde{\\psi}(t)\\rangle - e^{z(H - \\delta)} \\vert \\psi_0\\rangle \\parallel_2, \\] <p>where \\(\\vert \\tilde{\\psi}(t) \\rangle\\) denotes the approximation computed during the algorithm. As the exact solution is not available this error is estimated using the method described by Algorithm 2 in</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p>"},{"location":"documentation/algorithms/evolve_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\n// Compute ground state energy\ndouble e0 = eigval0(ops, block);\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-12;\nauto res = evolve_lanczos(ops, psi0, time, precision, e0, true, 500);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    # Compute ground state energy\n    e0 = eigval0(ops, block)\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    res = evolve_lanczos(ops, psi0, time, precision=1e-12, shift=e0, normalize=true)\n    @show res.alphas\n    @show res.betas\nend\n</code></pre>"},{"location":"documentation/algorithms/imaginary_time_evolve/","title":"imaginary_time_evolve","text":"<p>Computes the imaginary-time evolution, </p> \\[\\vert \\psi(\\tau) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using an iterative algorithm. \\(\\delta\\) here denotes a real number which can be chosen as the ground state energy \\(\\delta=E_0\\) of \\(H\\).</p> <p>Sources imaginary_time_evolve.hpp imaginary_time_evolve.cpp imaginary_time_evolve.jl</p>"},{"location":"documentation/algorithms/imaginary_time_evolve/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>State imaginary_time_evolve(OpSum const &amp;H, State psi0, double time,\n                            double precision = 1e-12, double shift = 0.);\n</code></pre> <pre><code>imaginary_time_evolve(ops::OpSum, psi0::State, time::Float64; precision::Float64 = 1e-12, \n                      shift::Float64=0.0)::State\n</code></pre> </li> <li> <p>An inplace variant <code>imaginary_time_evolve_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>imaginary_time_evolve</code>.</p> C++Julia <pre><code>void imaginary_time_evolve_inplace(OpSum const &amp;H, State &amp;psi0, double time,\n                                   double precision = 1e-12, shift = 0.);\n</code></pre> <pre><code>imaginary_time_evolve_inplace(ops::OpSum, psi0::State, time::Float64; \n                              precision::Float64 = 1e-12, shift::Float64=0.0)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/imaginary_time_evolve/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(\\tau\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(\\tau) \\rangle\\) 1e-12 shift the offset \\(\\delta\\) when computing \\(\\vert \\psi(t) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle\\) 0.0 <p>The routine calls the subroutine evolve_lanczos implementing a Lanczos algorithm to perform the evolution. This routine can also be called explicitly if more control is desired. Please also confer to the page evolve_lanczos for further details on the specifics of the algorithm. The parameter <code>shift</code> can be used to turn all eigenvalues of the matrix \\(H - \\delta \\;\\textrm{Id}\\) positive whenever \\(\\delta &lt; E_0\\), where \\(E_0\\) denotes the ground state energy of \\(H\\).</p>"},{"location":"documentation/algorithms/imaginary_time_evolve/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\n// Compute ground state energy\ndouble e0 = eigval0(ops, block);\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-12;\nauto psi = imaginary_time_evolve(ops, psi0, time, precision, e0);\nimaginary_time_evolve_inplace(ops, psi0, time, precision, e0);\nXDIAG_SHOW(isapprox(psi0, psi));\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    # Compute ground state energy\n    e0 = eigval0(ops, block)\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    psi = imaginary_time_evolve(ops, psi0, time,\n                                precision=1e-12, shift=e0)\n    imaginary_time_evolve_inplace(ops, psi0, time, precision=1e-12, shift=e0)\n    @show isapprox(psi0, psi)\nend\n</code></pre>"},{"location":"documentation/algorithms/time_evolve/","title":"time_evolve","text":"<p>Computes the real-time evolution, </p> \\[\\vert \\psi(t) \\rangle = e^{-iHt} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using an iterative algorithm. </p> <p>Sources time_evolve.hpp time_evolve.cpp time_evolve.jl</p>"},{"location":"documentation/algorithms/time_evolve/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>State time_evolve(OpSum const &amp;H, State psi0, double time,\n                  double precision = 1e-12,\n                  std::string algorithm = \"lanczos\");\n</code></pre> <pre><code>time_evolve(ops::OpSum, psi0::State, time::Float64; \n            precision::Float64 = 1e-12, \n            algorithm::String = \"lanczos\")::State\n</code></pre> </li> <li> <p>An inplace variant <code>time_evolve_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>time_evolve</code>.</p> C++Julia <pre><code>void time_evolve_inplace(OpSum const &amp;H, State &amp;psi0, double time,\n                         double precision = 1e-12,\n                         std::string algorithm = \"lanczos\");\n</code></pre> <pre><code>time_evolve_inplace(ops::OpSum, psi0::State, time::Float64; \n                    precision::Float64 = 1e-12, \n                    algorithm::String = \"lanczos\")\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/time_evolve/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(t\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(t) \\rangle\\) 1e-12 algorithm iterative algorithm which is used, one of <code>lanczos</code> or <code>expokit</code> <code>lanczos</code> <p>The <code>algorithm</code> parameter decised which backend is run. If <code>lanczos</code> is chosen, the evolve_lanczos routine is called with the standard arguments. Alternatively, <code>expokit</code> chooses the time_evolve_expokit routine. For a detailed documentation of the algorithms we refer to the evolve_lanczos and time_evolve_expokit pages. Broadly speaking, the <code>expokit</code> can yield higher precision states at arbitrarily long times at the cost of increased memory and computing time. In practice, we recommend analysing the effect of the <code>precision</code> parameters on the time evolution series obtained in both cases. </p>"},{"location":"documentation/algorithms/time_evolve/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\nauto psi = time_evolve(ops, psi0, time);\ntime_evolve_inplace(ops, psi0, time);\nXDIAG_SHOW(isapprox(psi0, psi));\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    psi = time_evolve(ops, psi0, time)\n    time_evolve_inplace(ops, psi0, time)\n    @show isapprox(psi0, psi)\nend\n</code></pre>"},{"location":"documentation/algorithms/time_evolve_expokit/","title":"time_evolve_expokit","text":"<p>Computes the real-time evolution, </p> \\[\\vert \\psi(t) \\rangle = e^{-iHt} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using the iterative algorithm implemented by Expokit</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p> <p>The algorithm features automatic stepsize control and computes approximate solutions with high precision according to our tests. Yet, the evolve_lanczos implementation is currently faster and more memory efficient. </p> <p>Sources time_evolve_expokit.hpp time_evolve_expokit.cpp time_evolve_expokit.jl</p>"},{"location":"documentation/algorithms/time_evolve_expokit/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>TimeEvolveExpokitResult time_evolve_expokit(\n    OpSum const &amp;ops, State state, double time, double precision = 1e-12,\n    int64_t m = 30, double anorm = 0., int64_t nnorm = 2);\n</code></pre> <pre><code>time_evolve_expokit(ops::OpSum, state::State, time::Float64;\n                    precision::Float64=1e-12, m::Int64 = 30, \n                    anorm::Float64 = 0.0, nnorm::Int64 = 2)\n</code></pre> </li> <li> <p>An inplace variant <code>time_evolve_expokit_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>time_evolve_expokit</code>.</p> C++Julia <pre><code>TimeEvolveExpokitInplaceResult time_evolve_expokit_inplace(\n    OpSum const &amp;ops, State &amp;state, double time, double precision = 1e-12,\n    int64_t m = 30, double anorm = 0., int64_t nnorm = 2);\n</code></pre> <pre><code>time_evolve_expokit_inplace(ops::OpSum, state::State, time::Float64;\n                            precision::Float64=1e-12, m::Int64 = 30, \n                            anorm::Float64 = 0.0, nnorm::Int64 = 2)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/time_evolve_expokit/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(t\\) until which the state is evolved precision accuracy of the computed time evolved state 1e-12 m dimension of used Krylov space, main memory requirement 30 anorm 1-norm estimate of the operator \\(H\\), if unknown default 0. computes it fresh 0. nnorm number of random samples to estimate 1-norm, usually not more than 2 required 2"},{"location":"documentation/algorithms/time_evolve_expokit/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description error the computed error estimate during evolution hump the \"hump\" as defined in Expokit 10.1145/285861.285868 state time-evolved State \\(\\vert \\psi(t)\\rangle\\) (not defined for inplace variant)"},{"location":"documentation/algorithms/time_evolve_expokit/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm is estimating the following error,</p> \\[ \\varepsilon = \\parallel \\vert \\tilde{\\psi}(t)\\rangle - e^{z(H - \\delta)} \\vert \\psi_0\\rangle \\parallel_2, \\] <p>where \\(\\vert \\tilde{\\psi}(t) \\rangle\\) denotes the approximation computed during the algorithm. As the exact solution is not available this error is estimated using the method described by Algorithm 2 in</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p>"},{"location":"documentation/algorithms/time_evolve_expokit/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-8;\nauto res1 = time_evolve_expokit(ops, psi0, time, precision);\nauto res2 = time_evolve_expokit_inplace(ops, psi0, time, precision);\nXDIAG_SHOW(isapprox(psi0, res1.state));\nXDIAG_SHOW(res1.error);\nXDIAG_SHOW(res1.hump);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    res1 = time_evolve_expokit(ops, psi0, time, precision=1e-8)\n    res2 = time_evolve_expokit_inplace(ops, psi0, time, precision=1e-8)\n    @show isapprox(psi0, res1.state)\n    @show res1.error\n    @show res1.hump\nend\n</code></pre>"},{"location":"documentation/blocks/electron/","title":"Electron","text":"<p>A block in an Electron (fermions with \\(\\uparrow, \\downarrow\\) spin) Hilbert space. </p> <p>Sources electron.hpp, electron.cpp</p>"},{"location":"documentation/blocks/electron/#constructors","title":"Constructors","text":"C++Julia <pre><code>Electron(int64_t nsites, std::string backend = \"auto\");\nElectron(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\nElectron(int64_t nsites, Representation irrep, std::string backend = \"auto\");\nElectron(int64_t nsites, int64_t nup, int64_t ndn, Representation irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>Electron(nsites::Int64, backend::String=\"auto\")\nElectron(nsites::Int64, nup::Int64, ndn::Int64, backend::String=\"auto\")\nElectron(nsites::Int64, irrep::Representation, backend::String=\"auto\")\nElectron(nsites::Int64, nup::Int64, ndn::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code></p>"},{"location":"documentation/blocks/electron/#iteration","title":"Iteration","text":"<p>An Electron block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = Electron(4, 2, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre> <pre><code>block = Electron(4, 2, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/electron/#methods","title":"Methods","text":""},{"location":"documentation/blocks/electron/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJ block.</p> C++Julia <pre><code>int64_t index(tJ const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::tJ, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/electron/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(tJ const &amp;block);\n</code></pre> <pre><code>nsites(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(tJ const &amp;block) const;\n</code></pre> <pre><code>size(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(tJ const &amp;block) const;\n</code></pre> <pre><code>dim(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(tJ const &amp;block);\n</code></pre> <pre><code>isreal(block::tJ)::Bool\n</code></pre>"},{"location":"documentation/blocks/electron/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without number conservation\nauto block = Electron(N);\nXDIAG_SHOW(block);\n\n// with number conservation\nauto block_np = Electron(N, nup, ndn);\nXDIAG_SHOW(block_np);\n\n// with symmetries, without number conservation\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1, -1, 1, -1});\nauto block_sym = Electron(N, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and number conservation\nauto block_sym_np = Electron(N, nup, ndn, irrep);\nXDIAG_SHOW(block_sym_np);\nXDIAG_SHOW(block_sym_np.nsites());\nXDIAG_SHOW(block_sym_np.size());\n\n// Iteration\nfor (auto pstate : block_sym_np) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym_np, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without number conservation\nblock = Electron(N)\n@show block\n\n# with number conservation\nblock_np = Electron(N, nup, ndn)\n@show block_np\n\n# with symmetries, without number conservation\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = Electron(N, rep)\n@show block_sym\n\n# with symmetries and number conservation\nblock_sym_np = Electron(N, nup, ndn, rep)\n@show block_sym_np\n@show nsites(block_sym_np)\n@show size(block_sym_np)\n\n# Iteration\nfor pstate in block_sym_np\n    @show pstate, index(block_sym_np, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf/","title":"Spinhalf","text":"<p>A block in a spin \\(S=1/2\\)  Hilbert space. </p> <p>Sources spinhalf.hpp spinhalf.cpp spinhalf.jl</p>"},{"location":"documentation/blocks/spinhalf/#constructors","title":"Constructors","text":"C++Julia <pre><code>Spinhalf(int64_t nsites, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, int64_t nup, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, Representation const &amp;irrep, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, int64_t nup, Representation const &amp;irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>Spinhalf(nsites::Int64, backend::String=\"auto\")\nSpinhalf(nsites::Int64, nup::Int64, backend::String=\"auto\")\nSpinhalf(nsites::Int64, irrep::Representation, backend::String=\"auto\")\nSpinhalf(nsites::Int64, nup::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" spin setting spin (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>, <code>1sublattice</code>, <code>2sublattice</code>, <code>3sublattice</code>, <code>4sublattice</code>, and <code>5sublattice</code>. The backends <code>xsublattice</code> implement the sublattice coding algorithm described in Wietek, L\u00e4uchli, Phys. Rev. E 98, 033309 (2018). The sublattice coding algorithms impose certain constraints on the symmetries used, as described in the reference. </p>"},{"location":"documentation/blocks/spinhalf/#iteration","title":"Iteration","text":"<p>An Spinhalf block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = Spinhalf(4, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre> <pre><code>block = Spinhalf(4, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#methods","title":"Methods","text":""},{"location":"documentation/blocks/spinhalf/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the Spinhalf block.</p> C++Julia <pre><code>int64_t index(Spinhalf const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::Spinhalf, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/spinhalf/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(Spinhalf const &amp;block);\n</code></pre> <pre><code>nsites(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(Spinhalf const &amp;block) const;\n</code></pre> <pre><code>size(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(Spinhalf const &amp;block) const;\n</code></pre> <pre><code>dim(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(Spinhalf const &amp;block);\n</code></pre> <pre><code>isreal(block::Spinhalf)::Bool\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\n\n// without Sz conservation\nauto block = Spinhalf(N);\nXDIAG_SHOW(block);\n\n// with Sz conservation\nauto block_sz = Spinhalf(N, nup);\nXDIAG_SHOW(block_sz);\n\n// with symmetries, without Sz\nPermutation p1 = {0, 1, 2, 3};\nPermutation p2 = {1, 2, 3, 0};\nPermutation p3 = {2, 3, 0, 1};\nPermutation p4 = {3, 0, 1, 2};\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec({1, -1, 1, -1}));\nauto block_sym = Spinhalf(N, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and Sz\nauto block_sym_sz = Spinhalf(N, nup, irrep);\nXDIAG_SHOW(block_sym_sz);\n\nXDIAG_SHOW(block_sym_sz.nsites());\nXDIAG_SHOW(block_sym_sz.size());\n\n// Iteration\nfor (auto pstate : block_sym_sz) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym_sz, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\n\n# without Sz conservation\nblock = Spinhalf(N)\n@show block\n\n# with Sz conservation\nblock_sz = Spinhalf(N, nup)\n@show block_sz\n\n# with symmetries, without Sz\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = Spinhalf(N, rep)\n@show block_sym\n\n# with symmetries and Sz\nblock_sym_sz = Spinhalf(N, nup, rep)\n@show block_sym_sz\n@show nsites(block_sym_sz)\n@show size(block_sym_sz)\n\n# Iteration\nfor pstate in block_sym_sz\n    @show pstate, index(block_sym_sz, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/","title":"SpinhalfDistributed","text":"<p>A block in a spin \\(S=1/2\\) Hilbert space with distributed computing capabilities.</p> <p>Sources spinhalf_distributed.hpp, spinhalf_distributed.cpp</p>"},{"location":"documentation/blocks/spinhalf_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>SpinhalfDistributed(int64_t nsites, int64_t nup, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" spin setting spin (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/spinhalf_distributed/#iteration","title":"Iteration","text":"<p>An SpinhalfDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = SpinhalfDistributed(4, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/spinhalf_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the SpinhalfDistributed block.</p> C++ <pre><code>int64_t index(SpinhalfDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(SpinhalfDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(SpinhalfDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(SpinhalfDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(SpinhalfDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/tJ/","title":"tJ","text":"<p>A block in a  \\(t-J\\) type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin excluding doubly occupied sites. </p> <p>Sources tj.hpp tj.cpp tj.jl</p>"},{"location":"documentation/blocks/tJ/#constructors","title":"Constructors","text":"C++Julia <pre><code>tJ(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\ntJ(int64_t nsites, int64_t nup, int64_t ndn, Representation const &amp;irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>tJ(nsites::Int64, nup::Int64, ndn::Int64, backend::String=\"auto\")\ntJ(nsites::Int64, nup::Int64, ndn::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/tJ/#iteration","title":"Iteration","text":"<p>An tJ block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = tJ(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre> <pre><code>block = tJ(4, 2, 1)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/tJ/#methods","title":"Methods","text":""},{"location":"documentation/blocks/tJ/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJ block.</p> C++Julia <pre><code>int64_t index(tJ const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::tJ, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/tJ/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(tJ const &amp;block);\n</code></pre> <pre><code>nsites(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(tJ const &amp;block) const;\n</code></pre> <pre><code>size(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(tJ const &amp;block) const;\n</code></pre> <pre><code>dim(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(tJ const &amp;block);\n</code></pre> <pre><code>isreal(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without permutation symmetries\nauto block = tJ(N, nup, ndn);\nXDIAG_SHOW(block);\n\n// with permutation symmetries\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1, -1, 1, -1});\nauto block_sym = tJ(N, nup, ndn, irrep);\nXDIAG_SHOW(block_sym);\nXDIAG_SHOW(block_sym.nsites());\nXDIAG_SHOW(block_sym.size());\n\n// Iteration\nfor (auto pstate : block_sym) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without permutation symmetries\nblock = tJ(N, nup, ndn)\n@show block\n\n# with permutation symmetries\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = tJ(N, nup, ndn, rep)\n@show block_sym\n\n@show nsites(block_sym)\n@show size(block_sym)\n\n# Iteration\nfor pstate in block_sym\n    @show pstate, index(block_sym, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/","title":"tJDistributed","text":"<p>A block in a  \\(t-J\\) type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin excluding doubly occupied sites with distributed computing capabilities. </p> <p>Sources tj_distributed.hpp, tj_distributed.cpp</p>"},{"location":"documentation/blocks/tJ_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>tJDistributed(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/tJ_distributed/#iteration","title":"Iteration","text":"<p>An tJDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = tJDistributed(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/tJ_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJDistributed block.</p> C++ <pre><code>int64_t index(tJDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(tJDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(tJDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(tJDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(tJDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/compilation/building_documentation/","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To install it please run the following commands, <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre></p> <p>To work on the documentation locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"documentation/compilation/compilation/","title":"Compilation","text":""},{"location":"documentation/compilation/compilation/#library-compilation","title":"Library Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. The library can be compiled in two different versions:</p> <ul> <li>Normal library: features parallelization using OpenMP only</li> <li>Distributed library: features distributed-memory parallelization using MPI. </li> </ul>"},{"location":"documentation/compilation/compilation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"documentation/compilation/compilation/#download","title":"Download","text":"<p>The source code can be downloaded from Github using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p>"},{"location":"documentation/compilation/compilation/#default-library","title":"Default library","text":"<p><pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre> By default, the library is now installed in the subdirectory <code>install</code> of your XDiag path <code>/path/to/where/xdiag/should/be</code>. If you would like to install it to another directory, you could set up the CMake compilation using,</p> <pre><code>cmake -S . -B build -D CMAKE_INSTALL_PREFIX=/path/to/where/you/want/xdiag/installed\ncmake --build build\ncmake --install build\n</code></pre>"},{"location":"documentation/compilation/compilation/#distributed-library","title":"Distributed library","text":"<p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p>"},{"location":"documentation/compilation/compilation/#application-compilation","title":"Application Compilation","text":"<p>Once an application program is written, we next need to set up the compilation instructions using CMake. To do so we a second file called <code>CMakeLists.txt</code> in the application directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(xdiag_application)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/xdiag/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used with little alteration to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our XDiag application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"documentation/compilation/compilation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Shared / Static libraries</p> <p>XDiag can be built either as a static or shared library. By default, a static library is built. To build a shared library, use the option XDIAG_SHARED_LIBS, e.g. <pre><code>cmake -S . -B build -D XDIAG_SHARED_LIBS=On\n</code></pre> Typically, shared libraries can reduce the size of the executable and are often prefered. However, when building an application and linking to a static library, the resulting binary can be used standalone, without the shared library needing to be loaded. This means once an application code is compiled, it will run the same way indefinitely, even if the XDiag library changes. Thus, it is mostly more convenient to link against the static library.</p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building examples</p> <p>To compile and run the example programs, use <pre><code>cmake -S . -B build -D BUILD_EXAMPLES=On\ncmake --build build\nbuild/examples/usage_examples\n</code></pre></p> </li> </ul>"},{"location":"documentation/compilation/compilation/#optimization","title":"Optimization","text":"<ul> <li> <p>Native optimization</p> <p>Adds the flag <code>-march=native</code> to perform optimizations for the native architecture. This can have tremendous performance impact, especially on t-J models, since then the BMI2 instructions are activated whenever they are available (e.g. newer Intel and AMD processors) <pre><code>cmake -S . -B build -D XDIAG_OPTIMIZE_FOR_NATIVE=On\n</code></pre></p> </li> </ul>"},{"location":"documentation/compilation/julia_wrapper/","title":"Building the Julia wrapper","text":"<p>In order to develop and extend the julia wrapper, one should work locally and build a local version of the <code>xdiag</code> Julia binaries. First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> <p>In order to test the new shared library <code>xdiagjl</code> together with the <code>XDiag.jl</code> library, we need to override the artifact associated with the <code>XDiag_jll.jl</code> package. For this, first we need to find out which artifact is associated with <code>XDiag_jll.jl</code>. For this enter julia and type the following commands:</p> <pre><code>julia\nusing XDiag_jll\nXDiag_jll.find_artifact_dir()\n</code></pre> <p>This gives the directory in which the artifact is defined. Now we have to add a line in the <code>Overrides.toml</code> file, typically located at <code>.julia/artifacts/Overrides.toml</code>.</p> <p>Here, we then add a line like this:</p> <pre><code>55ec928f6054024a4e9bf02e74e4da8b69175655 = \"/path/to/xdiag/install\"\n</code></pre> <p>The hash is to be replaced by the directory of the <code>XDiag_jll.jl</code> artifact.</p>"},{"location":"documentation/io/file_h5/","title":"FileH5","text":"<p>A file handler for hdf5 files. The proper tool to write results of XDiag simulations to disk. Only provided for the C++ version as Julia already provides good tools handling hdf5 files.</p> <p>Sources file_h5.hpp, file_h5.cpp</p>"},{"location":"documentation/io/file_h5/#constructors","title":"Constructors","text":"C++ <pre><code>FileH5(std::string filename, std::string iomode = \"w\");\n</code></pre> Name Description Default filename filename of the hdf5 file iomode whether to read or write to file <code>w</code> <p>There are four possible values of <code>iomode</code></p> <ol> <li><code>r</code>: read-only mode</li> <li><code>w</code>: secure write mode, new file is created if it does not exist</li> <li><code>w!</code>: forced write mode, existing file will be overwritten</li> <li><code>a</code>: append mode, new datasets in an existing file can be created</li> </ol>"},{"location":"documentation/io/file_h5/#methods","title":"Methods","text":""},{"location":"documentation/io/file_h5/#getindex-operator","title":"getindex / operator[]","text":"<p>Returns a handler to a value to be read or written from or to the hdf5 file.</p> C++ <pre><code>hdf5::FileH5Handler operator[](std::string key);\n</code></pre>"},{"location":"documentation/io/file_h5/#usage-example","title":"Usage Example","text":"C++ <pre><code>std::string filename = XDIAG_DIRECTORY \"/misc/data/hdf5/write.h5\";\nauto fl = FileH5(filename, \"w!\");\n\n// Write output to the hdf5 file\nfl[\"val\"] = 12;\nfl[\"test/to\"] = 22;\nfl[\"test/to2/group\"] = 32;\nfl[\"test/to3/group2/asdf\"] = 42;\n\nauto mat = arma::cx_mat(3, 5, arma::fill::randn);\nfl[\"a/b/c/mat\"] = mat;\n</code></pre>"},{"location":"documentation/io/file_toml/","title":"FileToml","text":"<p>A file handler for TOML files. Most funtionality is only provided for the C++ version as Julia already provides good tools handling TOML files.</p> <p>Sources file_toml.hpp, file_toml.cpp</p>"},{"location":"documentation/io/file_toml/#constructors","title":"Constructors","text":"C++Julia <pre><code>FileToml(const char *filename);\nFileToml(std::string filename);\n</code></pre> <pre><code>FileToml(filename::String)\n</code></pre> Name Description Default filename filename of the TOML file"},{"location":"documentation/io/file_toml/#methods","title":"Methods","text":""},{"location":"documentation/io/file_toml/#defined","title":"defined","text":"<p>Returns whether or not the TOML file has a certain key defined.</p> C++ <pre><code>bool defined(FileToml const &amp;fl, std::string key);\n</code></pre>"},{"location":"documentation/io/file_toml/#getindex-operator-c-only","title":"getindex / operator[] (C++ only)","text":"<p>Returns a handler to a value to be read from the TOML file.</p> C++ <pre><code>io::FileTomlHandler operator[](std::string key);\n</code></pre>"},{"location":"documentation/io/file_toml/#usage-example","title":"Usage Example","text":"C++ <pre><code>auto fl = FileToml(XDIAG_DIRECTORY \"/misc/data/toml/input.toml\");\nXDIAG_SHOW(defined(fl, \"N\"));\n\nint N = fl[\"N\"].as&lt;int&gt;();\nint nup = fl[\"nup\"].as&lt;int&gt;();\ndouble J1 = fl[\"J1\"].as&lt;double&gt;();\ndouble J2 = fl[\"J2\"].as&lt;double&gt;();\n\nauto block = Spinhalf(N, nup);\nauto H = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  H += J1 * Op(\"SdotS\", {i, (i+1)%N});\n  H += J2 * Op(\"SdotS\", {i, (i+2)%N});\n}\ndouble e0 = eigval0(H, block);\nXDIAG_SHOW(e0);\n</code></pre>"},{"location":"documentation/io/read_opsum/","title":"read_opsum","text":"<p>Reads an OpSum object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_opsum/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_opsum(FileToml file, std::string tag);\n</code></pre> <pre><code>read_opsum(file::FileToml, tag::String)::OpSum\n</code></pre>"},{"location":"documentation/io/read_opsum/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the OpSum is read tag tag which holds the information in the TOML file about the OpSum"},{"location":"documentation/io/read_opsum/#data-format","title":"Data format","text":"<p>An OpSum can be defined in a TOML file as a simple list. The entries of the list are themselves also lists, which contain two or more entries:</p> <ol> <li>The first entry must be either a string or a real / complex number denoting the coupling constant of the term.</li> <li>The second entry must be a string and denotes the operator type</li> <li>The (optional) following entries are integer numbers which denote the sites of the Op</li> </ol> <p>Here is typical example of a OpSum specification in a TOML file:</p> <pre><code>Interactions = [\n  ['J1', 'SdotS', 0, 1],\n  ['J1', 'SdotS', 1, 2],\n  ['J1', 'SdotS', 2, 0],\n  ['Jchi', 'ScalarChirality', 0, 1, 2],\n]\n</code></pre>"},{"location":"documentation/io/read_opsum/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/triangular.9.hop.sublattices.tsl.toml\";\nauto fl = FileToml(file);\nauto ops = read_opsum(fl, \"Interactions\");\nXDIAG_SHOW(ops);\n</code></pre> <pre><code>file = \"triangular.9.hop.sublattices.tsl.toml\"\nfl = FileToml(file)\nops = read_opsum(fl, \"Interactions\")\n@show ops\n</code></pre>"},{"location":"documentation/io/read_permutation_group/","title":"read_permutation_group","text":"<p>Reads an PermutationGroup object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_permutation_group/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_permutation_group(FileToml file, std::string tag);\n</code></pre> <pre><code>read_permutation_group(file::FileToml, tag::String)::PermutationGroup\n</code></pre>"},{"location":"documentation/io/read_permutation_group/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the PermutationGroup is read tag tag which holds the information in the TOML file about the PermutatioGroup"},{"location":"documentation/io/read_permutation_group/#data-format","title":"Data format","text":"<p>A  PermutationGroup can be defined in a TOML file as an integer matrix, where the rows are the integers of the permutation.</p> <p>A typical specification of a \\(C_4\\) PermutationGroup is shown here:</p> <pre><code>Symmetries = [\n  [0, 1, 2, 3],\n  [1, 2, 3, 0],\n  [2, 3, 0, 1],\n  [3, 0, 1, 2]\n]\n</code></pre> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/io/read_permutation_group/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/triangular.9.hop.sublattices.tsl.toml\";\nauto fl = FileToml(file);\nauto group = read_permutation_group(fl, \"Symmetries\");\nXDIAG_SHOW(group);\n</code></pre> <pre><code>file = \"triangular.9.hop.sublattices.tsl.toml\"\nfl = FileToml(file)\ngroup = read_permutation_group(fl, \"Symmetries\")\n@show group\n</code></pre>"},{"location":"documentation/io/read_representation/","title":"read_representation","text":"<p>Reads an Representation object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_representation/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_representation(FileToml file, std::string irrep_tag, \n                          std::string group_tag = \"Symmetries\");\n</code></pre> <pre><code>read_representation(file::FileToml, irrep_tag::String, \n                    group_tag::String = \"Symmetries\")::Representation\n</code></pre>"},{"location":"documentation/io/read_representation/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the Representation is read irrep_tag tag which holds the information about the Representation in the TOML file group_tag tag which holds the information about the PermutationGroup in the TOML file \"Symmetries\""},{"location":"documentation/io/read_representation/#data-format","title":"Data format","text":"<p>A  Representation can be defined in a TOML file by specifying up two or three things:</p> <ol> <li>The PermutationGroup as an integer matrix</li> <li>The <code>characters</code> of the representation </li> <li>(optional) the <code>allowed_symmetries</code> of the representation, i.e. a list of the number of symmetries used in the irrep. By default all symmetries of the group are used in the representation.</li> </ol> <p>A typical specification of several Representations is shown here:</p> <pre><code>    Symmetries = [\n      [0, 1, 2, 3],\n      [1, 2, 3, 0],\n      [2, 3, 0, 1],\n      [3, 0, 1, 2]\n    ]\n\n    # real irrep, momentum 0\n    [k_0]\n    characters=[1.0, 1.0, 1.0, 1.0]\n\n    # complex irrep, momentum pi/2\n    [k_pi2]\n    characters=[\n      [1.0, 0.0], \n      [0.0, 1.0], \n      [-1.0, 0.0],\n      [0.0, -1.0]\n    ]\n\n    # real irrep, momentum pi\n    [k_pi]\n    characters=[1.0, -1.0, 1.0, -1.0]\n\n    # real irrep on subgroup\n    [k_pi2_half]\n    characters=[1.0, -1.0]\n    allowed_symmetries=[0, 2]\n</code></pre> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/io/read_representation/#usage-example","title":"Usage Example","text":"<p>The example reads the representation defined in the <code>irreps.toml</code> file, whose contents are shown up in the section Data format.</p> C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/irreps.toml\";\nauto fl = FileToml(file);\n\nauto k_0 = read_representation(fl, \"k_0\");\nXDIAG_SHOW(k_0);\nXDIAG_SHOW(isreal(k_0));\n\nauto k_pi2 = read_representation(fl, \"k_pi2\");\nXDIAG_SHOW(k_pi2);\nXDIAG_SHOW(isreal(k_pi2));\n\nauto k_pi = read_representation(fl, \"k_pi\");\nXDIAG_SHOW(k_pi);\nXDIAG_SHOW(isreal(k_pi));\n\nauto k_pi2_half = read_representation(fl, \"k_pi2_half\");\nXDIAG_SHOW(k_pi2_half);\nXDIAG_SHOW(isreal(k_pi2_half));\n</code></pre> <pre><code>file = \"irreps.toml\"\nfl = FileToml(file)\n\nk_0 = read_representation(fl, \"k_0\")\n@show k_0\n@show isreal(k_0)\n\nk_pi2 = read_representation(fl, \"k_pi2\")\n@show k_pi2\n@show isreal(k_pi2)\n\nk_pi = read_representation(fl, \"k_pi\")\n@show k_pi\n@show isreal(k_pi)\n\nk_pi2_half = read_representation(fl, \"k_pi2_half\")\n@show k_pi2_half\n@show isreal(k_pi2_half)\n</code></pre>"},{"location":"documentation/operators/hc/","title":"hc","text":"<p>Returns the hermitian conjugate \\(\\mathcal{O}^\\dagger\\) of an operator \\(\\mathcal{O}\\) represented by an Op or OpSum object. Please note the details when conjugating complex couplings, outlined in OpSum # Complex couplings.</p> <p>Sources hc.hpp hc.cpp hc.jl</p>"},{"location":"documentation/operators/hc/#definition","title":"Definition","text":"C++Julia <pre><code>Op hc(Op const &amp;op)\nOpSum hc(OpSum const &amp;ops)\n</code></pre> <pre><code>hc(op::OpSum)::Op\nhc(ops::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/hc/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto cdagup = Op(\"Cdagup\", 0);\nauto sdots = Op(\"SdotS\", {0, 1});\nauto hop = (1.0 + 1.0i) * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(cdagup == hc(cdagup));\nXDIAG_SHOW(sdots == hc(sdots));\nXDIAG_SHOW(hop == hc(hop));\n</code></pre> <pre><code>cdagup = Op(\"Cdagup\", 1)\nsdots = Op(\"SdotS\", [1, 2])\nhop = (1.0 + 1.0im) * Op(\"Hop\", [1, 2])\n@show cdagup == hc(cdagup)\n@show sdots == hc(sdots)\n@show hop == hc(hop)\n</code></pre>"},{"location":"documentation/operators/op/","title":"Op","text":"<p>Object describing a single linear operator acting on a Hilbert space.</p> <p>Sources op.hpp op.cpp op.jl</p> <p>Every operator is defined by up to three paramaters:</p> <ol> <li> <p>The type of the operator. This is a string argument which determines what kind of operator is represented. A detailed overview of the available types can be found at Operator types</p> </li> <li> <p>The sites of the operator. This defines which physical sites (or orbitals) the operator acts upon. While most operator types require sites, there are also operator types (e.g. <code>HubbardU</code>) which do not need to define sites.</p> </li> <li> <p>For special interactions, it can be necessary to additionally specify a numerical matrix, which can either be real or complex. An example is the operator type <code>Matrix</code> defining generic spin interactions.</p> </li> </ol>"},{"location":"documentation/operators/op/#constructors","title":"Constructors","text":"C++Julia <pre><code>Op(std::string type);\nOp(std::string type, int64_t site);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites);\nOp(std::string type, int64_t site, arma::mat const &amp;matrix);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites, arma::mat const &amp;matrix);\nOp(std::string type, int64_t site, arma::cx_mat const &amp;matrix);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites, arma::cx_mat const &amp;matrix);\n</code></pre> <pre><code>Op(type::String)\nOp(type::String, site::Int64)\nOp(type::String, sites::Vector{Int64})\nOp(type::String, site::Int64, matrix::Matrix{Float64})\nOp(type::String, sites::Vector{Int64}, matrix::Matrix{Float64})\nOp(type::String, site::Int64, matrix::Matrix{ComplexF64})\nOp(type::String, sites::Vector{Int64}, matrix::Matrix{ComplexF64})\n</code></pre> Parameter Description type a string which denotes what kind of operator is represented sites defines on which site(s) of the lattice the operator acts on. optional matrix defines a matrix which may be needed to describe an operator. optional <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of an Op, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/operators/op/#methods","title":"Methods","text":""},{"location":"documentation/operators/op/#isreal","title":"isreal","text":"<p>Returns whether an Op is a real operator.</p> C++Julia <pre><code>bool isreal(Op const &amp;op);\n</code></pre> <pre><code>isreal(op::Op)::Bool\n</code></pre>"},{"location":"documentation/operators/op/#isapprox","title":"isapprox","text":"<p>Returns whether two Ops are approximately equal.</p> C++Julia <pre><code>bool isapprox(Op const &amp;op1, OpSum const &amp;op2, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(op1::Op, op2::Op, rtol::Float64=1e-12, atol::Float64=1e-12)::Bool\n</code></pre>"},{"location":"documentation/operators/op/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Op to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Op const &amp;op);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Op const &amp;op);\n</code></pre> <pre><code>to_string(op::Op)::String\n</code></pre>"},{"location":"documentation/operators/op/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto op = \"T\" * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(op);\n\nop = 1.23 * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(op);\n\narma::cx_mat m(arma::mat(\"0 0; 0 0\"), arma::mat(\"0 -1; 1 0\"));\nop = Op(\"Matrix\", 0, m);\nXDIAG_SHOW(op);\nXDIAG_SHOW(isreal(op));\n</code></pre> <pre><code>op = \"T\" * Op(\"Hop\", [1, 2])\n@show op\n\nop = 1.23 * Op(\"Hop\",  [1, 2])\n@show op\n\nop = Op(\"Matrix\", 1, [0 -1.0im; 1.0im 0])\n@show op\n@show isreal(op)\n</code></pre>"},{"location":"documentation/operators/operator_types/","title":"Operator types","text":""},{"location":"documentation/operators/operator_types/#list-of-operator-types","title":"List of operator types","text":"<p>Generic operators in XDiag are represented as OpSum objects made up of a coupling, which can be a real/complex number or a string, and Op objects. Every Op is defined by a <code>type</code>. Here we list all the available types implemented in XDiag, their required number of sites, and the blocks for which they are available.</p> Type Description No. of sites Blocks <code>Hop</code> A hopping term for \\(\\uparrow\\) and \\(\\downarrow\\) spins of the form $$ \\textcolor{red}{-}\\sum_{\\sigma=\\uparrow\\downarrow} (tc^\\dagger_{i\\sigma}c_{j\\sigma} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed <code>Hopup</code> A hopping term for \\(\\uparrow\\) spins of the form $$ \\textcolor{red}{-}(tc^\\dagger_{i\\uparrow}c_{j\\uparrow} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed <code>Hopdn</code> A hopping term for \\(\\downarrow\\) spins of the form $$ \\textcolor{red}{-}(tc^\\dagger_{i\\downarrow}c_{j\\downarrow} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed <code>HubbardU</code> A uniform Hubbard interaction across the full lattice of the form $$ \\sum_i n_{i\\uparrow}n_{i\\downarrow}$$ 0 Electron <code>Cdagup</code> A fermionic creation operator for an \\(\\uparrow\\) spin \\(c^\\dagger_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed <code>Cdagdn</code> A fermionic creation operator for an \\(\\downarrow\\) spin \\(c^\\dagger_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Cup</code> A fermionic annihilation operator for an \\(\\uparrow\\) spin \\(c_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed <code>Cdn</code> A fermionic annihilation operator for an \\(\\downarrow\\) spin \\(c_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Nup</code> A number operator for an \\(\\uparrow\\) spin \\(n_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed <code>Ndn</code> A number operator for an \\(\\downarrow\\) spin \\(n_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Ntot</code> A number operator \\(n_i = n_{i\\uparrow} + n_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Nupdn</code> double occupancy \\(d_i = n_{i\\uparrow} n_{i\\downarrow}\\) 1 Electron <code>NupdnNupdn</code> double occupancy correlation \\(d_id_j\\) 2 Electron <code>NtotNtot</code> A density-density interaction \\(n_i n_j\\) 2 tJ, Electron, tJDistributed <code>SdotS</code> A Heisenberg interaction of the form $$ \\mathbf{S}_i \\cdot \\mathbf{S}_j = S^x_iS^x_j + S^y_iS^y_j + S^z_iS^z_j$$ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>SzSz</code> An Ising interaction of the form $ S^z_i S^z_j $ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>Exchange</code> A spin exchange interaction of the form $$ \\frac{1}{2}(JS^+_i S^-_j + J^*S^-_iS^+_j)$$ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>Sz</code> A local magnetic moment in the \\(z\\)-direction $ S^z_i$ 1 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>S+</code> A local spin raising operator \\(S^+_i\\) 1 Spinhalf, SpinhalfDistributed <code>S-</code> A local spin lowering operator \\(S^-_i\\) 1 Spinhalf, SpinhalfDistributed <code>ScalarChirality</code> A scalar chirality interaction of the form $$ \\mathbf{S}_i \\cdot ( \\mathbf{S}_j \\times  \\mathbf{S}_k)$$ 3 Spinhalf <code>tJSzSz</code> An Ising interaction as encountered in the \\(t-J\\) model of the form $$  S^z_i S^z_j - \\frac{n_i n_j}{4}$$ 2 tJ, tJDistributed <code>tJSdotS</code> An Heisenberg  interaction as encountered in the \\(t-J\\) model of the form $$  \\mathbf{S}_i \\cdot \\mathbf{S}_j - \\frac{n_i n_j}{4}$$ 2 tJ, tJDistributed <code>Matrix</code> A generic spin interaction no an arbitrary number of sites defined via a coupling matrix arbitrary Spinhalf"},{"location":"documentation/operators/operator_types/#matrix-type","title":"Matrix type","text":"<p>The <code>Matrix</code> interaction type is a special type with whom one can define generic interactions for the Spinhalf block. In addition to the <code>type</code> and <code>sites</code> argument, also a numerical matrix is provided when constructing the Op object. The matrix describes the operator acting on the \\(2^n\\) dimensional space spanned by the \\(n\\) sites of the operator. For example, we can represent a \\(S^x\\) spin operator as,</p> C++ <pre><code>auto sx = arma::mat({{0, 1},{1, 0}});\nauto op = Op(\"Matrix\", 0, sx);\n</code></pre> <p>More generically, we can use this mechanism to construct arbitary spin interactions, e.g.   </p> C++ <pre><code>auto sx = arma::mat({{0, 1},{1, 0}});\nauto sz = arma::mat({{0.5, 1},{0, -0.5}});\n\narma::mat sxsz = arma::kron(sx, sz);\narma::mat sxszsxsz = arma::kron(sxsz, sxsz);\n\nauto op_sxsz = Op(\"Matrix\", {0, 1}, sxsz);\nauto op_sxszsxsz = Op(\"Matrix\", {0, 1, 2, 3}, sxsz);\n</code></pre> <p>Here we have been using the Kronecker product function <code>kron</code>.</p>"},{"location":"documentation/operators/opsum/","title":"OpSum","text":"<p>Object representing a generic many-body operator by a sum of operators of the form </p> \\[ \\mathcal{O} = \\sum_i c_i \\mathcal{O}_i. \\] <p>Sources opsum.hpp opsum.cpp opsum.jl</p> <p>An OpSum is consists of a sum of pairs given by</p> <ol> <li> <p>A coupling constant \\(c_i\\) which is given by a either a string name or a real/complex number.</p> </li> <li> <p>An operator \\(\\mathcal{O}_i\\) defined by an Op object.</p> </li> </ol> <p>Generically, an OpSum can thus have coupling constants defined by either strings or numerical real/complex numbers. We call an OpSum plain if its couplings are only numerical numbers, and not strings. String couplings can be defined by using the access <code>operator[]</code>. If all string coupling constants are defined, the OpSum can be converted to a plain OpSum using the <code>plain</code> method shown below.</p> <p>Thus, OpSums can be defined independently of the numerical values of the coupling constants, e.g. in an input file. Upon execution of the code, these constants can then be set. Most operations in XDiag require the OpSum to be convertible to a plain OpSum.</p> <p>OpSums can be added and subtracted, as well as multiplied with and divided by a scalar value, i.e. a real or complex number. Hence, OpSums carry the mathematical structure of a vector space.</p>"},{"location":"documentation/operators/opsum/#constructors","title":"Constructors","text":"<p>The following constructors create an OpSum with a single pair of coupling and operator. Additional terms can be added using the <code>+</code> and <code>+=</code> operators explained further below. If no coupling is given, a numerical coefficient of <code>1.0</code> is assumed.</p> C++Julia <pre><code>OpSum(Op const &amp;op);\nOpSum(double coupling, Op const &amp;op);\nOpSum(complex coupling, Op const &amp;op);\nOpSum(std::string coupling, Op const &amp;op);\n</code></pre> <pre><code>OpSum(op::Op)\nOpSum(coupling::Float64, op::Op)\nOpSum(coupling::ComplexF64, op::Op)\nOpSum(coupling::String, op::Op)\n</code></pre> Parameter Description Default coupling A coupling which is either a string or a real/complex number 1.0 op An Op which describes the type of operator <p>Alternatively, an OpSum can also be constructed via the <code>* operator</code>, for example:</p> C++Julia <pre><code>auto ops = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n    ops += \"J\" * Op(\"SzSz\", {i, (i + 1) % N});\n}\n</code></pre> <pre><code>ops = OpSum();\nfor i in 1:n\n    ops += \"J\" * Op(\"SzSz\", [i, mod1(i+1, N)]);\n</code></pre>"},{"location":"documentation/operators/opsum/#complex-couplings","title":"Complex couplings","text":"<p>XDiag allows all couplings to be complex. Depending on the operator type  a complex coupling can have two meanings:</p> <ol> <li> <p>A complex prefactor \\(c\\) which upon hermitian conjugation with hc gets     conjugated to \\(c^\\star\\). This is the case for the following interaction types:  <code>HubbardU</code>, <code>Cdagup</code>, <code>Cdagdn</code>, <code>Cup</code>, <code>Cdn</code>, <code>Nup</code>, <code>Ndn</code>, <code>Ntot</code>, <code>NtotNtot</code>,     <code>SdotS</code>, <code>SzSz</code>, <code>Sz</code>, <code>S+</code>, <code>S-</code>, <code>ScalarChirality</code>, <code>tJSzSz</code>, <code>tJSdotS</code>,     <code>Matrix</code>    Thus, a complex coupling can turn a Hermitian operator to a non-Hermitian operator.</p> </li> <li> <p>The coupling is part of the definition of the operator. For, example a hopping     operator of the form     $$ ( t c^\\dagger_{i\\sigma}c_{j\\sigma} + \\textrm{h.c.})  = ( t c^\\dagger_{i\\sigma}c_{j\\sigma} + t^\\star c^\\dagger_{j\\sigma}c_{i\\sigma}) $$    A complex coupling \\(t\\) gives the hopping a phase, but the overall operator remains    Hermitian and, thus, invariant under hc. This holds for the types     <code>Hop</code>, <code>Hopup</code>, <code>Hopdn</code>, <code>Exchange</code>. In the latter case, complex spin exchange     <code>Exchange</code> is defined as,    $$ \\frac{1}{2}( J S^+_i S^-_j + J^\\star S^-_iS^+_j)$$</p> </li> </ol>"},{"location":"documentation/operators/opsum/#methods","title":"Methods","text":""},{"location":"documentation/operators/opsum/#plain","title":"plain","text":"<p>Converts an OpSum with possible string couplings to an OpSum with purely numerical real/complex couplings.</p> C++Julia <pre><code>OpSum plain(OpSum const &amp;ops) const;\n</code></pre> <pre><code>plain(ops::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-creation","title":"operator* (Creation)","text":"<p>Creates an OpSum with a single pair of coupling constant and an Op object.</p> C++Julia <pre><code>OpSum operator*(double coupling, Op const &amp;op);\nOpSum operator*(complex coupling, Op const &amp;op);\nOpSum operator*(std::string coupling, Op const &amp;op);\n</code></pre> <pre><code>Base.:*(coupling::Float64, op::Op)::OpSum\nBase.:*(coupling::ComplexF64, op::Op)::OpSum\nBase.:*(coupling::String, op::Op)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator","title":"operator+ / operator +=","text":"<p>Adds two OpSum objects \\(\\mathcal{A} = \\sum_i a_i \\mathcal{A}_i\\) and \\(\\mathcal{B} = \\sum_i b_i \\mathcal{B}_i\\) to for the sum of the two operators,     $$ \\mathcal{A} + \\mathcal{B} = \\sum_i a_i \\mathcal{A}_i + \\sum_i b_i \\mathcal{B}_i$$</p> C++Julia <pre><code>OpSum &amp;operator+=(OpSum const &amp;ops);\nOpSum operator+(OpSum const &amp;ops) const;\n</code></pre> <pre><code>Base.:+(ops1::OpSum, ops2::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator-","title":"operator- / operator -=","text":"<p>Subtracts to OpSum objects.</p> C++Julia <pre><code>OpSum &amp;operator-=(OpSum const &amp;ops);\nOpSum operator-(OpSum const &amp;ops) const;\n</code></pre> <pre><code>Base.:-(ops::OpSum, ops2::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator-scalar-muliplicationdivision","title":"operator* , operator/ (scalar muliplication/division)","text":"<p>Multiplies an OpSum \\(\\mathcal{A} = \\sum_i a_i \\mathcal{A}_i\\) with a scalar \\(b\\) to form</p> \\[\\mathcal{B} = b \\sum_i a_i \\mathcal{A}_i\\] C++Julia <pre><code>OpSum &amp;operator*=(double scalar);\nOpSum &amp;operator*=(complex scalar);\nOpSum &amp;operator/=(double scalar);\nOpSum &amp;operator/=(complex scalar);\n\nOpSum operator*(double scalar, OpSum const &amp;op);\nOpSum operator*(complex scalar, OpSum const &amp;op);\nOpSum operator*(OpSum const &amp;op, double scalar);\nOpSum operator*(OpSum const &amp;op, complex scalar);\nOpSum operator/(OpSum const &amp;op, double scalar);\nOpSum operator/(OpSum const &amp;op, complex scalar);\n</code></pre> <pre><code>Base.:*(coupling::Float64, ops::OpSum)::OpSum\nBase.:*(coupling::ComplexF64, ops::OpSum)::OpSum\nBase.:*(ops::OpSum, coupling::Float64)::OpSum\nBase.:*(ops::OpSum, coupling::ComplexF64)::OpSum\nBase.:/(ops::OpSum, coupling::Float64)::OpSum\nBase.:/(ops::OpSum, coupling::ComplexF64)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator","title":"operator[]","text":"<p>Sets a coupling constant defined as a string to a numerical value.</p> C++Julia <pre><code>Scalar &amp;operator[](std::string name);\n</code></pre> <pre><code>Base.setindex!(ops::OpSum, cpl::Float64, name::String)\nBase.setindex!(ops::OpSum, cpl::ComplexF64, name::String)\n</code></pre>"},{"location":"documentation/operators/opsum/#constants","title":"constants","text":"<p>Returns a vector of strings with the coupling constants defined, i.e. the strings that define some of the coupling constants.</p> C++Julia <pre><code>std::vector&lt;std::string&gt; constants(OpSum const &amp;ops) const;\n</code></pre> <pre><code>constants(ops::OpSum)::Vector{String}\n</code></pre>"},{"location":"documentation/operators/opsum/#isreal","title":"isreal","text":"<p>Returns whether an OpSum is a real operator.</p> C++Julia <pre><code>bool isreal(OpSum const &amp;ops);\n</code></pre> <pre><code>isreal(ops::OpSum)::Bool\n</code></pre>"},{"location":"documentation/operators/opsum/#isapprox","title":"isapprox","text":"<p>Returns whether two OpSums are approximately equal.</p> C++Julia <pre><code>bool isapprox(OpSum const &amp;ops1, OpSum const &amp;ops2, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(ops1::OpSum, ops2::OpSum, rtol::Float64=1e-12, atol::Float64=1e-12)::Bool\n</code></pre>"},{"location":"documentation/operators/opsum/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the OpSum to a readable string representation.</p> C++Julia <pre><code>std::string to_string(OpSum const &amp;ops);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, OpSum const &amp;ops);\n</code></pre> <pre><code>to_string(ops::OpSum)::String\n</code></pre>"},{"location":"documentation/operators/opsum/#usage-example","title":"Usage Example","text":"C++ <pre><code>// Define the 1D transverse-field Ising chain\nint N = 12;\ndouble J = 1.0;\ndouble h = 0.5;\nauto Sx = arma::mat(\"0 1; 1 0\");\n\n// Option 1: coupling constants as numbers\nauto ops1 = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops1 += J * Op(\"SzSz\", {i, (i+1)%N});\n  ops1 += h * Op(\"Matrix\", i, Sx);\n}\n\n// Option 2: coupling constants as strings\nauto ops2 = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops2 += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n  ops2 += \"h\" * Op(\"Matrix\", i, Sx);\n}\nops2[\"J\"] = J;\nops2[\"h\"] = h;\n\nXDIAG_SHOW(isapprox(ops1, ops2));\nXDIAG_SHOW(isapprox(ops1 + ops2, 2.0 * ops1));\n</code></pre>"},{"location":"documentation/operators/symmetrize/","title":"symmetrize","text":"<p>Symmetrizes an operator with respect to a PermutationGroup or a Representation.</p> <p>Sources symmetrize.hpp symmetrize.cpp symmetrize.jl</p> <p>Symmetrization in this context means the following. In general, we are given an OpSum of the form,</p> \\[ O = \\sum_{A\\subseteq \\mathcal{L}} O_A,\\] <p>where \\(O_A\\) denotes a local operator acting on sites \\(A=\\{a_1, \\ldots, a_{l_A}\\}\\) and \\(L\\) denotes the lattice. A PermutationGroup \\(\\mathcal{G}\\) is defined through its permutations \\(\\pi_1, \\ldots, \\pi_M\\). The symmetrized operator returned by this function is then </p> \\[ O^\\mathcal{G} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}}  O_{\\pi(A)},\\] <p>where \\(\\pi(A) = \\{\\pi(a_1), \\ldots,\\pi(a_{l_A})\\}\\) denotes the permutated set of sites of the local operator \\(O_A\\). If a Representation called \\(\\rho\\) is given in addition, the following operator is constructed,</p> \\[ O^\\mathcal{G, \\rho} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}} \\chi_\\rho(\\pi) O_{\\pi(A)},\\] <p>where \\(\\chi_\\rho(\\pi)\\) denotes the characters of the representation \\(\\rho\\). This routine is useful to evaluate observables in symmetrized blocks.</p>"},{"location":"documentation/operators/symmetrize/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum symmetrize(Op const &amp;op, PermutationGroup const &amp;group);\nOpSum symmetrize(Op const &amp;op, Representation const &amp;irrep);\nOpSum symmetrize(OpSum const &amp;ops, PermutationGroup const &amp;group);\nOpSum symmetrize(OpSum const &amp;ops, Representation const &amp;irrep);\n</code></pre> <pre><code>symmetrize(op::Op, group::PermutationGroup)::OpSum\nsymmetrize(op::Op, irrep::Representation)::OpSum\nsymmetrize(ops::OpSum, group::PermutationGroup)::OpSum\nsymmetrize(ops::OpSum, irrep::Representation)::OpSum\n</code></pre>"},{"location":"documentation/operators/symmetrize/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator to be symmetrized group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group"},{"location":"documentation/operators/symmetrize/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nauto block = Spinhalf(N, nup);\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto rep = Representation(group);\nauto block_sym = Spinhalf(N, rep);\n\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto [e0s, psi_sym] = eig0(ops, block_sym);\n\nauto corr = Op(\"SdotS\", {0, 1});\nauto nn_corr = inner(corr, psi);\nauto corr_sym = symmetrize(corr, group);\nauto nn_corr_sym = innerC(corr_sym, psi_sym);\nXDIAG_SHOW(nn_corr);\nXDIAG_SHOW(nn_corr_sym);\n</code></pre> <pre><code>let\n    N = 4\n    nup = 2\n    block = Spinhalf(N, nup)\n    p1 = Permutation([1, 2, 3, 4])\n    p2 = Permutation([2, 3, 4, 1])\n    p3 = Permutation([3, 4, 1, 2])\n    p4 = Permutation([4, 1, 2, 3])\n    group = PermutationGroup([p1, p2, p3, p4])\n    rep = Representation(group)\n    block_sym = Spinhalf(N, rep)\n\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    e0, psi = eig0(ops, block);\n    e0, psi_sym = eig0(ops, block_sym);\n\n    corr = Op(\"SdotS\", [1, 2])\n    nn_corr = inner(corr, psi)\n    corr_sym = symmetrize(corr, group)\n    nn_corr_sym = inner(corr_sym, psi_sym)\n    @show nn_corr, nn_corr_sym\nend\n</code></pre>"},{"location":"documentation/states/create_state/","title":"Creating specific States","text":"<p>Sources create_state.hpp, create_state.cpp</p>"},{"location":"documentation/states/create_state/#product_state","title":"product_state","text":"<p>Creates a filled product state.</p> C++Julia <pre><code>State product_state(Block const &amp;block, std::vector&lt;std::string&gt; const &amp;local_state, bool real = true);\n</code></pre> <pre><code>product_state(block::Block, local_states::Vector{String}; real::Bool=true)\n</code></pre>"},{"location":"documentation/states/create_state/#parameters","title":"Parameters","text":"Name Description block block on which the state is defined local_states local configurations of the product state real flag whether real state is created"},{"location":"documentation/states/create_state/#random_state","title":"random_state","text":"<p>Create a filled random state with normal \\(\\mathcal{N}(0, 1)\\) distributed coefficients.</p> C++Julia <pre><code>State random_state(Block const &amp;block, bool real = true, int64_t seed = 42, bool normalized = true);\n</code></pre> <pre><code>random_state(block::Block; real::Bool=true, seed::Int64=42, normalized::Bool=true\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_1","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created seed random seed determining the precise random numbers normalized flag whether the state is normalized"},{"location":"documentation/states/create_state/#zero_state","title":"zero_state","text":"<p>Create a filled state with all zero entries.</p> C++Julia <pre><code>State zero_state(Block const &amp;block, bool real = true, int64_t ncols = 1);\n</code></pre> <pre><code>zero_state(block::Block; real::Bool=true, ncols::Int64=1)\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_2","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created ncols number of columns in the state"},{"location":"documentation/states/create_state/#zero","title":"zero","text":"<p>Set all coefficients of a given state to zero.</p> C++Julia <pre><code>void zero(State &amp;state);\n</code></pre> <pre><code>zero(state::State)\n</code></pre>"},{"location":"documentation/states/create_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = product_state(block, {\"Up\", \"Dn\"});\nXDIAG_SHOW(state.vector());\n\nzero(state);\nXDIAG_SHOW(state.vector());\n\nstate = random_state(block, false, 1234, true);\nXDIAG_SHOW(state.vectorC());\n\nstate = zero_state(block, true, 2);\nXDIAG_SHOW(state.vector());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = product_state(block, [\"Up\", \"Dn\"])\ndisplay(vector(state))\n\nzero(state)\ndisplay(vector(state))\n\nstate = random_state(block, real=false, seed=1234, normalized=true)\ndisplay(vector(state))\n\nstate = zero_state(block, real=true, ncols=2)\ndisplay(matrix(state))\n</code></pre>"},{"location":"documentation/states/fill/","title":"fill","text":"<p>Fills a State with a given model state, e.g. a ProductState or a RandomState.</p> <p>Sources fill.hpp fill.cpp fill.jl</p>"},{"location":"documentation/states/fill/#definition","title":"Definition","text":"C++Julia <pre><code>void fill(State &amp;state, ProductState const &amp;pstate, int64_t ncol = 0);\nvoid fill(State &amp;state, RandomState const &amp;rstate, int64_t ncol = 0);\n</code></pre> <pre><code>fill(state::State, pstate::ProductState, ncol::Int64 = 1)\nfill(state::State, rstate::RandomState, ncol::Int64 = 1)\n</code></pre> Name Description state State object to be filled pstate ProductState object rstate RandomState object ncol integer deciding which column of the State is filled (default: 1/0 (Julia/C++))"},{"location":"documentation/states/fill/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = State(block);  \nauto pstate = ProductState({\"Up\", \"Dn\"});\nfill(state, pstate);\nXDIAG_SHOW(state.vector());\n\nauto rstate = RandomState(1234);\nfill(state, rstate);\nXDIAG_SHOW(state.vector());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = State(block)\npstate = ProductState([\"Up\", \"Dn\"])\nfill(state, pstate)\ndisplay(vector(state))\n\nrstate = RandomState(1234)\nfill(state, rstate)\ndisplay(vector(state))\n</code></pre>"},{"location":"documentation/states/product_state/","title":"ProductState","text":"<p>A product state of local configurations.</p> <p>Sources product_state.hpp product_state.cpp product_state.jl</p>"},{"location":"documentation/states/product_state/#constructors","title":"Constructors","text":"C++Julia <pre><code>ProductState(int64_t nsites);\nProductState(std::vector&lt;std::string&gt; const &amp;local_states);\n</code></pre> <pre><code>ProductState(nsites::Int64)\nProductState(local_states::Vector{String})\n</code></pre> Parameter Description nsites construct a product state on nsites local_states the local configurations of the product state"},{"location":"documentation/states/product_state/#iteration","title":"Iteration","text":"<p>A ProductState can be iterated over, where at each iteration the string of the local configuration is retured. Here is an example:</p> C++Julia <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n    Log(\"{}\", s);\n}\n</code></pre> <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n</code></pre>"},{"location":"documentation/states/product_state/#methods","title":"Methods","text":""},{"location":"documentation/states/product_state/#nsites","title":"nsites","text":"<p>Returns the number of sites of the product state</p> C++Julia <pre><code>int64_t nsites(ProductState const &amp;p);\n</code></pre> <pre><code>nsites(p::ProductState)\n</code></pre>"},{"location":"documentation/states/product_state/#size","title":"size","text":"<p>Returns the number of sites of the product state. Same as \"nsites\".</p> C++Julia <pre><code>int64_t size(ProductState const &amp;p);\n</code></pre> <pre><code>size(state::ProductState)\n</code></pre>"},{"location":"documentation/states/product_state/#setindex-operator","title":"setindex! / operator[]","text":"<p>Sets the local configuration at the given site index to the given string.</p> C++Julia <pre><code>std::string &amp;operator[](int64_t i);\n</code></pre> <pre><code>setindex!(state::ProductState, local_state::String, idx::Int64)\n</code></pre>"},{"location":"documentation/states/product_state/#getindex-operator","title":"getindex / operator[]","text":"<p>Returns the string of the local configuration at the given site index.</p> C++Julia <pre><code>std::string const &amp;operator[](int64_t i) const;\n</code></pre> <pre><code>getindex(state::ProductState, idx::Int64)\n</code></pre>"},{"location":"documentation/states/product_state/#push-push_back","title":"push! / push_back","text":"<p>Adds a local configuration add the end of the product state.</p> C++Julia <pre><code>void push_back(std::string l);\n</code></pre> <pre><code>push!(state::ProductState, local_state::String\n</code></pre>"},{"location":"documentation/states/product_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n\npstate = ProductState();\npstate.push_back(\"Dn\");\npstate.push_back(\"Up\");\npstate.push_back(\"Dn\");\nXDIAG_SHOW(pstate.nsites());\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n</code></pre> <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n@show pstate\n\npstate = ProductState()\npush!(pstate, \"Dn\")\npush!(pstate, \"Up\")\npush!(pstate, \"Dn\")\n@show nsites(pstate)\nfor s in pstate\n    @show s\nend\n@show pstate\n</code></pre>"},{"location":"documentation/states/random_state/","title":"RandomState","text":"<p>A random state with \\(\\mathcal{N}(0, 1)\\) normal distributed coefficients.</p> <p>Sources random_state.hpp random_state.cpp random_state.jl</p>"},{"location":"documentation/states/random_state/#constructors","title":"Constructors","text":"C++Julia <pre><code>RandomState(int64_t seed = 42, bool normalized = true);\n</code></pre> <pre><code>RandomState(seed::Int64 = 42, normalized::Bool = true)\n</code></pre> Parameter Description seed random seed determining which random numbers are put normalized flag whether the State is normalized"},{"location":"documentation/states/random_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = State(block, false);  // complex State\nauto rstate1 = RandomState(1234);\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n\nauto rstate2 = RandomState(4321);\nfill(state, rstate2);\nXDIAG_SHOW(state.vectorC());\n\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = State(block, real=false)  # complex State\nrstate1 = RandomState(1234)\nfill(state, rstate1)\ndisplay(vector(state))\n\nrstate2 = RandomState(4321)\nfill(state, rstate2)\ndisplay(vector(state))\n\nfill(state, rstate1)\ndisplay(vector(state))\n</code></pre>"},{"location":"documentation/states/state/","title":"State","text":"<p>A generic state describing a quantum wave function \\(|\\psi \\rangle\\).</p> <p>Sources state.hpp state.cpp state.jl</p>"},{"location":"documentation/states/state/#constructors","title":"Constructors","text":"<p>A state can be constructed in three ways:</p> <ol> <li> <p>By only specifying the block. In this case the state is initialized with all coefficients zero.</p> C++Julia <pre><code>State(Block const &amp;block, bool real = true, int64_t n_cols = 1);\n</code></pre> <pre><code>State(block::Block; real::Bool = true, n_cols::Int64 = 1)\n</code></pre> </li> <li> <p>By handing a vector of coefficients.</p> C++Julia <pre><code>State(Block const &amp;block, arma::vec const &amp;vector);\nState(Block const &amp;block, arma::cx_vec const &amp;vector);\n</code></pre> <pre><code>State(block::Block, vec::Vector{Float64})\nState(block::Block, vec::Vector{ComplexF64})\n</code></pre> </li> <li> <p>By handing a matrix whose columns describe several states at once.</p> C++Julia <pre><code>State(Block const &amp;block, arma::mat const &amp;matrix);\nState(Block const &amp;block, arma::cx_mat const &amp;matrix);\n</code></pre> <pre><code>State(block::Block, mat::Matrix{Float64})\nState(block::Block, mat::Matrix{ComplexF64})\n</code></pre> </li> </ol> Parameter Description block The block of a Hilbertspace on which the state is defined real Flag whether or not the state has real coefficients n_cols Number of columns of the state (default 1) vector A vector containing the coefficients of the state. Must be same size as block. matrix A matrix containing the coefficients of the state. Number of rows must be same as block size ."},{"location":"documentation/states/state/#methods","title":"Methods","text":""},{"location":"documentation/states/state/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block the state is defined on.</p> C++Julia <pre><code>int64_t nsites(State const &amp;s) const\n</code></pre> <pre><code>nsites(state::State)\n</code></pre>"},{"location":"documentation/states/state/#isapprox","title":"isapprox","text":"<p>Returns whether two states are approximately equal.</p> C++Julia <pre><code>bool isapprox(State const &amp;v, State const &amp;w, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(v::State, w::State, rtol::Float64, atol::Float64)\n</code></pre>"},{"location":"documentation/states/state/#isreal","title":"isreal","text":"<p>Returns whether the state is real.</p> C++Julia <pre><code>int64_t isreal(State const &amp;s) const;\n</code></pre> <pre><code>isreal(state::State)\n</code></pre>"},{"location":"documentation/states/state/#real","title":"real","text":"<p>Returns the real part of the State.</p> C++Julia <pre><code>State real(State const &amp;s) const;\n</code></pre> <pre><code>real(state::State)\n</code></pre>"},{"location":"documentation/states/state/#imag","title":"imag","text":"<p>Returns the imaginary part of the State.</p> C++Julia <pre><code>State imag(State const &amp;s) const;\n</code></pre> <pre><code>imag(state::State)\n</code></pre>"},{"location":"documentation/states/state/#make_complex-make_complex","title":"make_complex! / make_complex","text":"<p>Turns a real State into a complex State. Does nothing if the state is already complex</p> C++Julia <pre><code>void make_complex(State &amp;s);\n</code></pre> <pre><code>make_complex!(state::State)\n</code></pre>"},{"location":"documentation/states/state/#dim","title":"dim","text":"<p>Returns the dimension of the block the state is defined on.</p> C++Julia <pre><code>int64_t dim(State const &amp;s) const;\n</code></pre> <pre><code>dim(block::Spinhalf)\n</code></pre>"},{"location":"documentation/states/state/#size","title":"size","text":"<p>Returns the <code>size</code> of the block (also equal to <code>nrows</code>) times the number of columns <code>ncols</code>. For distributed blocks the local size of a Block is not the same as the dimension <code>dim</code>, which is the overall dimension of the block across all processes.</p> C++Julia <pre><code>int64_t size(State const &amp;s);\n</code></pre> <pre><code>size(s::State)\n</code></pre>"},{"location":"documentation/states/state/#nrows","title":"nrows","text":"<p>Returns number of rows of the local storage.</p> C++Julia <pre><code>int64_t nrows(State const &amp;s);\n</code></pre> <pre><code>nrows(s::State)\n</code></pre>"},{"location":"documentation/states/state/#n_cols","title":"n_cols","text":"<p>Returns number of columns.</p> C++Julia <pre><code>int64_t ncols(State const &amp;s);\n</code></pre> <pre><code>ncols(s::State)\n</code></pre>"},{"location":"documentation/states/state/#col","title":"col","text":"<p>Returns a state created from the n-th column of the storage. Whether or not the storage is copied can be specified by setting the flag \"copy\".</p> C++Julia <pre><code>State col(State const &amp;s, int64_t n, bool copy = true);\n</code></pre> <pre><code>col(s::State, n::Int64 = 1; copy::Bool = true)\n</code></pre>"},{"location":"documentation/states/state/#vectorvectorc","title":"vector/vectorC","text":"<p>Returns a vector from the n-th column of the storage. In C++ use \"vector\"/\"vectorC\" to either get a real or complex vector.</p> C++Julia <pre><code>arma::vec vector(State const &amp;s, int64_t n = 0, bool copy = true);\narma::cx_vec vectorC(State const &amp;s, int64_t n = 0, bool copy = true);\n</code></pre> <pre><code>vector(state::State; n::Int64 = 1, copy::Bool=true)\n# no vectorC method in julia\n</code></pre>"},{"location":"documentation/states/state/#matrixmatrixc","title":"matrix/matrixC","text":"<p>Returns matrix representing the storage. In C++ use \"matrix\"/\"matrixC\" to either get a real or complex matrix.</p> C++Julia <pre><code>arma::vec matrix(State const &amp;s, bool copy = true);\narma::cx_vec matrixC(State const &amp;s, bool copy = true);\n</code></pre> <pre><code>matrix(state::State, copy::Bool=true)\n# no matrixC method in julia\n</code></pre>"},{"location":"documentation/states/state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto psi1 = State(block, arma::vec(\"1.0 2.0 3.0 4.0\"));\nXDIAG_SHOW(psi1);\nXDIAG_SHOW(vector(psi1));\nmake_complex(psi1);\nXDIAG_SHOW(vectorC(psi1));\n\nauto psi2 = State(block, false, 3);\nXDIAG_SHOW(psi2);\nXDIAG_SHOW(matrixC(psi2));\n\nauto psi3 = State(block, arma::cx_vec(arma::vec(\"1.0 2.0 3.0 4.0\"),\n                      arma::vec(\"4.0 3.0 2.0 1.0\")));\nXDIAG_SHOW(vectorC(psi3));\nXDIAG_SHOW(vector(real(psi3)));\nXDIAG_SHOW(vector(imag(psi3)));\n</code></pre> <pre><code>block = Spinhalf(2)\npsi1 = State(block, [1.0, 2.0, 3.0, 4.0])\n@show psi1\ndisplay(vector(psi1))\nmake_complex!(psi1)\ndisplay(vector(psi1))\n\npsi2 = State(block, real=false, n_cols=3)\n@show psi2\ndisplay(matrix(psi2))\n\npsi3 = State(block, [1.0+4.0im, 2.0+3.0im, 3.0+2.0im, 4.0+1.0im])\ndisplay(vector(psi3))\ndisplay(vector(real(psi3)))\ndisplay(vector(imag(psi3)))\n</code></pre>"},{"location":"documentation/symmetries/permutation/","title":"Permutation","text":"<p>Permutations of indices or lattice sites. Basic building block of a PermutationGroup. Permutations can be multiplied, inverted and raised to a power.</p> <p>Sources permutation.hpp permutation.cpp permutation.jl</p>"},{"location":"documentation/symmetries/permutation/#constructors","title":"Constructors","text":""},{"location":"documentation/symmetries/permutation/#from-an-array","title":"From an array","text":"<p>Creates an Permutation out of an array of integers, e.g. <code>{0, 2, 1, 3}</code>. If the input array is of size <code>N</code> then every number between <code>0</code> and <code>N-1</code> must occur exactly once, otherwise the Permutation is invalid.</p> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p> C++Julia <pre><code>Permutation(std::initializer_list&lt;int64_t&gt; list);\nPermutation(std::vector&lt;int32_t&gt; const &amp;array);\nPermutation(std::vector&lt;int64_t&gt; const &amp;array);\n</code></pre> <pre><code>Permutation(array::Vector{Int64})\n</code></pre> Name Description array array of integers, e.g. list initializer list of the permutation ptr pointer to memory as an array size size of the array"},{"location":"documentation/symmetries/permutation/#for-identity","title":"For identity","text":"<p>Constructs an identity permutation of a given size, e.g. <code>{0, 1, 2, 3}</code>.</p> C++Julia <pre><code>Permutation(int64_t size);\n</code></pre> <pre><code>Permutation(size::Int64)\n</code></pre> Name Description size size of the identity permutation"},{"location":"documentation/symmetries/permutation/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/permutation/#inv","title":"inv","text":"<p>Computes the inverse permutation.</p> C++Julia <pre><code>Permutation inv(Permutation const &amp;p);\n</code></pre> <pre><code>inv(perm::Permutation)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#operator","title":"* operator","text":"<p>Concatenates two permutations by overloading the <code>*</code> operator.</p> C++Julia <pre><code>Permutation operator*(Permutation const &amp;p1, Permutation const &amp;p2);\n</code></pre> <pre><code>Base.:*(p1::Permutation, p2::Permutation)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#operator-pow","title":"^ operator, pow","text":"<p>Raises a permutation to an integer power.</p> C++Julia <pre><code>Permutation pow(Permutation const &amp;p, int64_t power);\n</code></pre> <pre><code>Base.:^(p::Permutation, power::Int64)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#size","title":"size","text":"<p>Returns the size of a Permutation.</p> C++Julia <pre><code>int64_t size(Permutation const &amp;p);\n</code></pre> <pre><code>size(p::Permutation)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Permutation to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Permutation const &amp;perm);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Permutation const &amp;perm);\n</code></pre> <pre><code>to_string(perm::Permutation)::String\n</code></pre>"},{"location":"documentation/symmetries/permutation/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>Permutation p1 = {0, 2, 1, 3};\nPermutation p2 = {2, 0, 1, 3};\n\nXDIAG_SHOW(inv(p1));\nXDIAG_SHOW(p1*p2);\n</code></pre> <pre><code>p1 = Permutation([1, 3, 2, 4])\np2 = Permutation([3, 1, 2, 4])\n\n@show inv(p1)\n@show p1 * p2\n@show p1 ^ 2\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/","title":"PermutationGroup","text":"<p>A group of permutations. Group axioms are verified during construction.</p> <p>Sources permutation_group.hpp permutation_group.cpp permutation_group.jl</p>"},{"location":"documentation/symmetries/permutation_group/#constructor","title":"Constructor","text":""},{"location":"documentation/symmetries/permutation_group/#from-permutations","title":"From Permutations","text":"<p>Creates an PermutationGroup out of a vector of Permutation objects.</p> C++Julia <pre><code>PermutationGroup(std::vector&lt;Permutation&gt; const &amp;permutations);\n</code></pre> <pre><code>PermutationGroup(permutations::Vector{Permutation})\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#from-matrix","title":"From matrix","text":"<p>Creates a PermutationGroup out of a matrix whose rows specify the individual permutations. If a raw pointer is handed, the matrix is assumed to be in column-major form.</p> C++Julia <pre><code>PermutationGroup(arma::Mat&lt;int64_t&gt; const &amp;matrix);\nPermutationGroup(int64_t *ptr, int64_t n_permutations, int64_t nsites);\n</code></pre> <pre><code>PermutationGroup(matrix::Matrix{Int64})\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/permutation_group/#nsites","title":"nsites","text":"<p>Returns the number of sites on which the permutations of the group acts.</p> C++Julia <pre><code>int64_t nsites(PermutationGroup const &amp;group);\n</code></pre> <pre><code>nsites(group::PermutationGroup)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#size","title":"size","text":"<p>Returns the size of the permutation group, i.e. the number permutations.</p> C++Julia <pre><code>int64_t size(PermutationGroup const &amp;group);\n</code></pre> <pre><code>size(group::PermutationGroup)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the PermutationGroup to a readable string representation.</p> C++Julia <pre><code>std::string to_string(PermutationGroup const &amp;group);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, PermutationGroup const &amp;group);\n</code></pre> <pre><code>to_string(group::PermutationGroup)::String\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>// Define a cyclic group of order 3\nPermutation p1 = {0, 1, 2};\nPermutation p2 = {1, 2, 0};\nPermutation p3 = {2, 0, 1};\nauto C3 = PermutationGroup({p1, p2, p3});\n\nXDIAG_SHOW(C3.size());\nXDIAG_SHOW(C3.nsites());\n</code></pre> <pre><code># Define a cyclic group of order 3\np1 = Permutation([1, 2, 3])\np2 = Permutation([2, 3, 1])\np3 = Permutation([3, 1, 2])\nC3 = PermutationGroup([p1, p2, p3])\n\n@show size(C3)\n@show nsites(C3)\n</code></pre>"},{"location":"documentation/symmetries/representation/","title":"Representation","text":"<p>A (1D) irreducible representation of a finite group. Upon creation, the group homomorphism properties are verified.</p> <p>Sources representation.hpp representation.cpp representation.jl</p>"},{"location":"documentation/symmetries/representation/#constructors","title":"Constructors","text":""},{"location":"documentation/symmetries/representation/#trivial-representation","title":"Trivial representation","text":"<p>Creates the trivial representation (all characters equal to 1) of a PermutationGroup</p> C++Julia <pre><code>Representation(PermutationGroup const &amp;group);\n</code></pre> <pre><code>Representation(group::PermutationGroup)\n</code></pre>"},{"location":"documentation/symmetries/representation/#with-characters","title":"With characters","text":"<p>Creates a 1D representation of a PermutationGroup with given real or complex characters.</p> C++Julia <pre><code>template &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, std::vector&lt;T&gt; const &amp;characters);\ntemplate &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, arma::Col&lt;T&gt; const &amp;characters);\ntemplate &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, T *characters, int64_t n_characters);\n</code></pre> <pre><code>Representation(group::PermutationGroup, characters::Vector{Float64})\nRepresentation(group::PermutationGroup, characters::Vector{ComplexF64})\n</code></pre> Name Description group PermutationGroup of the Representation characters characters of the representation n_characters length of the array of characters <p>The template parameter <code>T</code> in C++ can either be <code>double</code> or <code>complex</code>.</p>"},{"location":"documentation/symmetries/representation/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/representation/#size","title":"size","text":"<p>Returns the size of the Representation, i.e. the number of group elements represented.</p> C++Julia <pre><code>int64_t size(Representation const &amp;irrep);\n</code></pre> <pre><code>size(irrep::Representation)::Int64\n</code></pre>"},{"location":"documentation/symmetries/representation/#isreal","title":"isreal","text":"<p>Returns the whether or not the Representation is real, I.E. the characters are real numbers and do not have an imaginary part.</p> C++Julia <pre><code>bool isreal(Representation const &amp;irrep) const;\n</code></pre> <pre><code>isreal(irrep::Representation)::Bool\n</code></pre>"},{"location":"documentation/symmetries/representation/#operator","title":"* operator","text":"<p>Multiplies two Representations by overloading the <code>*</code> operator.</p> C++Julia <pre><code>Representation operator*(Representation const &amp;r1, Representation const &amp;r2);\n</code></pre> <pre><code>Base.:*(r1::Representation, r2::Representation)::Representation\n</code></pre>"},{"location":"documentation/symmetries/representation/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Representation to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Representation const &amp;irrep);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Representation const &amp;irrep);\n</code></pre> <pre><code>to_string(irrep::Representation)::String\n</code></pre>"},{"location":"documentation/symmetries/representation/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>Permutation p = {1, 2, 3, 0};\nauto C4 = PermutationGroup({pow(p, 0), pow(p, 1), pow(p, 2), pow(p, 3)});\nRepresentation r1(C4, arma::vec{1.0, -1.0, 1.0, -1.0});\nRepresentation r2(C4, arma::cx_vec{1.0, 1.0i, -1.0, -1.0i});\nXDIAG_SHOW(r1 * r2);\n</code></pre> <pre><code>p = Permutation([2, 3, 4, 1])\nC4 = PermutationGroup([p^0, p^1, p^2, p^3])\nr1 = Representation(C4, [1.0, -1.0, 1.0, -1.0])\nr2 = Representation(C4, [1.0, 1.0im, -1.0, -1.0im])\n@show r1 * r2\n</code></pre>"},{"location":"documentation/utilities/logging/","title":"Logging","text":"<p>Sources logger.hpp, logger.cpp</p>"},{"location":"documentation/utilities/logging/#setting-the-verbosity","title":"Setting the verbosity","text":"<p>Algorithms implemented in XDiag do not output anything during their execution by default. However, it is typically useful to get some information on how the code is performing and even intermediary results at runtime. For this, the verbosity of the internal XDiag logging can be set using the function <code>set_verbosity</code>, which is defined as </p> C++Julia <pre><code>void set_verbosity(int64_t level);\n</code></pre> <pre><code>set_verbosity(level::Integer);\n</code></pre> <p>There are several levels of verbosity, defining how much information is shown.</p> level outputed information 0 no information 1 some information 2 detailed information <p>For example, when computing a ground state energy using the eigval0 function, we can set a higher verbosity level using</p> C++Julia <pre><code>set_verbosity(2);\ndouble e0 = eigval0(bonds, block);\n</code></pre> <pre><code>set_verbosity(2);\ne0 = eigval0(bonds, block);\n</code></pre> <p>This will print detailed information, which can look like this</p> <pre><code>Lanczos iteration 1\nMVM: 0.00289 secs\nalpha: -0.2756971549998545\nbeta: 1.7639347562074059\neigs: -0.2756971549998545\nLanczos iteration 2\nMVM: 0.00244 secs\nalpha: -0.7116140394927443\nbeta: 2.3044797637130743\neigs: -2.2710052270892791 1.2836940325966804\nLanczos iteration 3\nMVM: 0.00210 secs\nalpha: -1.2772539678430306\nbeta: 2.6627870395174456\neigs: -3.7522788386927637 -0.6474957945455240 2.1352094709026579\n</code></pre>"},{"location":"documentation/utilities/logging/#log-mechanism-c-only","title":"Log mechanism (C++ only)","text":"<p>Producing nicely formatted output is unfortunately a bit cumbersome in standard C++. For this, the <code>Log</code> mechanism in XDiag can help. To simply write out a line of information you can call,</p> <pre><code>Log(\"hello from the logger\");\n</code></pre> <p>By default, a new line is added. It is also possible to set verbosity by handing the level as the first argument,</p> <pre><code>Log(2, \"hello from the logger only if global verbosity is set to &gt;= 2\");\n</code></pre> <p>This message will only appear if the global verbosity level is set to a value \\(\\geq 2\\). Finally, XDiag also supports formatted output by using the fmtlib library. For example, numbers can be formated this way</p> <pre><code>Log(\"pi is around {:.4f} and the answer is {}\", 3.141592, 42);\n</code></pre>"},{"location":"documentation/utilities/timing/","title":"Timing","text":"<p>In standard C++ measuring time is a bit awkward. To quickly monitor the CPU time spent by XDiag by simple functions.</p>"},{"location":"documentation/utilities/timing/#simple-timing-using-tic-toc","title":"Simple timing using tic() / toc()","text":"<p>Similar as in Matlab one can use <code>tic()</code> and <code>toc()</code> to measure the time spent between two points in the code. </p> <pre><code>tic();\ndouble e0 = eigval0(bonds, block);\ntoc();\n</code></pre> <p><code>toc()</code> will output the time spent since the last time <code>tic()</code> has been called.</p>"},{"location":"documentation/utilities/timing/#detailed-timing","title":"Detailed timing","text":"<p>To get the present time, simply call </p> <pre><code>auto time = rightnow();\n</code></pre> <p>A timing (in second) between two time points can be written to output using</p> <pre><code>timing(begin, end);\n</code></pre> <p>This can even be accompanied by a message about what is being timed and a verbosity level (see Logging) can also be set. The full call signature is</p> <pre><code>timing(begin, end, message, level);\n</code></pre> Name Description Default begin starting time computed using <code>rightnow()</code> end end time computed using <code>rightnow()</code> message message string to be prepended to timing \"\" level verbosity level at which timing is printed 0"},{"location":"documentation/utilities/utils/","title":"Utility functions","text":""},{"location":"documentation/utilities/utils/#set_verbosity","title":"set_verbosity","text":"<p>Set how much logging is generated my XDiag to monitor the progress and behaviour of the code. There are three verbosity levels that can be set:</p> <ul> <li>0: no output at all</li> <li>1: some output </li> <li>2: detailed output </li> </ul> <p>This can be useful, e.g. to monitor the progress of an iterative algorithm</p> C++Julia <pre><code>void set_verbosity(int64_t level);\n</code></pre> <pre><code>set_verbosity(level::Int64)\n</code></pre>"},{"location":"documentation/utilities/utils/#say_hello","title":"say_hello","text":"<p>Prints a nice welcome message containing the version number and git commit used.</p> C++Julia <pre><code>void say_hello()\n</code></pre> <pre><code>say_hello()\n</code></pre>"},{"location":"documentation/utilities/utils/#print_version","title":"print_version","text":"<p>If <code>say_hello</code> is too much flower power for you, one can also just have a boring print-out of the version number using this function. </p> C++Julia <pre><code>void print_version()\n</code></pre> <pre><code>print_version()\n</code></pre>"},{"location":"documentation/utilities/xdiag_show/","title":"Debug printing","text":"<p>For quick debugging in C++, XDiag features a simple macro which outputs the name and content of a variable calles <code>XDIAG_SHOW(x)</code>. For example</p> <pre><code>Spinhalf block(16, 8);\nXDIAG_SHOW(block);\n</code></pre> <p>will write an output similar to</p> <pre><code>block:\n  nsites  : 16\n  nup     : 8\n  dimension: 12,870\n  ID       : 0xa9127434d66b9878\n</code></pre> <p>The <code>XDIAG_SHOW(x)</code> macro can be used on any XDiag object and several other standard C++ objects as well.</p>"},{"location":"examples/cmake_distributed/","title":"CMakeLists.txt for the distributed XDiag library","text":""},{"location":"examples/cmake_normal/","title":"CMakeLists.txt for the normal XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(hello_world)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/where/xdiag/should/be/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre>"},{"location":"examples/entanglement_ground_state/","title":"Entanglement Entropy Ground-State XXZ","text":"<p>In this example, we compute the entanglement entropy[1] of the ground state of the spin \\(-\\frac{1}{2}\\) XXZ chain, described by the Hamiltonian: $$ \\mathcal{H} = J \\sum_{n=0}^{N-1} \\left(S^x_n\\cdot S^x_{n+1} + S^y_n\\cdot S^y_{n+1} + \\Delta S^z_n\\cdot S^z_{n+1}\\right).  $$</p> <p>The algorithm follows these steps:</p> <ol> <li> <p>Obtain the ground state using the Lanczos algorithm.</p> </li> <li> <p>Construct the reduced density matrix for the region with the firs \\(\\ell\\) spins by tracing out the complementary degrees of freedom:</p> </li> </ol> \\[ \\rho_{\\ell} = \\text{Tr}_{\\bar{\\ell}} \\left(|\\text{GS}\\rangle \\langle\\text{GS}| \\right). \\] <ol> <li>Compute the entanglement entropy from the reduced density matrix:</li> </ol> \\[ S_\\ell = -\\text{Tr}\\left( \\rho_\\ell \\ln \\rho_\\ell  \\right), \\] <p>which is done by diagonalizing \\(\\rho_\\ell\\).</p> <p></p> <p>As shown in the Figure above, the entanglement entropy of the XXZ chain ground state for two distinct values of \\(\\Delta\\). In the critical phase, when  \\(\\Delta \\in (-J,J)\\) [1], the entanglement entropy follows a logarithmic scaling with the subsystem size, as predicted by (1+1)-dimensional conformal field theory. Specifically, we extract the central charge, \\(c\\), by fitting the entanglement entropy to the expression derived for a finite system[2]: $$ S_{\\text{CFT}}\\left(\\ell,L \\right) = \\dfrac{c}{3} \\ln \\left( \\dfrac{L}{\\pi} \\sin\\left(\\frac{\\pi\\ell}{L}\\right)\\right) + b_0, $$ where \\(L\\) is the total size of the system and \\(b_0\\) is a constant. Away from this regime the system is in gapped phase, the system is in a gapped phase, where the entanglement entropy does not depend on the subsystem size for \\(1\\ll\\ell\\ll L\\),i.e, it follows the area-law behaviour.</p> C++Julia <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nvoid push_to_ps(xdiag::ProductState &amp;ps1, xdiag::ProductState &amp;psA, xdiag::ProductState &amp;psB);\nvoid Create_RDM(arma::cx_mat &amp;RDM, arma::vec &amp;vstate, xdiag::Spinhalf &amp;Block, xdiag::Spinhalf &amp;BlockA, xdiag::Spinhalf &amp;BlockB);\ndouble getVnE(arma::cx_mat &amp;RDM);\n\nint main()\ntry\n{\n    unsigned N = 16;    // chain length\n    double Delta = 1.0; // anisotropy\n\n    auto ops = OpSum();\n    auto block = Spinhalf(N); // Spin1/2 Block full\n\n    for (unsigned i = 0; i &lt; N; i++)\n    {\n        ops += Op(\"Exchange\", {i, (i + 1) % N});\n        ops += Delta * Op(\"SzSz\", {i, (i + 1) % N});\n    }\n\n    auto [e0, gs] = eig0(ops, block); // get GS with Lanczos\n\n    arma::vec vstate = vector(gs);\n\n    arma::mat vne = arma::mat(N / 2, 2, arma::fill::zeros); // Array to store EE as a function of subsystem size\n\n    for (unsigned na = 0; na &lt; N / 2; na++) // Compute the Entanglement entropy for different subsystems from l=1 to l=N/2, as the entanglement entropy satisfies: S(l) = S(N=l).\n    {\n        unsigned nb = N - (na + 1);\n        auto blockA = Spinhalf((na + 1)); // Spin1/2 Block full\n        auto blockB = Spinhalf(nb);       // Spin1/2 Block full\n        arma::cx_mat RDM = arma::cx_mat(dim(blockA), dim(blockA), arma::fill::zeros);\n        Create_RDM(RDM, vstate, block, blockA, blockB);\n        vne(na, 0) = (na + 1);\n        vne(na, 1) = getVnE(RDM);\n    }\n\n    // Construct the filename\n    std::string flstring = \"EE_XXX_model.Nsites.\" + std::to_string(N) + \".Delta\" + std::to_string((double)Delta)  + \".outfile.h5\";\n\n    auto save_fl = FileH5(flstring, \"w!\");\n    save_fl[\"entanglement_entropy\"] = vne;\n    return 0;\n}\ncatch (Error e)\n{\n    error_trace(e);\n}\n\nvoid push_to_ps(xdiag::ProductState &amp;ps1, xdiag::ProductState &amp;psA, xdiag::ProductState &amp;psB)\n{\n    for (auto sub : psA)\n    {\n        ps1.push_back(sub);\n    }\n    for (auto sub : psB)\n    {\n        ps1.push_back(sub);\n    }\n}\n\nvoid Create_RDM(arma::cx_mat &amp;RDM, arma::vec &amp;vstate, xdiag::Spinhalf &amp;Block, xdiag::Spinhalf &amp;BlockA, xdiag::Spinhalf &amp;BlockB)\n{\n    unsigned i = 0;\n    unsigned j = 0;\n    for (auto p1 : BlockA)\n    {\n        j = 0;\n        for (auto p2 : BlockA)\n        {\n            for (auto p3 : BlockB) //loop over all configurations in subspace that we are interested in tracing.\n            {\n                auto p1aux = ProductState();\n                auto p2aux = ProductState();\n                push_to_ps(p1aux, p1, p3);\n                push_to_ps(p2aux, p2, p3);\n                unsigned id1 = index(Block, p1aux);\n                unsigned id2 = index(Block, p2aux);\n                RDM(j, i) += vstate(id2) * std::conj(vstate(id1));\n            }\n            j++;\n        }\n        i++;\n    }\n}\n\ndouble getVnE(arma::cx_mat &amp;RDM)\n{\n    // Compute the Entanglement entropy\n    double vne = 0.0;\n    arma::vec pvals;\n    arma::cx_mat eigvec;\n    arma::eig_sym(pvals, eigvec, RDM); // FULL ED in the RDM\n\n    for (unsigned p = 0; p &lt; pvals.n_elem; p++)\n    {\n        if (pvals(p) &gt; 1e-14)\n            vne -= pvals(p) * log(pvals(p));\n    }\n    return vne;\n};\n</code></pre> <pre><code>using LinearAlgebra\nusing XDiag\nusing HDF5\nusing Printf\n\nfunction push_ProductState!(ps1, psA, psB)\n    for sub in psA\n        push!(ps1, String(sub))\n    end\n    for sub in psB\n        push!(ps1, String(sub))\n    end\nend\n\nfunction Create_RDM(RDM, vstate, Block, BlockA, BlockB) #Function to construct the RDM\n    for (i, p1) in enumerate(BlockA)\n        for (j, p2) in enumerate(BlockA)\n            for (k, p3) in enumerate(BlockB)\n                p1aux = ProductState()\n                p2aux = ProductState()\n                push_ProductState!(p1aux, p1, p3)\n                push_ProductState!(p2aux, p2, p3)\n                id1 = index(Block, p1aux)\n                id2 = index(Block, p2aux)\n                RDM[j, i] += vstate[id2] * conj(vstate[id1])\n            end\n        end\n    end\nend\n\nfunction getVnE(RDM) #Function to compute the entanglement entropy.\n    vne = 0\n    p = eigvals(Hermitian(RDM))#FULL ED in the RDM\n    for i in p\n        if i&gt;1e-14\n            vne -= i*log(i)\n        end\n    end\n    return vne\nend\n\nfunction main()\n    N = 16 # chain length\n    ops = OpSum()\n    block = Spinhalf(N) # Spin1/2 Block full\n    Delta = 1.0\n    for i in 1:N\n        ops += Op(\"Exchange\", [i, mod1(i + 1, N)])\n        ops += Delta*Op(\"SzSz\", [i, mod1(i + 1, N)])\n    end\n\n    e0, gs = eig0(ops, block)# get GS with Lanczos  \n    vstate = vector(gs)\n    vne = zeros(Float64,(length(1:div(N,2)),2))\n    for Na in 1:div(N,2)\n        Nb = N - Na\n        blockA = Spinhalf(Na) # Spin1/2 Block full\n        blockB = Spinhalf(Nb) # Spin1/2 Block full\n        RDM = zeros(ComplexF64, (dim(blockA), dim(blockA)))\n        Create_RDM(RDM, vstate, block, blockA, blockB)\n        vne[Na,1] = Na\n        vne[Na,2] = getVnE(RDM)\n    end\n    filename = @sprintf(\"EE_XXX_model.Nsites.%d.Delta.%d.outfile.h5\", N,Delta)\n    h5open(filename, \"w\") do file\n        write(file, \"vne\", vne)\n    end \nend\n\nmain()\n</code></pre>"},{"location":"examples/entanglement_ground_state/#references","title":"references","text":"<p>[1] Laflorencie, Nicolas, Quantum entanglement in condensed matter systems, Physics Reports 646, 1-59 (2016)</p> <p>[2] Calabrese, Pasquale and Cardy, John, Entanglement entropy and conformal field theory, Journal of Physics A: Mathematical and Theoretical  42,50 (2009) </p>"},{"location":"examples/hello_world/","title":"Hello world!","text":"JuliaC++ <pre><code>   using XDiag\n   say_hello()\n</code></pre> <pre><code>   #include &lt;xdiag/all.hpp&gt;\n\n   using namespace xdiag;\n\n   int main() try {\n     say_hello();\n   } catch (Error e) {\n     error_trace(e);\n   }\n</code></pre>"},{"location":"examples/hubbard_greens_f/","title":"Green's function","text":"<p>Uses the Lanczos algorithm[1] to calculate the Green's function of the Hubbard model. See also the documentation page for the spin structure factor. The Green's function is given by</p> \\[     G({\\bf k}, \\omega)=-i\\int dt e^{-i\\omega t}\\langle \\lbrace c_{\\bf k}(t),c^{\\dagger}_{\\bf k}\\rbrace\\rangle. \\] <p>To achieve a mesh of momentum space, we can use either use the generated momenta inside the Wigner-Seitz cell allowed by the finite cluster or twisted boundary conditions[2], where the lattice \\({\\bf k}\\)-point is shifted to \\({\\bf k + \\boldsymbol{\\theta}}\\) by introducing a flux via Peierls substitution in the Hamiltonian, \\(t_{ij} \\rightarrow t_{ij}\\exp(i{\\bf \\boldsymbol{\\theta}\\cdot r}_{ij})\\). For this example, we're calculating the spectral function along the cut \\(\\Gamma\\)-\\(M\\), i.e., the diagonal of the reciprocal lattice unit cell.</p>"},{"location":"examples/hubbard_greens_f/#example-code","title":"example code","text":"JuliaC++ <pre><code>    using XDiag\n    using HDF5\n\n    function main()\n      say_hello()\n\n      # IO\n      latticeInput = \"../../misc/data/square.8.hubbard.ttprime.toml\"\n      lfile = FileToml(latticeInput)\n\n      filename = \"../../misc/data/examples_output/hubbard_greens_f.h5\"\n      outfile = h5open(filename, \"w\")\n\n      # Define the Hubbard model\n      N = 8\n      nup = 3\n      ndn = 3\n      ops = read_opsum(lfile, \"Interactions\")\n      t = 1.0\n      tp = 0.0\n      ops[\"Ty\"] = t\n      ops[\"Tx\"] = t\n      ops[\"Tprime+\"] = tp\n      ops[\"Tprime-\"] = tp\n      ops += \"U\" * Op(\"HubbardU\")\n      ops[\"U\"] = -6.0\n      @show(ops)\n      opsTBC = ops\n\n      irrep = read_representation(lfile, \"Gamma.C1.A\")\n\n      # compute groundstate (known to be at k=0)\n      println(\"Computing ground state ...\")\n      block = Electron(N, nup, ndn, irrep)\n      e0, gs = eig0(ops, block)\n      make_complex!(gs)\n      println(\"done.\")\n      println(\"Ground state energy: $e0\")\n      outfile[\"e0\"] = e0\n\n      function tbc_mesh(kx, ky)\n        # compare to twisted boundary condition calculation,\n        # cf. Zemljic &amp; Prelovsek, PRB 75, 104514 (2007)\n        # Tohyama, PRB 70, 174517 (2004).\n        println(\"\\n considering TBC momentum [$kx,$ky]\")\n        opsTBC[\"Tx\"] = t * exp(1im * kx)\n        opsTBC[\"Ty\"] = t * exp(1im * ky)\n        opsTBC[\"Tprime+\"] =\n          tp * exp(1im * (kx + ky)) # r_ij = (1,1)\n        opsTBC[\"Tprime-\"] =\n          tp * exp(1im * (kx - ky)) # r_ij = (1,-1)\n\n        e0, gs_tbc = eig0(opsTBC, block)\n        # @show e0\n        c_q_tbc = symmetrize(sqrt(N) * Op(\"Cup\", 1), irrep)\n        Av = apply(c_q_tbc, gs_tbc)\n        @show nrm = norm(Av)\n        Av /= nrm\n\n        res_tbc = eigvals_lanczos_inplace(opsTBC, Av)\n        @show res_tbc.eigenvalues[1]\n        return nrm, res_tbc\n      end\n\n      # loop through momenta\n      irreps = Dict{String,Vector{Float64}}(\n        \"Gamma.C1.A\" =&gt; [0.0, 0.0],\n        \"M.C1.A\" =&gt; [3.1415926535897931, 3.1415926535897931],\n        \"Sigma0.C1.A\" =&gt; [1.5707963267948966, 1.5707963267948966],\n        \"Sigma1.C1.A\" =&gt; [1.5707963267948966, -1.5707963267948966],\n        \"Sigma2.C1.A\" =&gt; [-1.5707963267948966, 1.5707963267948966],\n        \"Sigma3.C1.A\" =&gt; [-1.5707963267948966, -1.5707963267948966],\n        \"X0.C1.A\" =&gt; [3.1415926535897931, 0.0000000000000000],\n        \"X1.C1.A\" =&gt; [0.0000000000000000, 3.1415926535897931])\n      for (name, momentum) in irreps\n        println(\"\\n considering irrep $name, momentum $momentum\")\n        aq_irrep = read_representation(lfile, name)\n        c_q = symmetrize(sqrt(N) * Op(\"Cup\", 1), aq_irrep)\n        Av = apply(c_q, gs)\n        @show nrm = norm(Av)\n        Av /= nrm\n\n        res = eigvals_lanczos_inplace(ops, Av)\n        @show res.eigenvalues[1]\n        outfile[\"$name/norm\"] = nrm\n        outfile[\"$name/alphas\"] = res.alphas\n        outfile[\"$name/betas\"] = res.betas\n        outfile[\"$name/eigs\"] = res.eigenvalues\n\n        tbc_mesh(momentum[1], momentum[2])\n      end\n\n      for (k, kx) in enumerate(0:pi/101:pi)\n        nrm, res_tbc = tbc_mesh(kx, kx)\n\n        ik = \"$(k-1)\" # mimics c++ output\n        # group = create_group(outfile, ik)\n        # subgroup = create_group(group, ik)\n        outfile[\"$ik/$ik/norm\"] = nrm\n        outfile[\"$ik/$ik/alphas\"] = res_tbc.alphas\n        outfile[\"$ik/$ik/betas\"] = res_tbc.betas\n        outfile[\"$ik/$ik/eigs\"] = res_tbc.eigenvalues\n      end\n    end\n\n    main()\n</code></pre> <pre><code>    #include &lt;xdiag/all.hpp&gt;\n\n    using namespace xdiag;\n    using namespace arma;\n    using fmt::format;\n    using namespace std::complex_literals;\n\n    int main() try {\n      say_hello();\n\n      // IO\n      std::string latticeInput =\n          XDIAG_DIRECTORY \"/misc/data/square.8.hubbard.ttprime.toml\";\n      auto lfile = FileToml(latticeInput);\n\n      std::string filename =\n          XDIAG_DIRECTORY \"/misc/data/examples_output/hubbard_greens_f.h5\";\n      auto outfile = FileH5(filename, \"w!\");\n\n      // Define the Hubabrd model\n      int N = 8;\n      int nup = 3;\n      int ndn = 3;\n      auto ops = read_opsum(lfile, \"Interactions\");\n      auto t = -1.;\n      auto tp = 0.;\n      ops[\"Ty\"] = t;\n      ops[\"Tx\"] = t;\n      ops[\"Tprime+\"] = tp;\n      ops[\"Tprime-\"] = tp;\n      ops += \"U\" * Op(\"HubbardU\");\n      ops[\"U\"] = -6.;\n      auto opsTBC = ops;\n\n      auto irrep = read_representation(lfile, \"Gamma.C1.A\");\n\n      // compute groundstate (known to be at k=0)\n      Log(\"Computing ground state ...\");\n      auto block = Electron(N, nup, ndn, irrep);\n      auto [e0, gs] = eig0(ops, block);\n      gs.make_complex();\n      Log(\"gag.\");\n      Log(\"Ground state energy: {:.12f}\", e0);\n      outfile[\"e0\"] = e0;\n\n      auto tbc_mesh =\n          [&amp;opsTBC, &amp;t, &amp;tp, &amp;block, &amp;N,\n           &amp;irrep](double const &amp;kx,\n                   double const &amp;ky) -&gt; std::pair&lt;double, EigvalsLanczosResult&gt; {\n        // lambda to perform TBC calc.\n        // compare to twisted boundary condition calculation,\n        // cf. Zemljic &amp; Prelovsek, PRB 75, 104514 (2007);\n        // Tohyama, PRB 70, 174517 (2004).\n        Log(\"TBC calculation, momentum [{}, {}]\", kx, ky);\n        opsTBC[\"Tx\"] = t * exp(1i * kx);\n        opsTBC[\"Ty\"] = t * exp(1i * ky);\n        opsTBC[\"Tprime+\"] = tp * exp(1i * (kx + ky)); // r_ij = (1,1)\n        opsTBC[\"Tprime-\"] = tp * exp(1i * (kx - ky)); // r_ij = (1,-1)\n        // XDIAG_SHOW(opsTBC);\n        auto [e0_tbc, gs_tbc] = eig0(opsTBC, block, 1e-12, 100);\n        // XDIAG_SHOW(e0_tbc);\n        auto c_q_tbc = symmetrize(sqrt((double)N) * Op(\"Cup\", 0), irrep);\n        auto Av = apply(c_q_tbc, gs_tbc);\n        auto nrm = norm(Av);\n        XDIAG_SHOW(nrm);\n        Av /= nrm;\n\n        auto res_tbc = eigvals_lanczos_inplace(opsTBC, Av, 1, 1e-12, 100);\n        XDIAG_SHOW(res_tbc.eigenvalues(0));\n        Log(\"n iterations {}\", res_tbc.niterations);\n        return {nrm, res_tbc};\n      };\n\n      // loop through momenta of the cluster reciprocal lattice\n      std::vector&lt;std::pair&lt;std::string, arma::vec&gt;&gt; irreps = {\n          {\"Gamma.C1.A\", {0., 0.}},\n          {\"M.C1.A\", {3.1415926535897931, 3.1415926535897931}},\n          {\"Sigma0.C1.A\", {1.5707963267948966, 1.5707963267948966}},\n          {\"Sigma1.C1.A\", {1.5707963267948966, -1.5707963267948966}},\n          {\"Sigma2.C1.A\", {-1.5707963267948966, 1.5707963267948966}},\n          {\"Sigma3.C1.A\", {-1.5707963267948966, -1.5707963267948966}},\n          {\"X0.C1.A\", {3.1415926535897931, 0.0000000000000000}},\n          {\"X1.C1.A\", {0.0000000000000000, 3.1415926535897931}}};\n      for (const auto &amp;[name, momentum] : irreps) {\n        Log(\"considering irrep {}, momentum [{}, {}]\", name, momentum(0),\n            momentum(1));\n        auto aq_irrep = read_representation(lfile, name);\n        auto c_q = symmetrize(sqrt((double)N) * Op(\"Cup\", 0),\n                              aq_irrep); // normalize to 1/sqrt(N)\n        auto Av = apply(c_q, gs);\n        auto nrm = norm(Av);\n        Av /= nrm;\n        XDIAG_SHOW(nrm);\n\n        auto res = eigvals_lanczos_inplace(ops, Av);\n        XDIAG_SHOW(res.eigenvalues(0));\n        outfile[format(\"{}/norm\", name)] = nrm;\n        outfile[format(\"{}/alphas\", name)] = res.alphas;\n        outfile[format(\"{}/betas\", name)] = res.betas;\n        outfile[format(\"{}/eigs\", name)] = res.eigenvalues;\n\n        // compare to tbc calc\n        auto [nrm_tbc, res_tbc] = tbc_mesh(momentum(0), momentum(1));\n        XDIAG_SHOW(nrm_tbc);\n        XDIAG_SHOW(res_tbc.eigenvalues(0));\n      }\n\n      // TBC mesh, 10x10 grid\n      int nkx = 101;\n      int nky = nkx;\n      auto momentum = [&amp;nkx, &amp;nky](int const &amp;ikx,\n                                   int const &amp;iky) -&gt; std::pair&lt;double, double&gt; {\n        return {(double)ikx * 3.1415926535897931 / (double)(nkx - 1),\n                (double)iky * 3.1415926535897931 / (double)(nky - 1)};\n      };\n      for (int ikx = 0; ikx &lt; nkx; ++ikx) {\n        auto iky = ikx;\n        // for (int iky = 0; iky &lt; nky; ++iky) {\n        auto [kx, ky] = momentum(ikx, iky);\n        auto [nrm, res] = tbc_mesh(kx, ky);\n        XDIAG_SHOW(nrm);\n        XDIAG_SHOW(res.eigenvalues(0));\n\n        outfile[format(\"{}/{}/norm\", ikx, iky)] = nrm;\n        outfile[format(\"{}/{}/alphas\", ikx, iky)] = res.alphas;\n        outfile[format(\"{}/{}/betas\", ikx, iky)] = res.betas;\n        outfile[format(\"{}/{}/eigs\", ikx, iky)] = res.eigenvalues;\n        outfile[format(\"{}/{}/kx\", ikx, iky)] = kx;\n        outfile[format(\"{}/{}/ky\", ikx, iky)] = ky;\n        // }\n      }\n\n    } catch (Error e) {\n      error_trace(e);\n    }\n</code></pre>"},{"location":"examples/hubbard_greens_f/#references","title":"references","text":"<p>[1]  Prelov\u0161ek, P., &amp; Bon\u010da, J. (2013). Ground state and finite temperature Lanczos methods. Strongly Correlated Systems: Numerical Methods, 1-30.</p> <p>[2] Tohyama, T. (2004). Asymmetry of the electronic states in hole-and electron-doped cuprates: Exact diagonalization study of the \\(t-t\u2032-t \u2033-J\\) model. Phys. Rev. B, 70(17), 174517</p>"},{"location":"examples/specific_heat_randomtj/","title":"Specific Heat Random t-J Model","text":"<p>We use full exact diagonalisation (ED) to calculate the specific heat in the t-J model with \\(N\\) sites, incorporating all-to-all random interactions and hoppings, $$ \\mathcal{H} = \\frac{1}{\\sqrt{N}}\\sum_{i\\neq j=0}^{N-1} t_{i j} P c^\\dagger_{i\\alpha} c_{j\\alpha} + \\frac{1}{\\sqrt{N}} \\sum_{i&lt; j=0}^{N-1} J_{ij} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j, $$ where \\(P\\) is the projection on non-doubly occupied sites, \\(\\boldsymbol{S}_i=\\frac{1}{2}c^\\dagger_{i\\alpha} \\boldsymbol{\\sigma}_{\\alpha \\beta}c_{j\\beta}\\) is the spin operator on site \\(i\\). Both the hoppings \\(t_{ij}=t^\\ast_{ji}\\) and the exchange interation \\(J_{ij}\\) are independent random numbers with zero mean and variance \\(\\bar{t}^2 and\\bar{J}^2\\), respectively. This type of system exhibits a transition from a spin glass to a disordered Fermi liquid with increasing doping [1]. Notably, at the critical value of the doping, \\(p_c \\sim1/3\\), the model displays features reminiscent of the criticality observed in SYK models.</p> <p>The following algorithm constructs the t-J Hamiltonian and computes the specific heat using full ED for each realization of the random couplings. The specific heat is then obtained by performing disorder averaging in the post-processing step. In the figure above, we illustrate the case where \\(\\bar{t}^2 = \\bar{J}^2\\), \\(N=8\\), and the number of fermions with spin-up and spin-down is \\(2\\).</p> <p></p> C++Julia <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;random&gt;\n#include &lt;xdiag/all.hpp&gt;\n\nconst unsigned Nsites = 8;   // total number of sites\nconst unsigned Nup = 2;       // total number of spin-up fermions\nconst unsigned Ndn = 2;       // total number of spin-down fermions\nconst unsigned Nsamples = 200; // number of disorder averages\nconst double thopp = 1.0;     // Variances hopping elements\nconst double Jhopp = 1.0;     // Variances exchange elements\n\n// Create random devices to generate random couplings\nstd::random_device rd;\nstd::vector&lt;unsigned int&gt; seeds = {rd(), rd(), rd(), rd(), rd()};\nstd::seed_seq seq(seeds.begin(), seeds.end());\nstd::mt19937 gen(seq);\n\nusing namespace xdiag;\n\nvoid get_H(xdiag::OpSum &amp;H);\n\nint main()\ntry\n{\n    // define Hamiltonian\n    auto block = tJ(Nsites, Nup, Ndn); // tj model sites\n\n    // Temperature range to compute the specific heat\n    arma::vec Temp = arma::linspace&lt;arma::vec&gt;(0.01, 0.5, 64);\n\n    // array to store specific heat\n    arma::mat C = arma::mat(Temp.n_elem, Nsamples, arma::fill::zeros);\n\n    // Obtain different disorder realizations\n    arma::vec eigs;\n    arma::cx_mat vecs;\n\n    // Generate bond interactions. Save all possible elements in a vector of strings to modifie latter\n    auto H = OpSum();\n    for (unsigned i = 0; i &lt; Nsites; i++)\n    {\n        for (unsigned j = (i + 1); j &lt; Nsites; j++)\n        {\n            std::string Sij = \"S_\" + std::to_string(i) + \"_\" + std::to_string(j);\n            std::string tij = \"t_\" + std::to_string(i) + \"_\" + std::to_string(j);\n            H += Sij * Op(\"SdotS\", {i, j});\n            H += tij * Op(\"Hop\", {i, j});\n        }\n    }\n\n    for (unsigned i = 0; i &lt; Nsamples; i++)\n    {\n\n        get_H(H); // generate new random couplings for the tj Hamiltonian\n\n        arma::cx_mat Hmat = matrixC(H, block); // convert to matrix\n        arma::eig_sym(eigs, vecs, Hmat);       // perform exact diagonalization\n        for (unsigned j = 0; j &lt; Temp.n_elem; j++)\n        {\n            arma::vec exp_eval = arma::exp(-eigs / Temp(j));\n            double Z = arma::sum(exp_eval); // Partition function;\n            double energy = arma::sum(eigs % exp_eval) / Z;\n            C(j, i) = (1.0 / pow(Temp(j), 2)) * (arma::sum(eigs % (eigs % exp_eval)) / Z - pow(energy, 2)); // Specific Heat\n        }\n    }\n\n    std::string filename = \"randomtj.Nsites.\" + std::to_string((unsigned)Nsites) + \".outfile.h5\";\n\n    auto save_fl = FileH5(filename, \"w!\");\n    save_fl[\"Temperature\"] = Temp;\n    save_fl[\"Specific_Heat\"] = C;\n\n    return 0;\n}\ncatch (Error e)\n{\n    error_trace(e);\n}\n\nvoid get_H(xdiag::OpSum &amp;H)\n{\n    // Normal random generators\n    std::normal_distribution&lt;double&gt; Jdist(0.0, pow(Jhopp, 2));\n    std::normal_distribution&lt;double&gt; tdist(0.0, pow(thopp, 2)/ sqrt(2.0));\n\n    // update random couplings\n    for (unsigned i = 0; i &lt; Nsites; i++)\n    {\n        for (unsigned j = (i + 1); j &lt; Nsites; j++)\n        {\n            std::string Sij = \"S_\" + std::to_string(i) + \"_\" + std::to_string(j);\n            std::string tij = \"t_\" + std::to_string(i) + \"_\" + std::to_string(j);\n            H[Sij] = Jdist(gen) / sqrt(Nsites);\n            H[tij] = std::complex&lt;double&gt;(tdist(gen), tdist(gen)) / sqrt(Nsites);\n        }\n    }\n}\n</code></pre> <pre><code>using XDiag\nusing Random, Distributions\nusing LinearAlgebra\nusing Printf\nusing HDF5\n\n\nfunction get_H!(H::OpSum, Nsites::Int, thopp::Float64, Jhopp::Float64)\n    #Variance of the hopping and interaction parameter:\n    thopp = 1.0\n    Jhopp = 1.0\n    Jdist = Normal(0.0, Jhopp^2) # Normal distribution\n    tdist = Normal(0.0, thopp^2 / sqrt(2.0)) # thopp\n\n    for i in 1:Nsites\n        for j in (i+1):Nsites\n            H[\"J_{$i}_{$j}\"] = rand(Jdist) / sqrt(Nsites)\n            H[\"t_{$i}_{$j}\"] = (rand(tdist) + 1im * rand(tdist)) / sqrt(Nsites)\n        end\n    end\nend\n\n\nfunction main()\n    Random.seed!(123) # seed this\n\n    Nsamples = 200\n    # define Hamiltonian\n    Nsites = 8 # total number of sites\n    nup = 2 # total number of spin-up fermions\n    ndn = 2 # total number of spin-down fermions\n    block = tJ(Nsites, nup, ndn) # tj model sites\n\n    Temp = LinRange(0.01, 0.5, 64) # temperature array\n    C = zeros(Float64, (length(Temp), Nsamples)) # array to store specific heat\n\n    #build Hamiltonian\n    H = OpSum()\n    for i in 1:Nsites\n        for j in (i+1):Nsites\n            H += \"J_{$i}_{$j}\" * Op(\"SdotS\", [i, j])\n            H += \"t_{$i}_{$j}\" * Op(\"Hop\", [i, j])\n        end\n    end\n\n    for i in 1:Nsamples\n        get_H!(H, Nsites, 1.0, 1.0) #generate random Hamiltonian\n        Hmat = matrix(H, block)\n        evals = eigvals(Hermitian(Hmat))\n\n        for (j, t) in enumerate(Temp)\n            exp_eval = exp.(-evals ./ t)\n            Z = sum(exp_eval)  # Partition function\n            energy = sum(evals .* exp_eval) / Z\n            C[j, i] = (1.0 / t^2) * (sum(evals .* evals .* exp_eval) / Z - energy^2)\n        end\n    end\n\n    filename = @sprintf(\"randomtj.Nsites.%d.outfile.h5\", Nsites)\n\n    h5open(filename, \"w\") do file\n        write(file, \"Temperature\", collect(Temp))\n        write(file, \"Specific_Heat\", C)\n    end\nend\n\nmain()\n</code></pre>"},{"location":"examples/specific_heat_randomtj/#references","title":"references","text":"<p>[1] H. Shackleton, A. Wietek, A. Georges, S. Sachdev, Quantum Phase Transition at Nonzero Doping in a Random t-J Model. Phys. Rev. Lett. 126, 136602 (2021)</p>"},{"location":"examples/spinhalf_chain_domain_wall_dynamics/","title":"Domain Wall Dynamics in a Spin-\\(1/2\\) Chain","text":"<p>This example demonstrates the time-evolution of quantum states in <code>XDiag</code> for the dynamics of a domain wall in the ferromagnetic spin-\\(1/2\\) XXZ chain</p> \\[     H = \\sum_{i=1}^{N-1} \\Big(- J \\bm{S}^z_i \\cdot \\bm{S}^z_{i+1} + \\frac{\\Delta}{2}\\big( \\bm{S}^+_i \\cdot \\bm{S}^-_{i+1} + \\bm{S}^-_i \\cdot \\bm{S}^+_{i+1} \\big) \\Big), \\] <p>where \\(0 &lt; J\\). Note that here we use open instead of periodic boundary conditions, allowing to have a single domain wall in the system.</p> <p>We choose as initial state the following eigenstate of the associated Ising chain (i.e. the model with only \\(S^zS^z\\) interactions)</p> \\[ \\ket{\\psi_0} = \\ket{\\uparrow\\ldots\\uparrow\\downarrow\\ldots\\downarrow}, \\] <p>having a domain wall in the middle of the chain. We expect the exchange terms in the XXZ Hamiltonian above to dissolve the domain wall over time as \\(\\ket{\\psi_0}\\) is not an eigenstate of the XXZ chain. This process may also be viewed as suddenly turning on exchange interactions in an Ising chain.</p> <p>The code below demonstrates how the the initial domain wall slowly dissolves. The following figure was created using the Julia version of the code, which includes a plotting command:</p> <p></p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\n\nint main() \ntry {\n\n    // define open ferromagnetic XXZ chain\n    int N = 16;\n    double J = 0.1;\n    double Delta = 0.5;\n\n    auto H = OpSum();\n    for (int i=0; i&lt;(N-1); i++){\n        H += \"J\" * Op(\"SzSz\", {i, i+1});\n        H += \"Delta\" * Op(\"Exchange\", {i, i+1});\n    }\n\n    H[\"J\"] = J;\n    H[\"Delta\"] = Delta;\n\n    // define initial state with domain wall\n    auto block = Spinhalf(N);\n    std::vector&lt;std::string&gt; psi0_vec (N);\n    for (int i=0; i&lt;N/2; i++) {psi0_vec[i] = \"Up\";}\n    for (int i=N/2; i&lt;N; i++) {psi0_vec[i] = \"Dn\";}\n    auto psi0 = product_state(block, psi0_vec);\n\n    // time evolve psi0 and measure Sz expectation value\n    double dt = 0.5;\n    int Nt = 30;\n    std::vector&lt;std::vector&lt;double&gt; &gt; Sz_expectation(Nt, std::vector&lt;double&gt;(N));\n    State psi_t;\n    for (int t_step=0; t_step&lt;Nt; t_step++){\n        psi_t = time_evolve(H, psi0, dt*t_step);\n        for (int i=0; i&lt;N; i++){\n            Sz_expectation[t_step][i] = innerC(Op(\"Sz\", {i}), psi_t).real(); // result must be real\n        }\n    }\n\n    // do something here with Sz_expectation (see Julia version for plotting routine)\n\n    return 0;\n} catch(Error e){\n    error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing Plots \n\nfunction main()\n\n    # define open ferromagnetic XXZ chain\n    N = 16\n    J = 0.1\n    Delta = 0.5\n\n    H = OpSum()\n    for i in 1:(N-1)\n        H += \"J\" * Op(\"SzSz\", [i, i+1])\n        H += \"Delta\" * Op(\"Exchange\", [i, i+1])\n    end\n\n    H[\"J\"] = J\n    H[\"Delta\"] = Delta\n\n    # define initial state with domain wall\n    block = Spinhalf(N)\n    psi0_vec = vcat(repeat([\"Up\"], N\u00f72), repeat([\"Dn\"], N\u00f72))\n    psi0 = product_state(block, psi0_vec)\n\n    # time evolve and measure Sz expectation value\n    dt = 0.5\n    Nt = 30\n    Sz_expectation = Matrix{Float64}(undef, Nt, N)\n    for t_step in 1:Nt\n        psi_t = time_evolve(H, psi0, dt*t_step)\n        for i in 1:N\n            Sz_expectation[t_step, i] = real(inner(Op(\"Sz\", [i]), psi_t))\n        end\n    end\n\n    # plot Sz expectation value\n    @show heatmap(\n        Sz_expectation,\n        c = :thermal,\n        xlabel=\"chain coordinate\",\n        ylabel=\"time step\",\n        title = \"Sz expectation value over time\")\n\nend\n\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_e0/","title":"Groundstate energy","text":"C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\n\nlet\n    say_hello()\n    N = 16\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    set_verbosity(2)            # set verbosity for monitoring progress\n    e0 = eigval0(ops, block)    # compute ground state energy\n\n    println(\"Ground state energy: $e0\")\nend\n</code></pre>"},{"location":"examples/spinhalf_chain_gs_corr_symmetries/","title":"\\(S=\\frac12\\) chain: Symmetries and Ground State Correlators","text":"<p>This example demonstrates how ground state expectation values can be computed for the spin-\\(\\frac{1}{2}\\) XXX antiferromagnetic chain</p> \\[     H = \\sum_{\\langle i, j \\rangle} \\bm{S}_i \\cdot \\bm{S}_j = \\sum_{\\langle i, j \\rangle} (S^x_i S^x_j + S^y_i S^y_j + S^z_i S^z_j) \\] <p>with periodic boundary conditions.</p> <p>This is done in three different ways, showcasing how the conservation of the overall number of up-spins as well as translation symmetry can be used to lower memory requirements.</p> <ul> <li> <p>The function <code>gs_correlator_simple()</code> is the most basic way of obtaining the ground state and computing a correlator. It does not use any of the aforementioned symmetries of the system and therefore needs to store a full Hilbert space vector. Although being fast, this can cause memory issues.</p> </li> <li> <p>The function <code>gs_correlator_Sz_sym()</code> exploits that \\(H\\) conserves the number of up-spins, decomposing the Hamiltonian into \\(N+1\\) separate blocks with a fixed number \\(n_{up} = 0, 1, \\ldots, N\\) of spins pointing up. The Lanczos algorithm is then performed on each of the sub-blocks which may take longer but yields a ground state vector whose size is bounded by the size of the largest sub-block, substantially reducing the memory footprint.</p> </li> <li> <p>The function <code>gs_correlator_translation_sym()</code> exploits that all nearest-neighbor bonds are equal and periodic boundary conditions are used. Thus, the Hamiltonian is invariant under translations and decomposes into \\(N\\) irreducible representations (irreps) labelled by lattice momentum \\(2\\pi/N \\times k\\) where \\(k=0, 1, \\ldots, N-1\\). Again, the Lanczos algorithm is run on all momentum sub-blocks, effectively exchanging a longer runtime for less memory consumption. An important caveat when working with representations is that the operators inside expectation values must be symmetrized with respect to the symmetry group.</p> </li> </ul> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include &lt;math.h&gt;\n\nusing namespace xdiag;\n\n// treat Hilbert space as a whole (memory consuming)\nvoid gs_correlator_simple(int N, OpSum&amp; H, OpSum&amp; corr_op){\n    auto full_block = Spinhalf(N);\n    auto lanczos_res = eigs_lanczos(H, full_block);\n    auto e0 = lanczos_res.eigenvalues[0];\n    auto psi0 = lanczos_res.eigenvectors;\n    auto corr = inner(corr_op, psi0);\n\n    Log(\"Ground state energy: {:.12f}\", e0);\n    Log(\"Ground state correlator: {:.12f}\", corr);\n    Log(\"State vector length: {:d}\", size(psi0));\n};\n\n// use Sz_tot conservation (less memory consuming)\nvoid gs_correlator_Sz_sym(int N, OpSum&amp; H, OpSum&amp; corr_op){\n    double e0 = 0.0;\n    double gs;\n    State psi0;\n    // check blocks with fixed number of up-spins\n    for (int nup = 0; nup &lt; N+1; nup++){\n        auto sym_block = Spinhalf(N, nup);\n        auto lanczos_res = eigs_lanczos(H, sym_block);\n        gs = lanczos_res.eigenvalues[0];\n        if (gs &lt; e0){\n            e0 = gs;\n            psi0 = lanczos_res.eigenvectors;\n        };\n    };\n    auto corr = inner(corr_op, psi0);\n\n    Log(\"Ground state energy: {:.12f}\", e0);\n    Log(\"Ground state correlator: {:.12f}\", corr);\n    Log(\"State vector length: {:d}\", size(psi0));\n};\n\nstd::complex&lt;double&gt; C_N_character(int N, int k, int p){\n    return std::exp( ( (2 * k * p) * M_PI / (double)N ) * std::complex&lt;double&gt;(0,1.) );\n\n};\n\n// use translation symmetry (less memory consuming)\nvoid gs_correlator_translation_sym(int N, OpSum&amp; H, OpSum&amp; corr_op){\n\n    // define shift by one site\n    std::vector&lt;int64_t&gt; T_perm (N, 0);\n    for (int i=0; i&lt;N-1; i++){\n        T_perm[i] = i + 1;\n    };\n    auto T = Permutation(T_perm);\n\n    // define cyclic group\n    std::vector&lt;Permutation&gt; perms (N);\n    for (int i=0; i&lt;N; i++){\n        perms[i] = pow(T, i);\n    };\n    auto C_N = PermutationGroup(perms);\n\n\n    // define irreps from character tables, labelled by momentum (2pi/N \u00d7) k\n    std::vector&lt;Representation&gt; irreps (N);\n    std::vector&lt;std::complex &lt;double&gt; &gt; characters (N, 0.0);\n    for (int k = 0; k &lt; N; k++){\n        for (int p=0; p&lt;N; p++){\n            characters[p] = C_N_character(N, k, p);\n        };\n        irreps[k] =  Representation(C_N, characters);\n    };\n\n    // check all translation symmetry blocks\n    double e0 = 0.0;\n    double gs;\n    State psi0;\n    for (int k = 0; k &lt; N; k++){\n        auto sym_block = Spinhalf(N, irreps[k]);\n        auto lanczos_res = eigs_lanczos(H, sym_block);\n        gs = lanczos_res.eigenvalues[0];\n        if (gs &lt; e0){\n            e0 = gs;\n            psi0 = lanczos_res.eigenvectors;\n        };\n    };\n\n    // now the operator must be symmetrized!\n    auto corr = inner(symmetrize(corr_op, C_N), psi0);\n\n    Log(\"Ground state energy: {:.12f}\", e0);\n    Log(\"Ground state correlator: {:.12f}\", corr);\n    Log(\"State vector length: {:d}\", size(psi0));\n};\n\n\n\n\nint main() try {\n\n    // periodic N-site Heisenberg antiferromagnet\n    int N = 14;\n    auto H = OpSum();\n    for (int i = 0; i &lt; N; i++) {\n        H += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n    };\n    H[\"J\"] = 1.0;\n\n    // define spin correlator at \"half-chain\" distance\n    auto corr_op = OpSum();\n    corr_op = Op(\"SdotS\", {0, N/2 - 1});\n\n    // run different implementations\n    gs_correlator_simple(N, H, corr_op);\n\n    gs_correlator_Sz_sym(N, H, corr_op);\n\n    gs_correlator_translation_sym(N, H, corr_op);\n\n} catch (Error e) {\n        error_trace(e);\n};\n</code></pre> <pre><code>using XDiag\n\nfunction main()\n\n    # periodic N-site Heisenberg antiferromagnet\n    N = 14\n    H = OpSum()\n    for i in 1:N\n        H += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    H[\"J\"] = 1.0 \n\n    # define spin correlator at \"half-chain\" distance\n    corr_op = OpSum()\n    corr_op += Op(\"SdotS\", [1, N \u00f7 2])\n\n    # run different implementations\n    gs_correlator_simple(N, H, corr_op)\n\n    gs_correlator_Sz_sym(N, H, corr_op)\n\n    gs_correlator_translation_sym(N, H, corr_op)\n\nend\n\n# treat Hilbert space as a whole (memory consuming)\nfunction gs_correlator_simple(N::Int, H::OpSum, corr_op::OpSum)\n    full_block = Spinhalf(N) \n    lanczos_res = eigs_lanczos(H, full_block)\n    e0 = lanczos_res.eigenvalues[1]\n    psi0 = lanczos_res.eigenvectors    \n    corr = inner(corr_op, psi0)\n\n    println(\"Ground state energy: $e0\")\n    println(\"Ground state correlator: $corr\")\n    println(\"State vector length = \", size(psi0))\nend\n\n# use Sz_tot conservation (less memory consuming) \nfunction gs_correlator_Sz_sym(N::Int, H::OpSum, corr_op::OpSum)\n    e0 = Inf\n    psi0 = nothing\n    Nup_vals = 0:N\n    # check blocks with fixed number of up-spins\n    for nup in Nup_vals\n        sym_block = Spinhalf(N, nup) \n        lanczos_result = eigs_lanczos(H, sym_block)\n        gs = lanczos_result.eigenvalues[1]\n        if  gs &lt; e0\n            e0 = gs\n            psi0 = lanczos_result.eigenvectors \n        end\n    end    \n    corr = inner(corr_op, psi0)\n\n    println(\"Ground state energy: $e0\")\n    println(\"Ground state correlator: $corr\")\n    println(\"State vector length = \", size(psi0))\nend\n\n# use translation symmetry (less memory consuming)\nfunction gs_correlator_translation_sym(N::Int, H::OpSum, corr_op::OpSum)\n\n    # define shift by one site\n    T = Permutation(circshift(1:N, -1))\n\n    # define cyclic group\n    C_N = PermutationGroup([T^k for k in 0:(N-1)])\n\n    # define irreps from character tables, labelled by momentum (2pi/N \u00d7) k\n    character_table = [ [C_N_character(N, k, p) for p in 0:(N-1)] for k in 0:(N-1)]\n    irreps = [ Representation(C_N, character_table[k]) for k in 1:N ]   \n\n    # check all translation symmetry blocks\n    e0 = Inf\n    psi0 = nothing\n    for k in eachindex(irreps)\n        sym_block = Spinhalf(N, irreps[k]) \n        lanczos_result = eigs_lanczos(H, sym_block)\n        gs = lanczos_result.eigenvalues[1]\n        if  gs &lt; e0\n            e0 = gs\n            psi0 = lanczos_result.eigenvectors\n        end\n    end\n\n    # now the operator must be symmetrized!\n    corr = inner(symmetrize(corr_op, C_N), psi0)\n\n    println(\"Ground state energy: $e0\")\n    println(\"Ground state correlator: $corr\")\n    println(\"State vector length = \", size(psi0))\nend\n\nfunction C_N_character(N::Int, k::Int, p::Int)\n    exp(im * 2 * pi * k * p / N)\nend\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_level_statistics/","title":"Level Statistics in Spin-\\(1/2\\) Chains","text":"<p>This example demonstrates the differing level statistics of integrable and non-integrable models using the example of spin-\\(1/2\\) chains.</p> <p>The term level statistic refers to the probability distribution \\(P(s)\\) where the variable \\(s\\) is the difference between adjacent energy levels \\(0 \\leq E_{i+1}-E_i\\). That is, for a given quantum system \\(P(s)\\) describes the likelihood that the next excited state above a randomly chosen energy level \\(E\\) has energy \\(E + s\\). To ensure comparability across different systems, one typically normalizes the level spacings by its mean value \\(\\tilde{s} = s/ \\bar{s}\\) and considers \\(P(\\tilde{s})\\). Since this is the standard procedure, we will assume that \\(P(s)\\) is the distribution of the normalized energy differences below instead of writing \\(P(\\tilde{s})\\).</p> <p>It is well established that for integrable systems (i.e. those with conserved quantities) the level statistic is a Poissonian</p> \\[P_{\\mathrm{Poiss}}(s) = \\exp(-s)\\] <p>whereas the so-called Wigner-Dyson distribution emerges for non-integrable systems</p> \\[P_{\\mathrm{WD}}(s) = \\frac{\\pi s}{2} \\exp(- \\pi s^2/4).\\] <p>Intuitively speaking, this is because having a system with symmetries and associated conserved quantities leads to degeneracies that contribute to seeing \\(s=0\\) very often such that \\(P_{\\mathrm{Pois}}(0) &gt; 0\\). On the contrary, the energy levels of non-integrable systems are approximately randomly distributed (especially in the bulk of the spectrum), giving a distribution satisfying \\(P_{\\mathrm{WD}}(0) = 0\\).</p> <p>To showcase this, we inspect two spin-\\(1/2\\) Hamiltonians on a chain, one being the integrable XXZ model</p> \\[     H_{\\mathrm{i}} = \\sum_{\\langle i, j \\rangle} \\Big(J \\bm{S}^z_i \\cdot \\bm{S}^z_j + \\frac{\\Delta}{2}\\big( \\bm{S}^+_i \\cdot \\bm{S}^-_j + \\bm{S}^-_i \\cdot \\bm{S}^+_j \\big) \\Big) \\] <p>while the second merely adds a next-nearest-neighbor interaction</p> \\[     H_{\\mathrm{ni}} = H_{\\mathrm{i}} + \\sum_{&lt;&lt; i, j &gt;&gt;} J_2 \\bm{S}^z_i \\cdot \\bm{S}^z_j \\] <p>and becomes \"non-integrable\". We must put \"non-integrable\" in quotes here, since strictly speaking both models are integrable. However, the \\(H_{\\mathrm{ni}}\\) system becomes non-integrable once the trivial spin-flip, mirror, and translation symmetries (we employ periodic boundary conditions) are removed. This is done by considering specific sectors of the total Hilbert space which is easily done in <code>XDiag</code>.</p> <p>The code below demonstrates how the level statistics of these systems can be computed inside the sectors where all trivial symmetries are removed. The Julia version also contains a simple plotting method, leading to the following distribution of level statistics:</p> <p></p> C++Julia <pre><code>#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include &lt;math.h&gt;\n#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\n\nstd::complex&lt;double&gt; C_N_character(int N, int k, int p){\n    return std::exp( ( (2 * k * p) * M_PI / (double)N ) * std::complex&lt;double&gt;(0,1.) );\n\n};\n\nstd::vector&lt;double&gt; compute_level_statistics(int N, OpSum H){\n\n    // fix magnetization (Sztot = 0 still has spin-flip symmetry!)\n    int Nup = N/2 + 1;\n\n    // fix lattice momentum (k = 0, N/2 still have parity symmetry!)\n    int k = 1;\n\n    std::vector&lt;int64_t&gt; T_perm (N, 0);\n    for (int i=0; i&lt;N-1; i++){\n        T_perm[i] = i + 1;\n    };\n    auto T = Permutation(T_perm);\n\n    std::vector&lt;Permutation&gt; perms (N);\n    for (int i=0; i&lt;N; i++){\n        perms[i] = pow(T, i);\n    };\n    auto C_N = PermutationGroup(perms);\n\n    std::vector&lt; std::complex &lt;double&gt; &gt; irrep_k_characters (N, 0.0);\n    for (int p=0; p&lt;N; p++){\n        irrep_k_characters[p] = C_N_character(N, k, p);\n    };\n    auto irrep_k = Representation(C_N, irrep_k_characters);\n\n    // block of Hamiltonian without remaining symmetries\n    auto block = Spinhalf(N, Nup, irrep_k);\n\n    // find its eigenspectrum\n    arma::cx_mat Hmat = matrixC(H, block);     \n    arma::vec eigenvalues = eig_sym(Hmat);\n\n    // compute level statistics (taking only the inner most half of spectrum)\n    int N_levels = eigenvalues.n_elem;\n    int s_start = (int)(0.25 * N_levels);\n    int s_stop = (int)(0.75 * N_levels);\n    int s_num = s_stop - s_start;\n    std::vector&lt;double&gt; s_arr (s_num);\n    double s_arr_sum = 0.0;\n    for (int i=0; i&lt;s_num; i++){\n        s_arr[i] = eigenvalues[s_start+i+1] - eigenvalues[s_start+i];\n        s_arr_sum += s_arr[i];\n    }\n    s_arr_sum = s_arr_sum / s_num;\n\n    // normalize\n    for (int i=0; i&lt;s_num; i++){\n        s_arr[i] = s_arr[i] /  s_arr_sum;\n    }\n\n    return s_arr;\n}\n\n\nint main() try {\n\n    int N = 18; // length of spin chain\n\n    // definition of integrable model\n    auto H_i = OpSum();\n    for (int i=0; i&lt;N; i++){\n        H_i += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n        H_i += \"Delta\" * Op(\"Exchange\", {i, (i+1)%N});\n    }\n\n    // definition of non-integrable model\n    auto H_ni = OpSum();\n    for (int i=0; i&lt;N; i++){\n        H_ni += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n        H_ni += \"Delta\" * Op(\"Exchange\", {i, (i+1)%N});\n        H_ni += \"J2\" * Op(\"SzSz\", {i, (i+2)%N});\n    }\n\n    // assign coupling values\n    double J, Delta, J2;\n    J = 1.0;\n    Delta = J2 = 0.5;\n\n    H_i[\"J\"] = H_ni[\"J\"] = J;\n    H_i[\"Delta\"] = H_ni[\"Delta\"] = Delta;\n    H_ni[\"J2\"] = J2;\n\n    // compute level statistics (remember to eliminate trivial symmetries!)\n    std::vector&lt;double&gt; H_i_statistics = compute_level_statistics(N, H_i); \n    std::vector&lt;double&gt; H_ni_statistics = compute_level_statistics(N, H_ni); \n\n    // do something with H_i_statistics and H_ni_statistics here (Julia version has a plotting routine)\n    return 0;\n\n} catch(Error e) {\n    error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing LinearAlgebra # exact diagonalization\nusing Plots # optional: plot histograms\n\n\nfunction main()\n\n    N = 18\n\n    # definition of integrable model\n    H_i = OpSum()\n    for i in 1:N\n        H_i += \"J\" * Op(\"SzSz\", [i,mod1(i+1, N)])\n        H_i += \"Delta\" * Op(\"Exchange\", [i, mod1(i+1, N)])\n    end\n\n    # definition of non-integrable model\n    H_ni = OpSum()\n    for i in 1:N\n        H_ni += \"J\" * Op(\"SzSz\", [i, mod1(i+1, N)])\n        H_ni += \"Delta\" * Op(\"Exchange\", [i, mod1(i+1, N)])\n        H_ni += \"J2\" * Op(\"SzSz\", [i, mod1(i+2, N)])\n    end\n\n    # assign coupling values\n    J = 1.0\n    Delta = J2 = 0.5\n\n    H_i[\"J\"] = H_ni[\"J\"] = J\n    H_i[\"Delta\"] = H_ni[\"Delta\"] = Delta\n    H_ni[\"J2\"] = J2\n\n    # compute level statistics (remember to eliminate trivial symmetries!)\n    H_i_statistics = compute_level_statistics(N, H_i)\n    H_ni_statistics = compute_level_statistics(N, H_ni)\n\n    # optional plot of histograms (only in Julia version!)\n    plot_histograms(H_i_statistics, H_ni_statistics)\nend\n\n\nfunction compute_level_statistics(N::Int, H::OpSum) :: Vector{Float64}\n\n    # fix magnetization (Sz_tot = 0 still has spin-flip symmetry!)\n    Nup = N\u00f72 + 1\n\n    # fix lattice momentum (k = 0, N/2 still have parity symmetry!)\n    k = 1\n    T = Permutation(circshift(1:N, -1))\n    C_N = PermutationGroup([T^p for p in 0:(N-1)])\n    irrep_k_characters = [C_N_character(N, k, p) for p in 0:(N-1)]\n    irrep_k = Representation(C_N, irrep_k_characters)\n\n    # block of Hamiltonian without remaining symmetries\n    block = Spinhalf(N, Nup, irrep_k) \n\n    # find its eigenspectrum\n    Hmat = matrix(H, block)\n    eigenvalues = eigvals(Hermitian(Hmat))\n\n    # compute level statistics (taking only inner most half of spectrum)\n    N_levels = size(block)\n    s_start = trunc(Int, 0.25*N_levels)\n    s_stop = trunc(Int, 0.75*N_levels)\n    s_num = s_stop - s_start\n    s_arr = Vector{Float64}(undef, s_num)\n    s_arr_sum = 0.0\n    for i in 1:s_num\n        s_arr[i] = eigenvalues[s_start+i+1] - eigenvalues[s_start+i]  \n        s_arr_sum += s_arr[i]\n    end\n\n    # normalize\n    return s_arr / (s_arr_sum / s_num)\nend \n\n\nfunction C_N_character(N::Int, k::Int, p::Int)\n    return exp( im * 2 * pi * p * k * 1.0 / N )\nend\n\n\nfunction plot_histograms(integ_stat::Vector{Float64}, noninteg_stat::Vector{Float64})\n    # plot histograms\n    smax = 3\n    Nbins = 20\n    bins = LinRange(0, smax, Nbins)\n    histogram(\n        [integ_stat noninteg_stat],\n        bins=bins,\n        normalize=:pdf,\n        fillalpha=0.3,\n        label=[\"integrable\" \"non-integrable\"],\n        xlabel=\"s\",\n        ylabel=\"P(s)\"\n    )\n\n    # plot Wigner Dyson distribution\n    x_vals = LinRange(0, smax, 200)\n    WD_y_vals = WD_func.(x_vals)\n    plot!(x_vals, WD_y_vals, color=:red, linewidth=3, label=\"Wigner-Dyson\")\n\n    # plot Poisson distribution\n    Pois_y_vals = Poisson_func.(x_vals)\n    plot!(x_vals, Pois_y_vals, color=:black, linewidth=3, label=\"Poisson\")\nend\n\n\nfunction WD_func(s::Float64) :: Float64\n    return (pi*s/2) * exp(-pi*s^2/4)\nend\n\n\nfunction Poisson_func(s::Float64) :: Float64\n    return exp(-s)\nend\n\n\n\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_structure_factor/","title":"Dynamical structure factor","text":"<p>Uses the Lanczos algorithm[1] to calculate the dynamical spin spectral function of the spin-1/2 Heisenberg chain. The structure factor is defined as</p> <p>$$     S^{zz}({\\bf k},\\omega) = \\int dt e^{-i\\omega t}\\langle S^z_{\\bf k}(t)S^z_{\\bf -k}\\rangle, $$ where \\(S^z_{\\bf k}=\\frac{1}{\\sqrt{N}}\\sum_i e^{-i\\bf{k\\cdot r}_i}S^z_i\\) and \\(S^z_i\\) is a spin operator on site \\(i\\). The calculation is done using the Lehmann representation</p> <p>$$     S^{zz}({\\bf k},\\omega)=\\frac{1}{N}\\sum_{m=1}^M |\\langle\\Psi_0|S^z_{\\bf k}|\\psi_m\\rangle|^2\\delta(\\omega-\\epsilon_m+E_0), $$ where \\(|\\Psi_0\\rangle\\) is the ground state which needs to be computed. The algorithm proceeds in 3 steps:</p> <ol> <li> <p>Compute the ground state \\(|\\Psi_0\\rangle\\) (is the appropriate symmetry sector, e.g., usually \\({\\bf k}=0\\)).</p> </li> <li> <p>Find the operator \\(S^z_{\\bf k}\\), e.g. symmetrize with respect to the appropriate irrep, and calculate \\(|\\tilde{\\Psi}_0\\rangle=S^z_{\\bf k}|\\Psi_0\\rangle\\).</p> </li> <li> <p>Rerun the Lanczos algorigthm using the normalized state \\(|\\Psi_1\\rangle=|\\tilde{\\Psi}_0\\rangle/\\sqrt{\\langle\\tilde{\\Psi}_0|\\tilde{\\Psi}_0\\rangle}\\).</p> </li> </ol>"},{"location":"examples/spinhalf_chain_structure_factor/#main-example-code","title":"main example code","text":"JuliaC++ <pre><code>    using Pkg;\n    Pkg.instantiate();\n    using XDiag\n    using HDF5\n\n    function main()\n      say_hello()\n      filename = \"../../misc/data/examples_output/spinhalf_chain_structure_factor.h5\"\n      outfile = h5open(filename, \"w\")\n\n      # define model\n      N = 16\n      nup = div(N, 2)\n      ops = OpSum()\n      for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i + 1, N)])\n      end\n      ops[\"J\"] = 1.0\n      @show ops\n\n      # Create the permutation group\n      @show perm = Permutation([mod1(s + 1, N) for s in 1:N])\n      @show group = PermutationGroup([perm^s for s in 0:N-1])\n\n      # Create the irreps at momenta k\n      irreps = Representation[]\n      for k in 0:N-1\n        phase = exp(2im * pi * k / N)\n        characters = [phase^s for s in 0:N-1]\n        irrep = Representation(group, characters)\n        # @show irrep\n        push!(irreps, irrep)\n      end\n\n      # compute groundstate (known to be at k=0)\n      println(\"Computing ground state ...\")\n      block = Spinhalf(N, nup, irreps[1])\n      e0, gs = eig0(ops, block)\n      make_complex!(gs)\n      println(\"done.\")\n      println(\"Ground state energy: $e0\")\n      outfile[\"e0\"] = e0\n\n      # loop through momenta\n      for k in 1:N\n        println(\"coumputing structure factor at q=$k\")\n        S_q = symmetrize(Op(\"Sz\", 1), irreps[k])\n        Av = apply(S_q, gs)\n        nrm = norm(Av)\n        Av /= nrm\n\n        res = eigvals_lanczos_inplace(ops, Av)\n        outfile[\"$k/norm\"] = nrm\n        outfile[\"$k/alphas\"] = res.alphas\n        outfile[\"$k/betas\"] = res.betas\n        outfile[\"$k/eigs\"] = res.eigenvalues\n      end\n    end\n\n    main()\n</code></pre> <pre><code>    #include &lt;xdiag/all.hpp&gt;\n\n    using namespace xdiag;\n    using namespace std::complex_literals;\n    using fmt::format;\n\n    constexpr double XDIAG_PI = 3.14159265358979323846;\n\n    int main() try {\n      say_hello();\n\n      // IO\n      std::string filename = XDIAG_DIRECTORY\n          \"/misc/data/examples_output/spinhalf_chain_structure_factor.h5\";\n      auto outfile = FileH5(filename, \"w!\");\n\n      // Define the nearest-neighbor Heisenberg model\n      int N = 16;\n      int nup = N / 2;\n      OpSum ops;\n      for (int i = 0; i &lt; N; ++i) {\n        ops += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n      }\n      ops[\"J\"] = 1.0;\n\n      // Create the permutation group\n      std::vector&lt;int&gt; translation;\n      for (int s = 0; s &lt; N; ++s) {\n        translation.push_back((s + 1) % N);\n      }\n      Permutation perm(translation);\n      std::vector&lt;Permutation&gt; perms;\n      for (int s = 0; s &lt; N; ++s) {\n        perms.push_back(pow(perm, s));\n      }\n      auto group = PermutationGroup(perms);\n\n      // Create the irreps at momenta k\n      std::vector&lt;Representation&gt; irreps;\n      for (int k = 0; k &lt; N; ++k) {\n        complex phase = exp(2i * XDIAG_PI * (double)k / (double)N);\n        std::vector&lt;complex&gt; characters;\n        for (int s = 0; s &lt; N; ++s) {\n          characters.push_back(pow(phase, s));\n        }\n        auto irrep = Representation(group, characters);\n        irreps.push_back(irrep);\n      }\n\n      // compute groundstate (known to be at k=0)\n      Log(\"Computing ground state ...\");\n      auto block = Spinhalf(N, nup, irreps[0]);\n      auto [e0, gs] = eig0(ops, block);\n      gs.make_complex();\n      Log(\"done.\");\n      Log(\"Ground state energy: {:.12f}\", e0);\n      outfile[\"e0\"] = e0;\n\n      // loop through momenta\n      for (int k = 0; k &lt; N; ++k) {\n        Log(\"S^zz(k,w) at momentum {}\", k);\n        auto S_q = symmetrize(Op(\"Sz\", 0), irreps[k]);\n        auto Av = apply(S_q, gs);\n        auto nrm = norm(Av);\n        Av /= nrm;\n        XDIAG_SHOW(nrm);\n\n        auto res = eigvals_lanczos_inplace(ops, Av);\n        outfile[format(\"{}/norm\", k)] = nrm;\n        outfile[format(\"{}/alphas\", k)] = res.alphas;\n        outfile[format(\"{}/betas\", k)] = res.betas;\n        outfile[format(\"{}/eigs\", k)] = res.eigenvalues;\n      }\n\n    } catch (Error e) {\n      error_trace(e);\n    }\n</code></pre>"},{"location":"examples/spinhalf_chain_structure_factor/#visualization-script","title":"visualization script","text":"<p>Postprocessing is here split into two parts:</p> <ol> <li> <p>Compute the poles/weights of the spectral function. The \\(m\\)-th pole appears at frequency \\(\\omega = \\epsilon_m -E_0\\) with the associated weights given by the norm of \\(|\\tilde{\\Psi}_0\\rangle\\) and the projection \\(w_m=\\langle \\tilde{\\Psi}_1|\\psi_m\\rangle\\). The latter is obtained from the first eigenvector of the tridiagonal matrix.</p> </li> <li> <p>Spread out the poles and weights using a Gaussian kernel of width \\(\\eta\\) onto some frequency interval, artificially broadening the \\(\\delta\\)-functions.</p> </li> </ol> Julia <pre><code>   using XDiag\n   using LinearAlgebra\n   using HDF5\n   using Plots\n\n   function plot_sf(outfile::String, omegas::Vector{Float64}, eta::Float64 = 0.15)\n       alls = Matrix{Float64}(undef, 16, length(omegas))\n       for k in 0:15\n           p, w = poles_weights(outfile, k)\n           s = spectrum(p, w, omegas, eta)\n           alls[k+1, :] = s\n       end\n       return heatmap(collect(range(0, 15, step=1)), omegas, alls',\n           xlabel=\"\\$k\\$\", ylabel=\"\\$\\\\omega\\$\",\n           interpolation=:false)\n   end\n\n   function poles_weights(outfile::String, k::Int64)\n       e0 = h5read(outfile, \"/e0\")\n       nrm, alphas, betas, eigs = h5read.((outfile,), [\"/$k/norm\", \"/$k/alphas\", \"/$k/betas\", \"/$k/eigs\"])\n       tmat = SymTridiagonal(alphas, betas)\n       es, evecs = eigen(tmat)\n       # es == eigs\n\n       poles = es .- e0\n       weights = evecs[1, :] .^ 2 .* nrm^2\n       return poles, weights\n   end\n\n   function spectrum(poles::Vector{Float64}, weights::Vector{Float64},\n       omegas::Vector{Float64}, eta::Float64=0.1; cutoff::Float64=0.0, filter::Float64=1e-6)\n       fpoles = [poles[i] for i in 1:length(weights) if abs(weights[i]) &gt; filter]\n       fweights = [weights[i] for i in 1:length(weights) if abs(weights[i]) &gt; filter]\n       diffs = omegas .- fpoles'\n       gaussians = exp.(-(diffs ./ (2.0 * eta)) .^ 2.0) ./ (eta * sqrt(2.0 * pi))\n       if abs(cutoff) &gt; 1e-12\n           idxs = findall(abs.(fpoles) .&gt; cutoff)\n           s = zeros(length(omegas))\n           for idx in idxs\n               s += gaussians[:, idx] * fweights[idx]\n           end\n           return s\n       else\n           return gaussians * fweights\n       end\n   end\n\n   let\n       source = \"../../misc/data/examples_output/spinhalf_chain_structure_factor.h5\"\n       omegas = collect(range(0.0, 3.0, length=1000))\n       eta = 10 * (omegas[2] - omegas[1])\n       fig = plot_sf(source, omegas, eta)\n       savefig(fig, \"spekt.pdf\")\n   end\n</code></pre>"},{"location":"examples/spinhalf_chain_structure_factor/#references","title":"references","text":"<p>[1]  Prelov\u0161ek, P., &amp; Bon\u010da, J. (2013). Ground state and finite temperature Lanczos methods. Strongly Correlated Systems: Numerical Methods, 1-30.</p>"},{"location":"examples/tj_distributed_time_evolve/","title":"\\(t\\)-\\(J\\) distributed time evolution","text":""},{"location":"examples/tos_alpha_xx/","title":"Tower Of States \\(\\alpha \\text{XX}\\) model","text":"<p>We perform a tower of states (TOS) analizes [1] of the \\(\\alpha \\text{XX}\\) model [2]. This model consists of an array of \\(N\\) spin-\\(\\frac{1}{2}\\) sites with long-range \\(\\text{XY}\\)  couplings that decay as a power law with exponent \\(\\alpha\\), $$     \\mathcal{H} = -\\dfrac{J}{2} \\sum_{i,&lt;j} \\dfrac{S^+_iS^-_j+S^-_iS^+_j}{|i - j|^\\alpha}. $$</p> <p>The TOS analysis provides strong evidence for spontaneous symmetry breaking (SSB) in the thermodynamic limit, as the ground state of a finite system is completely symmetric. The spectrum of the \\(\\alpha \\text{XX}\\) model can be labeled by total magnetization since \\(\\left[\\mathcal{H}, S^z \\right]=0\\). </p> <p>To perform the TOS analysis, we gather the eigenvalues using either full exact diagonalization (ED) or the Lanczos algorithm in each symmetry sector.</p> <p></p> <p>In the figure above for \\(\\alpha=1\\), the lowest energy in each \\(S^z\\) sector clear forms a tower of states. These energies scale as \\(\\propto 1 / N\\), so in the thermodynamic limit there the collapse of the tower of states forming a highly degenerate ground state manifold [3]. As such, in the thermodynamic limit SSB occurs. In contrast, for a finite system the ground state always lies in \\(S^z=0\\), and so it is symemtric (it is also an eigenstate of the Hamiltonian's symmetry). </p> <p>SSB does not occur for all values of \\(\\alpha\\). For example, when \\(\\alpha \\rightarrow +\\infty\\), the system becomes a one-dimensional \\(\\text{XX}\\) spin chain with only short-range interactions. In this case, the ground state is always in the \\(S^z=0\\) sector.</p> C++Julia <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;xdiag/all.hpp&gt;\nusing namespace xdiag;\n\nconst unsigned Nsites = 14; // total number of sites\nconst double alpha = 1.0;   // Exponent power-law decay\n\nint main()\n{\n    auto ops = OpSum(); // create OpSum\n\n    for (int i = 0; i &lt; Nsites; i++)\n    {\n        for (int j = i + 1; j &lt; Nsites; j++)\n        {\n            double J = -1.0 / (sqrt(Nsites) * pow(abs((double)(i - j)), alpha));\n            ops += J * Op(\"Exchange\", {i, j});\n        }\n    }\n\n    // Diagonalize in each magnetization sector using FullED\n    unsigned total_eigen = pow(2, Nsites);\n    arma::mat energies = arma::mat(total_eigen, 2, arma::fill::zeros); // Collect the energies with the number of spins up.\n    arma::vec eig;\n\n    unsigned count = 0;\n    for (unsigned nup = 0; nup &lt;= Nsites; nup++)\n    {\n        auto block = Spinhalf(Nsites, nup);\n        arma::mat H = matrix(ops, block);\n        eig_sym(eig, H);\n        for (unsigned j = 0; j &lt; eig.n_elem; j++)\n        {\n            energies(count, 0) = nup;    // Magnetization sector\n            energies(count, 1) = eig(j); // Energy eigenvalue\n            count++;\n        }\n    }\n    // Construct the filename\n    std::string flstring = \"energies_tos_XXmodel.Nsites.\" + std::to_string(Nsites) + \".alpha\" + std::to_string((double)alpha) + \".outfile.h5\";\n\n    auto save_fl = FileH5(flstring, \"w!\");\n    save_fl[\"energies\"] = energies;\n    return 0;\n}\n</code></pre> <pre><code>using XDiag\nusing LinearAlgebra\nusing Printf\nusing HDF5\n\nfunction main()\n    Nsites = 24 ## Number of Sites \n    alpha = 1.0 ## Exponent power-law decay\n    ops = OpSum() ## create OpSum\n\n    for i in 1:Nsites\n        for j in (i+1):Nsites\n        J = -1.0 / (sqrt(Nsites) * (abs(i - j))^(alpha))\n        ops += J * Op(\"Exchange\", [i, j])\n        end\n    end\n\n    energies = Vector{Float64}[] ## Collect the energies\n\n    Diagonalize in each magnetization sector using FullED\n    for nup in 0:Nsites\n        block = Spinhalf(Nsites, nup)\n        H = matrix(ops, block)\n        eig = eigvals(Hermitian(H))\n        for e0 in eig\n            push!(energies, [nup, e0])\n        end\n    end\n\n    #Diagonalize in each magnetization sector using Lanczos to get the first few eigenvalues\n    # for nup in 0:Nsites\n    #     block = Spinhalf(Nsites, nup)\n    #     r = eigvals_lanczos(ops, block, neigvals = 1);\n    #     for e0 in r.eigenvalues\n    #         push!(energies, [nup, e0])\n    #     end\n    # end\n\n    filename = @sprintf(\"energies_tos_XXmodel.Nsites.%d.alpha.%d.outfile.h5\", Nsites, alpha)\n    h5open(filename, \"w\") do file\n        write(file, \"energies\", hcat(energies...))\n    end\nend\n\nmain()\n</code></pre>"},{"location":"examples/tos_alpha_xx/#references","title":"references","text":"<p>[1] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p> <p>[2] Tommaso Comparin, Fabio Mezzacapo and Tommaso Roscilde, Robust spin squeezing from the tower of states of U(1)-symmetric spin Hamiltonians, Phys. Rev. A 105, 02262 (2022)</p> <p>[3] Alexander Wietek, Michael Schuler and Andreas M. L\u00e4uchli, Studying Continuous Symmetry Breaking using Energy Level Spectroscopy, arXiv:1704.08622 (2017).</p>"},{"location":"examples/tpq_shastry_sutherland/","title":"Shastry Sutherland Specific Heat with TPQ","text":"<p>We use an ensemble of Thermal Pure Quantum (TPQ) states [1] to compute the total energy and specific heat as functions of temperature for the Shastry\u2013Sutherland model.</p> <p>The Shastry\u2013Sutherland model is a paradigmatic example of a frustrated two-dimensional antiferromagnetic spin system. It is widely used as a faithful representation of materials such as the frustrated quantum magnet \\(\\text{SrCu}_2(\\text{BO}_3)_2\\). On a square lattice, the model describes spin \\(-\\frac{1}{2}\\) magnetic moments interacting via Heisenberg antiferromagnetic couplings, as shown in following figure. </p> <p></p> <p>The Hamiltonian is given by</p> \\[ \\mathcal{H} = J \\sum_{\\langle i,j \\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j + J_D \\sum_{\\langle\\langle i,j \\rangle\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>The expectation value of an observable \\(\\mathcal{O}\\) in the canonical ensemble is</p> \\[ \\langle \\mathcal{O} \\rangle = \\frac{\\text{Tr}\\left(e^{-\\beta \\mathcal{H}} \\mathcal{O}\\right)}{\\mathcal{Z}}, \\] <p>where \\(\\beta\\) is the inverse temperature and \\(\\mathcal{Z} = \\text{Tr}\\left(e^{-\\beta \\mathcal{H}}\\right)\\). We approximate the trace stochastically using a set of random vectors \\(\\{r_\\alpha\\}\\), leading to</p> <p>$$ \\langle \\mathcal{O} \\rangle \\approx \\sum_{\\alpha} \\frac{\\langle \\beta_\\alpha | \\mathcal{O} | \\beta_\\alpha \\rangle}{\\langle \\beta_\\alpha | \\beta_\\alpha \\rangle}, \\quad \\text{with } |\\beta_\\alpha\\rangle = e^{-\\beta \\mathcal{H}}|r_\\alpha\\rangle, $$ where $ |\\beta_\\alpha\\rangle$ is a TPQ state.</p> <p>We efficiently compute the TPQ state using the Lanczos basis [2], \\(V\\), constructed from \\(|r_\\alpha\\rangle\\). In this basis, the observable is approximated as</p> \\[ \\langle \\beta_\\alpha | \\mathcal{O} | \\beta_\\alpha \\rangle \\approx e_1^T\\, V\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, \\mathcal{O}\\, V\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, e_1, \\] <p>where \\(e_1^T = (1, 0, \\dots, 0)\\) and \\(T = V^\\dagger \\mathcal{H} V\\) is a tridiagonal matrix.</p> <p>Thus, for each random state, the algorithm performs the following steps:</p> <ol> <li> <p>Generate the Lanczos Basis: Obtain the elements of the tridiagonal matrix \\(T\\) from the state \\(|r_\\alpha\\rangle\\).</p> </li> <li> <p>Compute Observables: To obtain the specific heat,  $$    C = \\beta^2\\left[\\langle \\mathcal{H}^2 \\rangle - \\langle \\mathcal{H} \\rangle^2\\right], $$ we need to evaluate</p> </li> </ol> \\[    \\langle \\beta_\\alpha | \\mathcal{H} | \\beta_\\alpha \\rangle \\approx e_1^T\\, V\\, e^{-\\beta/2\\, T}\\, T\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, e_1, \\\\[2exm]     \\langle \\beta_\\alpha | \\mathcal{H}^2 | \\beta_\\alpha \\rangle \\approx e_1^T\\, V\\, e^{-\\beta/2\\, T}\\, T^2\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, e_1. \\] <p>This part could be done in the post-processing. The result is shown in the following figure,  The error bar was done using a Jackknife analysis.</p> C++Julia <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;xdiag/all.hpp&gt;\n\nconst unsigned Nsites = 20; // Total number of sites in the Shastry-Sutherland model:\nconst unsigned Rtqp = 5;    // Number of random vectors to be used in the algorithm\n\nauto fl = xdiag::FileToml(\"shastry_sutherland_L_5_W_4.toml\"); // TOML file with the list of interactions\nusing namespace xdiag;\n\nvoid Tqp_mag_sector(arma::mat &amp;Obser, arma::vec &amp;DBetas, xdiag::OpSum &amp;H);\n\nint main()\ntry\n{\n    // Read OpSum from file\n    xdiag::OpSum ops = read_opsum(fl, \"Interactions\");\n\n    // Defines exchange coupling strenght -- This ratio of couplings corresponds to the dimmer phase.\n    ops[\"Jd\"] = 1.0;\n    ops[\"J\"] = 0.630;\n\n    // Linear Array with target temperatures\n    arma::vec Temp = arma::linspace&lt;arma::vec&gt;(0.01, 0.35, 64);\n\n    // Array to store the specific heat\n    arma::mat Obser = arma::mat(Temp.n_elem, 3, arma::fill::zeros);\n\n    Tqp_mag_sector(Obser, Temp, ops);\n\n    auto save_fl = FileH5(\"shastry_sutherland_L_5_W_4.h5\", \"w!\");\n    save_fl[\"Temp\"] = Temp;\n    save_fl[\"Observable\"] = Obser;\n\n    return 0;\n}\ncatch (Error e)\n{\n    error_trace(e);\n}\n\nvoid Tqp_mag_sector(arma::mat &amp;Obser, arma::vec &amp;Temp, xdiag::OpSum &amp;H)\n{\n    auto block = Spinhalf(Nsites); // Create spin-1/2 block with conservation of Sz\n\n    arma::vec eigs;\n    arma::mat vecs;\n    for (unsigned k = 0; k &lt; Rtqp; k++) // #Perform the calculation for each random vector\n    {\n        auto res = eigvals_lanczos(H, block, 1, 1e-12, 150,1e-7,k); // Perform the Lanczos interation starting from a random vector;\n\n        //This part can be done in the post-processing        \n        arma::mat tmatrix = arma::diagmat(res.alphas);\n        tmatrix += arma::diagmat(res.betas.head(res.betas.size() - 1), 1) + arma::diagmat(res.betas.head(res.betas.size() - 1), -1);\n\n        arma::eig_sym(eigs, vecs, tmatrix); // get eigenvector of T\n\n        for (unsigned k = 0; k &lt; Temp.n_elem; k++)\n        {\n            arma::vec psi1 =(arma::exp(-(eigs-eigs(0)) / (2.0*Temp(k))) % arma::conj((vecs.row(0).t()))); // compute psi_1\n\n            Obser(k, 0) += arma::dot(psi1, psi1); // get norm factor for the partition function\n\n            Obser(k, 1) += arma::dot(psi1, eigs % psi1); // measure energy\n\n            Obser(k, 2) += arma::dot(psi1,eigs % eigs% psi1); // measure energy square\n        }\n    }\n}\n</code></pre> <pre><code>using LinearAlgebra, LinearAlgebra.LAPACK\nusing XDiag\nusing HDF5\nusing Printf\nconst Nsites = 20 # Total number of sites in the Shastry-Sutherland model:\nconst Rtqp = 2 # Number of random vectors to be used in the algorithm\n\nfunction Tqp_mag_sector(Obser::Matrix{Float64}, Temp::LinRange{Float64,Int64}, H::OpSum)\n\n    block = Spinhalf(Nsites) #Create spin-1/2 block with conservation of Sz\n\n    for k in 1:Rtqp #Perform the calculation for each random vector\n        res = eigvals_lanczos(H, block, neigvals=1, precision=1e-12, max_iterations=150, deflation_tol=1e-7, random_seed=k) # Perform the Lanczos interation starting from a random vector;\n\n        d = length(res.alphas)\n        vecs = Matrix{Float64}(I, d, d)\n        #This part can be done in the post-processing\n        (eigs, vecs) = LAPACK.stev!('V', res.alphas, res.betas)\n\n        for k in 1:length(Temp)\n            psi1 = exp.(-(eigs .- eigs[1]) ./ (2.0 .* Temp[k])) .* conj(vecs[1, :]) # compute psi_1\n\n            Obser[k, 1] += dot(psi1, psi1)# get norm factor for the partition function\n\n            Obser[k, 2] += dot(psi1, eigs .* psi1) # measure energy\n\n            Obser[k, 3] += dot(psi1, eigs .* (eigs .* psi1))# measure energy square\n        end\n    end\nend\n\nfunction main()\n\n\n    #Reads the file with the interactions\n    fl = FileToml(\"shastry_sutherland_L_5_W_4.toml\")\n    ops = read_opsum(fl, \"Interactions\")\n    #Defines exchange coupling strenght -- This ratio of couplings corresponds to the dimmer phase.\n    ops[\"Jd\"] = 1.0\n    ops[\"J\"] = 0.630\n\n    # Linear Array with target temperatures\n    Temp = LinRange(0.01, 0.35, 64)\n\n    # Array to store the average value of the observable \n    Obser = zeros(Float64, (length(Temp), 3))\n\n    Tqp_mag_sector(Obser, Temp, ops)\n\n    filename = @sprintf(\"shastry_sutherland_L_5_W_4.h5\")\n    h5open(filename, \"w\") do file\n        write(file, \"Temp\", collect(Temp))\n        write(file, \"Observable\", Obser)\n    end\nend\n\nmain()\n</code></pre> <p>The interactions terms for the Shastry Sutherland model with \\(L=5\\) and \\(W=4\\) sites is given in the following TOML file:</p> toml <pre><code># Interaction Shastry Sutherland with L=5 and W=4\nInteractions = [[\"J\", \"SdotS\", 0, 4], \n[\"J\", \"SdotS\", 0, 16], \n[\"J\", \"SdotS\", 0, 1], \n[\"J\", \"SdotS\", 0, 3], \n[\"J\", \"SdotS\", 1, 5], \n[\"J\", \"SdotS\", 1, 17], \n[\"J\", \"SdotS\", 1, 2], \n[\"J\", \"SdotS\", 2, 6], \n[\"J\", \"SdotS\", 2, 18], \n[\"J\", \"SdotS\", 2, 3], \n[\"J\", \"SdotS\", 3, 7], \n[\"J\", \"SdotS\", 3, 19], \n[\"J\", \"SdotS\", 4, 8], \n[\"J\", \"SdotS\", 4, 5], \n[\"J\", \"SdotS\", 4, 7], \n[\"J\", \"SdotS\", 5, 9], \n[\"J\", \"SdotS\", 5, 6], \n[\"J\", \"SdotS\", 6, 10],\n[\"J\", \"SdotS\", 6, 7], \n[\"J\", \"SdotS\", 7, 11], \n[\"J\", \"SdotS\", 8, 12], \n[\"J\", \"SdotS\", 8, 9], \n[\"J\", \"SdotS\", 8, 11], \n[\"J\", \"SdotS\", 9, 13], \n[\"J\", \"SdotS\", 9, 10], \n[\"J\", \"SdotS\", 10, 14],\n[\"J\", \"SdotS\", 10, 11], \n[\"J\", \"SdotS\", 11, 15], \n[\"J\", \"SdotS\", 12, 16], \n[\"J\", \"SdotS\", 12, 13], \n[\"J\", \"SdotS\", 12, 15], \n[\"J\", \"SdotS\", 13, 17], \n[\"J\", \"SdotS\", 13, 14], \n[\"J\", \"SdotS\", 14, 18], \n[\"J\", \"SdotS\", 14, 15], \n[\"J\", \"SdotS\", 15, 19], \n[\"J\", \"SdotS\", 16, 17], \n[\"J\", \"SdotS\", 16, 19], \n[\"J\", \"SdotS\", 17, 18], \n[\"J\", \"SdotS\", 18, 19], \n[\"Jd\", \"SdotS\", 0, 5], \n[\"Jd\", \"SdotS\", 6, 9], \n[\"Jd\", \"SdotS\", 2, 7], \n[\"Jd\", \"SdotS\", 4, 11], \n[\"Jd\", \"SdotS\", 8, 13], \n[\"Jd\", \"SdotS\", 14, 17], \n[\"Jd\", \"SdotS\", 10, 15], \n[\"Jd\", \"SdotS\", 12, 19], \n[\"Jd\", \"SdotS\", 1, 16], \n[\"Jd\", \"SdotS\", 3, 18]]\nN = [20]\n</code></pre>"},{"location":"examples/tpq_shastry_sutherland/#references","title":"references","text":"<p>[1] S. Sugiura and A. Shimizu, Thermal Pure Quantum States at Finite Temperature, Phys. Rev. Lett. 108, 240401 (2012).</p> <p>[2] Wietek, Alexander, Corboz, Philippe, Wessel, Stefan, Normand, B., Mila, Fr\\'ed\\'eric and Honecker, Andreas Thermodynamic properties of the Shastry-Sutherland model throughout the dimer-product phase, PhysRevResearch.103, 3038 (2019).</p>"}]}