{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Quick Start Code on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>XDiag is a C++ library for performing Exact Diagonalizations of quantum many-body systems. Key features include optimized combinatorical algorithms for navigating Hilbert spaces, iterative linear algebra algorithms,  shared and distributed memory parallelization.</p>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-examples","title":"Basic examples","text":"<ul> <li> <p> Hello World</p> <p>Prints out a greeting containing information on the version of the code.</p> <p>source </p> </li> <li> <p> Groundstate energy</p> <p>Computes the ground state energy of a simple Heisenberg spin \\(S=1/2\\) chain</p> <p>source </p> </li> </ul>"},{"location":"examples/#distributed-examples","title":"Distributed examples","text":"<ul> <li> <p> \\(t\\)-\\(J\\) time evolution</p> <p>Computes the time evolution of a state in the \\(t\\)-\\(J\\) model with distributed parallelization</p> <p>source </p> </li> </ul>"},{"location":"examples/#cmakeliststxt-for-applications","title":"CMakeLists.txt for applications","text":"<ul> <li> <p> Normal XDiag</p> <p>Template <code>CMakeLists.txt</code> which can be used to compile applications with the normal XDiag library.</p> <p>source </p> </li> <li> <p> Distributed XDiag</p> <p>Template <code>CMakeLists.txt</code> which can be used to compile applications with the distributed XDiag library.</p> <p>source </p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#julia-installation","title":"Julia Installation","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and add the following two packages <pre><code>add https://github.com/awietek/XDiag_jll.jl.git\nadd https://github.com/awietek/XDiag.jl.git\n</code></pre></p>"},{"location":"installation/#c-compilation","title":"C++ Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. Here we explain how to compile the library.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul>"},{"location":"installation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building the Julia wrapper locally</p> <p>First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> </li> </ul>"},{"location":"installation/#building-documentation","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To work on it locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"quickstart/","title":"Quick start","text":""},{"location":"quickstart/#hello-world","title":"Hello World","text":"<p>Let us set up our first program using the <code>xdiag</code> library. </p> JuliaC++ <pre><code>using XDiag\nsay_hello()\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information which exact XDiag version is used. In Julia this is all there is to it.</p> <p>For the C++ code we need to create two files to compile the program. The first is the actual <code>C++</code> code. What is maybe a bit unfamiliar is the <code>try / catch</code> block. XDiag implements a traceback mechanism for runtime errors, which is activated by this idiom. While not stricly necessary here, it is a good practice to make use of this.</p> <p>Now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"../../install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our first <code>xdiag</code> application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"quickstart/#computing-the-ground-state-energy-of-a-spin-chain","title":"Computing the ground state energy of a spin chain","text":"<p>We compute the ground state energy of the \\(S=1/2\\) Heisenberg chain on a periodic chain lattice in one dimension. The Hamiltonian is given by</p> \\[ H = J\\sum_{\\langle i,j \\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j\\] <p>where \\(\\mathbf{S}_i = (S_i^x, S_i^y, S_i^z)\\) are the spin \\(S=1/2\\) operators and \\(\\langle i,j \\rangle\\) denotes summation over nearest-meighbor sites \\(i\\) and \\(j\\).</p> <p>The following code, sets up the Hilbert space, defines the Hamiltonian and finally calls an iterative eigenvalue solver to compute the ground state energy.</p> JuliaC++ <pre><code>using XDiag\n\nlet \n    N = 16;\n    nup = N \u00f7 2;\n    block = Spinhalf(N, nup);\n\n    # Define the nearest-neighbor Heisenberg model\n    bonds = BondList()\n    for i in 1:N\n        bonds += Bond(\"HB\", \"J\", [i-1, i % N])\n    end\n    bonds[\"J\"] = 1.0;\n\n    set_verbosity(2);             # set verbosity for monitoring progress\n    e0 = eigval0(bonds, block);   # compute ground state energy\n\n    println(\"Ground state energy: $e0\");\nend\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += Op(\"HB\", \"J\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre>"},{"location":"documentation/","title":"Documentation","text":""},{"location":"documentation/#algorithms","title":"Algorithms","text":"Name Description Language eigval0 Computes the lowest lying eigenvalue of an operator eig0 Computes the lowest lying eigenvalue and eigenvector of an operator"},{"location":"documentation/#algebra","title":"Algebra","text":"matrix Creates the full matrix representation of an operator on a block apply Applies an operator to a state \\(\\vert w \\rangle = O \\vert v\\rangle\\) norm Computes the 2-norm of a state norm1 Computes the 1-norm of a state norminf Computes the \\(\\infty\\)-norm of a state dot Computes the dot product between two states inner Computes an expectation value \\(\\langle v \\vert O \\vert v \\rangle\\)"},{"location":"documentation/#blocks","title":"Blocks","text":"Spinhalf Block of a spin \\(S=1/2\\) type Hilbert space tJ Block of a \\(t-J\\) type Hilbert space Electron Block of a Electron type Hilbert space"},{"location":"documentation/#operators","title":"Operators","text":"Op A local operator acting on several lattice sites OpSum Sum of local operators Coupling Describes the coupling of a local operator symmetrize Symmetrizes an operator with respect to a permutation symmetry group"},{"location":"documentation/#states","title":"States","text":"State A generic state describing a quantum wave function ProductState A product state of local configurations RandomState A random state with normal distributed coefficients fill Fill a state with a given model state product Creates a filled product state rand Create a filled random state with normal distributed coefficients zeros Create a filled state with all zero entries zero Set all coefficients of a given state to zero"},{"location":"documentation/#symmetries","title":"Symmetries","text":"Permutation Permutations of indices or lattice sites PermutationGroup A group of permutations Representation A (1D) irreducible representation of a finite group"},{"location":"documentation/#utilities","title":"Utilities","text":"Logging Controling what is written to standard output Timing Measurng wall time straightforwardly XDIAG_SHOW Macro for printing debugging information"},{"location":"documentation/algebra/algebra/","title":"Basic algebra routines","text":"<p>Source algebra.hpp</p>"},{"location":"documentation/algebra/algebra/#norm","title":"norm","text":"<p>Computes the 2-norm of a state</p> JuliaC++ <pre><code>norm(state::State)\n</code></pre> <pre><code>double norm(State const &amp;v);\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm1","title":"norm1","text":"<p>Computes the 1-norm of a state</p> JuliaC++ <pre><code>norm1(state::State)\n</code></pre> <pre><code>double norm1(State const &amp;v);\n</code></pre>"},{"location":"documentation/algebra/algebra/#norminf","title":"norminf","text":"<p>Computes the \\(\\infty\\)-norm of a state</p> JuliaC++ <pre><code>norminf(state::State)\n</code></pre> <pre><code>double norminf(State const &amp;v);\n</code></pre>"},{"location":"documentation/algebra/algebra/#dot","title":"dot","text":"<p>Computes the dot product between two states. In C++, please use the dotC function if one of the two states is expected to be complex.</p> JuliaC++ <pre><code>dot(v::State, w::State)\n</code></pre> <pre><code>double dot(State const &amp;v, State const &amp;w);\ncomplex dotC(State const &amp;v, State const &amp;w);\n</code></pre>"},{"location":"documentation/algebra/algebra/#inner","title":"inner","text":"<p>Computes the expectation value \\(\\langle v | O |v \\rangle\\) of an operator \\(O\\) and a state \\(|v\\rangle\\). The operator can either be an Op or an OpSum object. In C++, please use the innerC function if either the operator or the state are complex.</p> JuliaC++ <pre><code>inner(ops::OpSum, v::State)\ninner(op::Op, v::State)\n</code></pre> <pre><code>double inner(OpSum const &amp;ops, State const &amp;v);\ndouble inner(Op const &amp;op, State const &amp;v);\ncomplex innerC(OpSum const &amp;ops, State const &amp;v);\ncomplex innerC(Op const &amp;op, State const &amp;v);\n</code></pre>"},{"location":"documentation/algebra/algebra/#usage-examples","title":"Usage Examples","text":"JuliaC++ <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", 1.0, [i-1, i % N])\n    end\n    e0, psi = eig0(ops, block);\n\n    @show norm(psi)\n    @show norm1(psi)\n    @show norminf(psi)\n\n    @show dot(psi, psi)\n    @show e0, inner(ops, psi)\n\n    phi = rand(block)\n    display(vector(phi))\n    display(vector(psi))\n    display(vector(psi + 2.0*phi))\n    display(vector(psi*3.0im + phi/2.0))\nend\n</code></pre> <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"HB\", 1.0, {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\n\nXDIAG_SHOW(norm(psi));\nXDIAG_SHOW(norm1(psi));\nXDIAG_SHOW(norminf(psi));\n\nXDIAG_SHOW(dot(psi, psi));\nXDIAG_SHOW(e0);\nXDIAG_SHOW(inner(ops, psi));\n\nauto phi = rand(block);\nXDIAG_SHOW(phi.vector());\nXDIAG_SHOW(psi.vector());\nXDIAG_SHOW((psi + 2.0*phi).vector());\nXDIAG_SHOW((psi*complex(0,3.0) + phi/2.0).vectorC());\n</code></pre>"},{"location":"documentation/algebra/apply/","title":"apply","text":"<p>Applies an operator to a state \\(\\vert w \\rangle = O \\vert v\\rangle\\).</p> <p>Source apply.hpp</p> JuliaC++ <pre><code>apply(op::Op, v::State, w::State, precision::Float64 = 1e-12)\napply(ops::OpSum, v::State, w::State, precision::Float64 = 1e-12)\n</code></pre> <pre><code>void apply(Op const &amp;op, State const &amp;v, State &amp;w, double precision = 1e-12);\nvoid apply(OpSum const &amp;ops, State const &amp;v, State &amp;w, double precision = 1e-12);\n</code></pre> <p>The resulting state is handed as the third argument and is overwritten upon exit. </p>"},{"location":"documentation/algebra/apply/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator v input state $\\vert v\\rangle  $ w output state \\(\\vert w \\rangle = O \\vert v\\rangle\\) precision precision with which checks for zero are performed (default \\(10^{-12}\\))"},{"location":"documentation/algebra/apply/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", 1.0, [i-1, i % N])\n    end\n    e0, psi = eig0(ops, block);\n\n    blockp = Spinhalf(N,  N \u00f7 2 + 1)\n    phi = zeros(blockp)\n    apply(Op(\"S+\", 1.0, 2), psi, phi)\n    @show inner(ops, psi)\n    @show inner(ops, phi)\nend\n</code></pre> <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  ops += Op(\"HB\", 1.0, {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\n\nauto blockp = Spinhalf(N,  N / 2 + 1);\nauto phi = zeros(blockp);\napply(Op(\"S+\", 1.0, 2), psi, phi);\nXDIAG_SHOW(inner(ops, psi));\nXDIAG_SHOW(inner(ops, phi));\n</code></pre>"},{"location":"documentation/algebra/matrix/","title":"matrix","text":"<pre><code>matrix(ops, block; force_complex=false)\nmatrixC(ops, block)  # c++ only\n</code></pre> <p>Creates the full matrix representation of a given OpSum on a block.</p> <p>In Julia, depending on whether a real/complex matrix is generated also a  real/complex matrix is returned. The C++ version has to return a fixed type. If a real matrix is desired, use the function <code>matrix</code>. If a complex matrix is desired, use the function <code>matrixC</code>.</p> <p>Source matrix.hpp</p>"},{"location":"documentation/algebra/matrix/#parameters","title":"Parameters","text":"Name Description ops OpSum defining the operator block block on which the operator is defined force_complex flag to determine if returned matrix is forced to be complex (Julia only)"},{"location":"documentation/algebra/matrix/#returns","title":"Returns","text":"Type Description matrix matrix representation of opsum on block"},{"location":"documentation/algebra/matrix/#definition","title":"Definition","text":"JuliaC++ <pre><code>matrix(ops::Opsum, block::Block; force_complex::Bool=false)\n</code></pre> <pre><code>template &lt;typename block_t&gt;\narma::mat matrix(OpSum const &amp;ops, block_t const &amp;block);\n\ntemplate &lt;typename block_t&gt;\narma::cx_mat matrixC(OpSum const &amp;ops, block_t const &amp;block);\n</code></pre>"},{"location":"documentation/algebra/matrix/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>let\n    # Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\n    N = 4\n    nup = 3\n    ndn = 2\n\n    # Define a Hubbard chain model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HOP\", \"T\", [i-1, i % N])\n    end\n    ops[\"T\"] = 1.0;\n    ops[\"U\"] = 5.0;\n\n    # Create the a permutation group\n    p1 = Permutation([0, 1, 2, 3])\n    p2 = Permutation([1, 2, 3, 0])\n    p3 = Permutation([2, 3, 0, 1])\n    p4 = Permutation([3, 0, 1, 2])\n    group = PermutationGroup([p1, p2, p3, p4])\n    irrep = Representation([1, -1, 1, -1])\n    block = Electron(N, nup, ndn, group, irrep)\n\n    H = matrix(ops, block)\n    display(H)\nend\n</code></pre> <pre><code>// Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\nint N = 4;\nint nup = 3;\nint ndn = 2;\n\n// Define a Hubbard chain model\nauto ops = OpSum();\nfor (int i=0; i&lt; N; ++i){\n  ops += Op(\"HOP\", \"T\", {i, (i+1) % N});\n}\nops[\"T\"] = 1.0;\nops[\"U\"] = 5.0;\n\n// Create the a permutation group\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block = Electron(N, nup, ndn, group, irrep);\n\nauto H = matrix(ops, block);\nH.print();\n</code></pre>"},{"location":"documentation/algorithms/eig0/","title":"eig0","text":"<pre><code>eig0(bondlist, block; precision, max_iterations, force_complex, random_seed)\n</code></pre> <p>Computes the groud state energy and the ground state of an operator on a block.</p> <p>Source sparse_diag.hpp</p>"},{"location":"documentation/algorithms/eig0/#parameters","title":"Parameters","text":"Name Description Default bondlist BondList defining the bonds of the operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 force_complex whether or not computation should be forced to have complex arithmetic false random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eig0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue State groundstate"},{"location":"documentation/algorithms/eig0/#definition","title":"Definition","text":"JuliaC++ <pre><code>eig0(bonds::BondList, block::Spinhalf;\n     precision::Real=1e-12, maxiter::Integer=1000,\n     force_complex::Bool=false, seed::Integer=42)\n</code></pre> <pre><code>std::tuple&lt;double, State&gt;\neig0(BondList const &amp;bondlist, block_variant_t const &amp;block,\n     double precision = 1e-12, int64_t max_iterations = 1000,\n     bool force_complex = false, int64_t random_seed = 42);\n</code></pre>"},{"location":"documentation/algorithms/eig0/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", \"J\", [i-1, i % N])\n    end\n    ops[\"J\"] = 1.0;\n\n    e0, gs = eig0(ops, block);\nend\n</code></pre> <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"HB\", \"J\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\nauto [e0, gs] = eig0(ops, block);\n</code></pre>"},{"location":"documentation/algorithms/eigval0/","title":"eigval0","text":"<pre><code>eigval0(bondlist, block; precision, max_iterations, force_complex, random_seed)\n</code></pre> <p>Computes the groud state energy of an operator on a block.</p> <p>Source sparse_diag.hpp</p>"},{"location":"documentation/algorithms/eigval0/#parameters","title":"Parameters","text":"Name Description Default bondlist BondList defining the bonds of the operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 force_complex whether or not computation should be forced to have complex arithmetic false random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigval0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue"},{"location":"documentation/algorithms/eigval0/#definition","title":"Definition","text":"JuliaC++ <pre><code>eig0(bonds::BondList, block::Union{Spinhalf,Electron,tJ};\n     precision::Real=1e-12, maxiter::Integer=1000,\n     force_complex::Bool=false, seed::Integer=42)\n</code></pre> <pre><code>double eigval0(BondList const &amp;bondlist, block_variant_t const &amp;block,\n               double precision = 1e-12, int64_t max_iterations = 1000,\n               bool force_complex = false, int64_t random_seed = 42);\n</code></pre>"},{"location":"documentation/algorithms/eigval0/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", \"J\", [i-1, i % N])\n    end\n    ops[\"J\"] = 1.0\n\n    e0 = eigval0(ops, block);\nend\n</code></pre> <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"HB\", \"J\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\ndouble e0 = eigval0(ops, block);\n</code></pre>"},{"location":"documentation/blocks/electron/","title":"Electron","text":"<p>Representation of a block in a Electron (spinful fermion) Hilbert space. </p> <p>Source electron.hpp</p>"},{"location":"documentation/blocks/electron/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>Electron(n_sites::Integer)\nElectron(n_sites::Integer, n_up::Integer, n_dn::Integer)\nElectron(n_sites::Integer, group::PermutationGroup, irrep::Representation)\nElectron(n_sites::Integer, n_up::Integer, n_dn::Integer, \n         group::PermutationGroup, irrep::Representation)\n</code></pre> <pre><code>Electron(int64_t n_sites);\nElectron(int64_t n_sites, int64_t n_up, int64_t n_dn);\nElectron(int64_t n_sites, PermutationGroup permutation_group,\n         Representation irrep);\nElectron(int64_t n_sites, int64_t n_up, int64_t n_dn, \n         PermutationGroup group, Representation irrep);\n</code></pre> Name Description n_sites number of sites (integer) n_up number of \"up\" electrons (integer) n_dn number of \"dn\" electrons (integer) group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group"},{"location":"documentation/blocks/electron/#iteration","title":"Iteration","text":"<p>An Electron block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> JuliaC++ <pre><code>block = Electron(4, 2, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre> <pre><code>auto block = Electron(4, 2, 2);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/electron/#methods","title":"Methods","text":"<p>index</p> <p>Returns the index of a given ProductState in the basis of the Electron block.</p> JuliaC++ <pre><code>index(block::Electron, pstate::ProductState)\n</code></pre> <pre><code>int64_t index(ProductState const &amp;pstate) const;\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p> <p>n_sites</p> <p>Returns the number of sites of the block.</p> JuliaC++ <pre><code>n_sites(block::Electron)\n</code></pre> <pre><code>int64_t n_sites() const;\n</code></pre> <p>n_up</p> <p>Returns the number of \"up\" electrons.</p> JuliaC++ <pre><code>n_up(block::Electron)\n</code></pre> <pre><code>int64_t n_up() const;\n</code></pre> <p>n_dn</p> <p>Returns the number of \"down\" electrons.</p> JuliaC++ <pre><code>n_dn(block::Electron)\n</code></pre> <pre><code>int64_t n_dn() const;\n</code></pre> <p>permutation_group</p> <p>Returns the PermutationGroup of the block, if defined.</p> JuliaC++ <pre><code>permutation_group(block::Electron)\n</code></pre> <pre><code>PermutationGroup permutation_group() const;\n</code></pre> <p>irrep</p> <p>Returns the Representation of the block, if defined.</p> JuliaC++ <pre><code>irrep(block::Electron)\n</code></pre> <pre><code>Representation irrep() const;\n</code></pre> <p>size</p> <p>Returns the size of the block, i.e. its dimension.</p> JuliaC++ <pre><code>size(block::Electron)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>dim</p> <p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> JuliaC++ <pre><code>dim(block::Electron)\n</code></pre> <pre><code>int64_tdim() const;\n</code></pre> <p>isreal</p> <p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> JuliaC++ <pre><code>isreal(block::Electron; precision::Real=1e-12)\n</code></pre> <pre><code>int64_t isreal(double precision = 1e-12) const;\n</code></pre>"},{"location":"documentation/blocks/electron/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without number conservation\nblock = Electron(N)\n@show block\n\n# with number conservation\nblock_np = Electron(N, nup, ndn)\n@show block_np\n\n# with symmetries, without number conservation\np1 = Permutation([0, 1, 2, 3])\np2 = Permutation([1, 2, 3, 0])\np3 = Permutation([2, 3, 0, 1])\np4 = Permutation([3, 0, 1, 2])\ngroup = PermutationGroup([p1, p2, p3, p4])\nrep = Representation([1, -1, 1, -1])\nblock_sym = Electron(N, group, rep)\n@show block_sym\n\n# with symmetries and number conservation\nblock_sym_np = Electron(N, nup, ndn, group, rep)\n@show block_sym_np\n\n@show n_sites(block_sym_np)\n@show size(block_sym_np)\n\n# Iteration\nfor pstate in block_sym_np\n    @show pstate, index(block_sym_np, pstate)\nend\n@show permutation_group(block_sym_np)\n@show irrep(block_sym_np)\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without number conservation\nauto block = Electron(N);\nXDIAG_SHOW(block);\n\n// with number conservation\nauto block_np = Electron(N, nup, ndn);\nXDIAG_SHOW(block_np);\n\n// with symmetries, without number conservation\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block_sym = Electron(N, group, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and number conservation\nauto block_sym_np = Electron(N, nup, ndn, group, irrep);\nXDIAG_SHOW(block_sym_np);\n\nXDIAG_SHOW(block_sym_np.n_sites());\nXDIAG_SHOW(block_sym_np.size());\n\n// Iteration\nfor (auto pstate : block_sym_np) {\n  Log(\"{} {}\", to_string(pstate), block_sym_np.index(pstate));\n}\nXDIAG_SHOW(block_sym_np.permutation_group());\nXDIAG_SHOW(block_sym_np.irrep());\n</code></pre>"},{"location":"documentation/blocks/spinhalf/","title":"Spinhalf","text":"<p>Representation of a block in a spin \\(S=1/2\\)  Hilbert space. </p> <p>Source spinhalf.hpp</p>"},{"location":"documentation/blocks/spinhalf/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>Spinhalf(n_sites::Integer)\nSpinhalf(n_sites::Integer, n_up::Integer)\nSpinhalf(n_sites::Integer, group::PermutationGroup, irrep::Representation)\nSpinhalf(n_sites::Integer, n_up::Integer, group::PermutationGroup, \n         irrep::Representation)\n</code></pre> <pre><code>Spinhalf(int64_t n_sites);\nSpinhalf(int64_t n_sites, int64_t n_up);\nSpinhalf(int64_t n_sites, PermutationGroup permutation_group,\n         Representation irrep);\nSpinhalf(int64_t n_sites, int64_t n_up, PermutationGroup group,\n         Representation irrep);\n</code></pre> Name Description n_sites number of sites (integer) n_up number of \"up\" spin setting spin (integer) group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group"},{"location":"documentation/blocks/spinhalf/#iteration","title":"Iteration","text":"<p>An Spinhalf block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> JuliaC++ <pre><code>block = Spinhalf(4, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre> <pre><code>auto block = Spinhalf(4, 2);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#methods","title":"Methods","text":"<p>index</p> <p>Returns the index of a given ProductState in the basis of the Spinhalf block.</p> JuliaC++ <pre><code>index(block::Spinhalf, pstate::ProductState)\n</code></pre> <pre><code>int64_t index(ProductState const &amp;pstate) const;\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p> <p>n_sites</p> <p>Returns the number of sites of the block.</p> JuliaC++ <pre><code>n_sites(block::Spinhalf)\n</code></pre> <pre><code>int64_t n_sites() const;\n</code></pre> <p>n_up</p> <p>Returns the number of \"up\" spins.</p> JuliaC++ <pre><code>n_up(block::Spinhalf)\n</code></pre> <pre><code>int64_t n_up() const;\n</code></pre> <p>permutation_group</p> <p>Returns the PermutationGroup of the block, if defined.</p> JuliaC++ <pre><code>permutation_group(block::Spinhalf)\n</code></pre> <pre><code>PermutationGroup permutation_group() const;\n</code></pre> <p>irrep</p> <p>Returns the Representation of the block, if defined.</p> JuliaC++ <pre><code>irrep(block::Spinhalf)\n</code></pre> <pre><code>Representation irrep() const;\n</code></pre> <p>size</p> <p>Returns the size of the block, i.e. its dimension.</p> JuliaC++ <pre><code>size(block::Spinhalf)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>dim</p> <p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> JuliaC++ <pre><code>dim(block::Spinhalf)\n</code></pre> <pre><code>int64_tdim() const;\n</code></pre> <p>isreal</p> <p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> JuliaC++ <pre><code>isreal(block::Spinhalf; precision::Real=1e-12)\n</code></pre> <pre><code>int64_t isreal(double precision = 1e-12) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>N = 4\nnup = 2\n\n# without Sz conservation\nblock = Spinhalf(N)\n@show block\n\n\n# with Sz conservation\nblock_sz = Spinhalf(N, nup)\n@show block_sz\n\n# with symmetries, without Sz\np1 = Permutation([0, 1, 2, 3])\np2 = Permutation([1, 2, 3, 0])\np3 = Permutation([2, 3, 0, 1])\np4 = Permutation([3, 0, 1, 2])\ngroup = PermutationGroup([p1, p2, p3, p4])\nrep = Representation([1, -1, 1, -1])\nblock_sym = Spinhalf(N, group, rep)\n@show block_sym\n\n# with symmetries and Sz\nblock_sym_sz = Spinhalf(N, nup, group, rep)\n@show block_sym_sz\n\n@show n_sites(block_sym_sz)\n@show size(block_sym_sz)\n\n# Iteration\nfor pstate in block_sym_sz\n    @show pstate, index(block_sym_sz, pstate)\nend\n@show permutation_group(block_sym_sz)\n@show irrep(block_sym_sz)\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\n\n// without Sz conservation\nauto block = Spinhalf(N);\nXDIAG_SHOW(block);\n\n// with Sz conservation\nauto block_sz = Spinhalf(N, nup);\nXDIAG_SHOW(block_sz);\n\n// with symmetries, without Sz\nPermutation p1 = {0, 1, 2, 3};\nPermutation p2 = {1, 2, 3, 0};\nPermutation p3 = {2, 3, 0, 1};\nPermutation p4 = {3, 0, 1, 2};\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block_sym = Spinhalf(N, group, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and Sz\nauto block_sym_sz = Spinhalf(N, nup, group, irrep);\nXDIAG_SHOW(block_sym_sz);\n\nXDIAG_SHOW(block_sym_sz.n_sites());\nXDIAG_SHOW(block_sym_sz.size());\n\n// Iteration\nfor (auto pstate : block_sym_sz) {\n  Log(\"{} {}\", to_string(pstate), block_sym_sz.index(pstate));\n}\nXDIAG_SHOW(block_sym_sz.permutation_group());\nXDIAG_SHOW(block_sym_sz.irrep());\n</code></pre>"},{"location":"documentation/blocks/tJ/","title":"tJ","text":"<p>Representation of a block in a  \\(t-J\\) type Hilbert space. </p> <p>Source tj.hpp</p>"},{"location":"documentation/blocks/tJ/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>tJ(n_sites::Integer, n_up::Integer, n_dn::Integer)\ntJ(n_sites::Integer, n_up::Integer, n_dn::Integer, \n   group::PermutationGroup, irrep::Representation)\n</code></pre> <pre><code>tJ(int64_t n_sites, int64_t n_up, int64_t n_dn);\ntJ(int64_t n_sites, int64_t n_up, int64_t n_dn, \n   PermutationGroup group, Representation irrep);\n</code></pre> Name Description n_sites number of sites (integer) n_up number of \"up\" electrons (integer) n_dn number of \"dn\" electrons (integer) group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group"},{"location":"documentation/blocks/tJ/#iteration","title":"Iteration","text":"<p>An tJ block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> JuliaC++ <pre><code>block = tJ(4, 2, 1)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre> <pre><code>auto block = tJ(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/tJ/#methods","title":"Methods","text":"<p>index</p> <p>Returns the index of a given ProductState in the basis of the tJ block.</p> JuliaC++ <pre><code>index(block::tJ, pstate::ProductState)\n</code></pre> <pre><code>int64_t index(ProductState const &amp;pstate) const;\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p> <p>n_sites</p> <p>Returns the number of sites of the block.</p> JuliaC++ <pre><code>n_sites(block::tJ)\n</code></pre> <pre><code>int64_t n_sites() const;\n</code></pre> <p>n_up</p> <p>Returns the number of \"up\" electrons.</p> JuliaC++ <pre><code>n_up(block::tJ)\n</code></pre> <pre><code>int64_t n_up() const;\n</code></pre> <p>n_dn</p> <p>Returns the number of \"down\" electrons.</p> JuliaC++ <pre><code>n_dn(block::tJ)\n</code></pre> <pre><code>int64_t n_dn() const;\n</code></pre> <p>permutation_group</p> <p>Returns the PermutationGroup of the block, if defined.</p> JuliaC++ <pre><code>permutation_group(block::tJ)\n</code></pre> <pre><code>PermutationGroup permutation_group() const;\n</code></pre> <p>irrep</p> <p>Returns the Representation of the block, if defined.</p> JuliaC++ <pre><code>irrep(block::tJ)\n</code></pre> <pre><code>Representation irrep() const;\n</code></pre> <p>size</p> <p>Returns the size of the block, i.e. its dimension.</p> JuliaC++ <pre><code>size(block::tJ)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>dim</p> <p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> JuliaC++ <pre><code>dim(block::tJ)\n</code></pre> <pre><code>int64_tdim() const;\n</code></pre> <p>isreal</p> <p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> JuliaC++ <pre><code>isreal(block::tJ; precision::Real=1e-12)\n</code></pre> <pre><code>int64_t isreal(double precision = 1e-12) const;\n</code></pre>"},{"location":"documentation/blocks/tJ/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without permutation symmetries\nblock = tJ(N, nup, ndn)\n@show block\n\n# with permutation symmetries\np1 = Permutation([0, 1, 2, 3])\np2 = Permutation([1, 2, 3, 0])\np3 = Permutation([2, 3, 0, 1])\np4 = Permutation([3, 0, 1, 2])\ngroup = PermutationGroup([p1, p2, p3, p4])\nrep = Representation([1, -1, 1, -1])\nblock_sym = tJ(N, nup, ndn, group, rep)\n@show block_sym\n\n@show n_sites(block_sym)\n@show size(block_sym)\n\n# Iteration\nfor pstate in block_sym\n    @show pstate, index(block_sym, pstate)\nend\n@show permutation_group(block_sym)\n@show irrep(block_sym)\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without permutation symmetries\nauto block = tJ(N, nup, ndn);\nXDIAG_SHOW(block);\n\n// with permutation symmetries\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block_sym = tJ(N, nup, ndn, group, irrep);\nXDIAG_SHOW(block_sym);\n\nXDIAG_SHOW(block_sym.n_sites());\nXDIAG_SHOW(block_sym.size());\n\n// Iteration\nfor (auto pstate : block_sym) {\n  Log(\"{} {}\", to_string(pstate), block_sym.index(pstate));\n}\nXDIAG_SHOW(block_sym.permutation_group());\nXDIAG_SHOW(block_sym.irrep());\n</code></pre>"},{"location":"documentation/operators/coupling/","title":"Coupling","text":"<p>Describes the coupling of a local operator. A coupling can either be a string, a real/complex number or even a real/complex matrix. It allows for converting to real/complex numbers or matrices as well as strings, whenever this conversion is sensible. </p> <p>Source coupling.hpp</p>"},{"location":"documentation/operators/coupling/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>Coupling(name::String)\nCoupling(val::Float64)\nCoupling(val::ComplexF64)\nCoupling(mat::Matrix{Float64})\nCoupling(mat::Matrix{ComplexF64})\n</code></pre> <pre><code>Coupling(std::string value);\nCoupling(double value);\nCoupling(complex value);\nCoupling(arma::mat const &amp;value);\nCoupling(arma::cx_mat const &amp;value);\n</code></pre>"},{"location":"documentation/operators/coupling/#methods","title":"Methods","text":"<p>type</p> <p>Returns the type of the Coupling, i.e. a string which either reads \"string\", \"double\", \"complex\", \"mat\", or \"cx_mat\"</p> JuliaC++ <pre><code>type(cpl::Coupling)\n</code></pre> <pre><code>std::string type() const;\n</code></pre> <p>isreal</p> <p>Returns whether or not the coupling is real. Throws an error if the coupling is given as a string, since then it cannot be determined whether the operator is real.</p> JuliaC++ <pre><code>isreal(cpl::Coupling)\n</code></pre> <pre><code>bool isreal() const;\n</code></pre> <p>ismatrix</p> <p>Returns whether or not the coupling is defined as a matrix. Throws an error if the coupling is given as a string, since then it cannot be determined whether the operator is real.</p> JuliaC++ <pre><code>ismatrix(cpl::Coupling)\n</code></pre> <pre><code>bool ismatrix() const;\n</code></pre> <p>isexplicit</p> <p>Returns false if the coupling is defined as a string, otherwise true</p> JuliaC++ <pre><code>isexplicit(cpl::Coupling)\n</code></pre> <pre><code>bool isexplicit() const;\n</code></pre>"},{"location":"documentation/operators/coupling/#conversions","title":"Conversions","text":"<p>A Coupling can be converted to the values it represents, so a string, real/complex number or a real/complex matrix. Initially real values can be cast to complex.</p> JuliaC++ <pre><code>convert(::Type{String}, cpl::Coupling)\nconvert(::Type{Float64}, cpl::Coupling)\nconvert(::Type{ComplexF64}, cpl::Coupling)\nconvert(::Type{Matrix{Float64}}, cpl::Coupling)\nconvert(::Type{Matrix{ComplexF64}}, cpl::Coupling)\n</code></pre> <pre><code>template &lt;typename coeff_t&gt; coeff_t as() const;\n</code></pre>"},{"location":"documentation/operators/coupling/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>cpl = Coupling(\"J\")\n@show type(cpl)\n@show isexplicit(cpl)\n\ncpl = Coupling(1.23)\n@show ismatrix(cpl)\n@show convert(Float64, cpl)\n@show convert(ComplexF64, cpl)\n\ncpl = Coupling([1 2; -2 1])\n@show ismatrix(cpl)\n@show isreal(cpl)\n@show convert(Matrix{Float64}, cpl)\n@show convert(Matrix{ComplexF64}, cpl)\n</code></pre> <pre><code>auto cpl = Coupling(\"J\");\nXDIAG_SHOW(cpl.type());\nXDIAG_SHOW(cpl.isexplicit());\n\ncpl = Coupling(1.23);\nXDIAG_SHOW(cpl.ismatrix());\nXDIAG_SHOW(cpl.as&lt;double&gt;());\nXDIAG_SHOW(cpl.as&lt;complex&gt;());\n\ncpl = Coupling(arma::mat(\"1 2; -2 1\"));\nXDIAG_SHOW(cpl.ismatrix());\nXDIAG_SHOW(cpl.isreal());\nXDIAG_SHOW(cpl.as&lt;arma::mat&gt;());\nXDIAG_SHOW(cpl.as&lt;arma::cx_mat&gt;());\n</code></pre>"},{"location":"documentation/operators/op/","title":"Op","text":"<p>A local operator acting on several lattice sites.</p> <p>Source op.hpp</p>"},{"location":"documentation/operators/op/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>Op(type::String, coupling::String, sites::Vector{Int64})\nOp(type::String, coupling::String, site::Int64)\n\nOp(type::String, coupling::Float64, sites::Vector{Int64})\nOp(type::String, coupling::Float64, site::Int64)\n\nOp(type::String, coupling::ComplexF64, sites::Vector{Int64})\nOp(type::String, coupling::ComplexF64, site::Int64)\n\nOp(type::String, coupling::Matrix{Float64}, sites::Vector{Int64})\nOp(type::String, coupling::Matrix{Float64}, site::Int64)\n\nOp(type::String, coupling::Matrix{ComplexF64}, sites::Vector{Int64})\nOp(type::String, coupling::Matrix{ComplexF64}, site::Int64)\n</code></pre> <pre><code>Op(std::string type, std::string coupling, std::vector&lt;int64_t&gt; const &amp;sites)\nOp(std::string type, std::string coupling, int64_t site)\n\nOp(std::string type, double coupling, std::vector&lt;int64_t&gt; const &amp;sites)\nOp(std::string type, double coupling, int64_t site)\n\nOp(std::string type, complex coupling, std::vector&lt;int64_t&gt; const &amp;sites)\nOp(std::string type, complex coupling, int64_t site)\n\nOp(std::string type, arma::mat const &amp;coupling, std::vector&lt;int64_t&gt; const &amp;sites)\nOp(std::string type, arma::mat const &amp;coupling, int64_t site)\n\nOp(std::string type, arma::cx_mat const &amp;coupling, std::vector&lt;int64_t&gt; const &amp;sites)\nOp(std::string type, arma::cx_mat const &amp;coupling, int64_t site)\n</code></pre> Parameter Description type a string which denotes what kind of operator is represented coupling sets the coefficients neded to specify the coupling. Further details below sites defines on which site(s) of the lattice the operator acts on. <p>The coupling can take on several types and allow some flexibility in defining operators.</p> type Description string the coupling is represented as a string, e.g. \"\\(t\\)\" or \"\\(J\\)\" in a \\(t-J\\) model real/cplx number the actual numerical value of the coupling real/cplx matrix more generic interactions can be specified as matrices"},{"location":"documentation/operators/op/#methods","title":"Methods","text":"<p>type</p> <p>Returns the type of the operator</p> JuliaC++ <pre><code>type(op::Op)\n</code></pre> <pre><code>std::string type() const;\n</code></pre> <p>coupling</p> <p>Returns the coupling of the operator</p> JuliaC++ <pre><code>coupling(op::Op)\n</code></pre> <pre><code>Coupling const &amp;coupling() const;\n</code></pre> <p>This returns an object of type Coupling, which can then be converted to an appropriate type.</p> <p>size</p> <p>Returns how many sites the operator is defined on</p> JuliaC++ <pre><code>size(op::Op)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>getindex / operator[]</p> <p>Returns the site with the given index.</p> JuliaC++ <pre><code>getindex(op::Op, idx::Int64)\n</code></pre> <pre><code>int64_t operator[](int64_t idx) const;\n</code></pre> <p>sites</p> <p>Returns all the sites the operator is defined on</p> JuliaC++ <pre><code>sites(op::Op)\n</code></pre> <pre><code>std::vector&lt;int64_t&gt; const &amp;sites() const;\n</code></pre> <p>isreal</p> <p>Returns whether or not the coupling is real. Throws an error if the coupling is given as a string, since then it cannot be determined whether the operator is real.</p> JuliaC++ <pre><code>isreal(op::Op)\n</code></pre> <pre><code>bool isreal() const;\n</code></pre> <p>ismatrix</p> <p>Returns whether or not the coupling is defined as a matrix. Throws an error if the coupling is given as a string, since then it cannot be determined whether the operator is real.</p> JuliaC++ <pre><code>ismatrix(op::Op)\n</code></pre> <pre><code>bool ismatrix() const;\n</code></pre> <p>isexplicit</p> <p>Returns false if the coupling is defined as a string, otherwise true</p> JuliaC++ <pre><code>isexplicit(op::Op)\n</code></pre> <pre><code>bool isexplicit() const;\n</code></pre>"},{"location":"documentation/operators/op/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>op = Op(\"HOP\", \"T\", [1, 2])\n@show op\n@show type(op)\n@show convert(String, coupling(op))\n@show size(op), op[1], op[2]\n@show sites(op) == [1, 2]\n@show isexplicit(op)\n\nop = Op(\"HOP\", 1.23, [1, 2])\n@show op\n@show isreal(op)\n@show ismatrix(op)\n@show isexplicit(op)\n\nop = Op(\"SY\", [0 -im; im 0], 1)\n@show op\n@show isreal(op)\n@show ismatrix(op)\n@show isexplicit(op)\n</code></pre> <pre><code>auto op = Op(\"HOP\", \"T\", {1, 2});\nXDIAG_SHOW(op);\nXDIAG_SHOW(op.type());\nXDIAG_SHOW(op.coupling().as&lt;std::string&gt;());\nXDIAG_SHOW(op.size());\nXDIAG_SHOW(op[0]);\nXDIAG_SHOW(op[1]);\nXDIAG_SHOW(op.isexplicit());\n\n op = Op(\"HOP\", 1.23, {1, 2});\nXDIAG_SHOW(op);\nXDIAG_SHOW(op.isreal());\nXDIAG_SHOW(op.ismatrix());\nXDIAG_SHOW(op.isexplicit());\n\narma::cx_mat m(arma::mat(\"0 0; 0 0\"), arma::mat(\"0 -1; 1 0\"));\nop = Op(\"SY\", m, 1);\nXDIAG_SHOW(op);\nXDIAG_SHOW(op.isreal());\nXDIAG_SHOW(op.ismatrix());\nXDIAG_SHOW(op.isexplicit());\n</code></pre>"},{"location":"documentation/operators/opsum/","title":"OpSum","text":"<p>A sum of local operators acting on several lattice sites.</p> <p>Source opsum.hpp</p>"},{"location":"documentation/operators/opsum/#constructor","title":"Constructor","text":"JuliaC++ <pre><code>OpSum()\nOpSum(ops::Vector{Op})\n</code></pre> <pre><code>OpSum() = default;\nOpSum(std::vector&lt;Op&gt; const &amp;ops);\n</code></pre> Parameter Description ops a vector of Op objects describing the operators summed over"},{"location":"documentation/operators/opsum/#methods","title":"Methods","text":"<p>size</p> <p>Returns the number of local Op operators.</p> JuliaC++ <pre><code>size(ops::OpSum)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>defined</p> <p>Returns bool whether a coupling (of type string) is defined</p> JuliaC++ <pre><code>defined(ops::OpSum, name::String)\n</code></pre> <pre><code>bool defined(std::string name) const;\n</code></pre> <p>setindex! / operator[]</p> <p>Sets a coupling given as a string to a certain numerical value or matrix</p> JuliaC++ <pre><code>Base.setindex!(ops::OpSum, cpl, name::String)\n</code></pre> <pre><code>Coupling &amp;operator[](std::string name);\n</code></pre> <p>getindex / operator[]</p> <p>Returns the value of a Coupling defined as a string. </p> JuliaC++ <pre><code>getindex(ops::OpSum, name::String)\n</code></pre> <pre><code>Coupling const &amp;operator[](std::string name) const;\n</code></pre> <p>couplings</p> <p>Returns all the possible names of Coupling as a vector of strings</p> JuliaC++ <pre><code>couplings(ops::OpSum)\n</code></pre> <pre><code>std::vector&lt;std::string&gt; couplings() const;\n</code></pre> <p>isreal</p> <p>Returns whether or not the OpSum is real. This will throw an error if some Coupling are only defined as a string.</p> JuliaC++ <pre><code>isreal(ops::OpSum)\n</code></pre> <pre><code>bool isreal() const;\n</code></pre> <p>isexplicit</p> <p>Returns false if there exist a Coupling which is defined as a string, otherwise true.</p> JuliaC++ <pre><code>isexplicit(ops::OpSum)\n</code></pre> <pre><code>bool isexplicit() const;\n</code></pre> <p>operator +</p> <p>Adds a single Op or a full OpSum</p> JuliaC++ <pre><code>+(ops::OpSum, op2::Op) = OpSum(ops.cxx_opsum + op2.cxx_op)\n+(ops::OpSum, ops2::OpSum) = OpSum(ops.cxx_opsum + ops2.cxx_opsum)\n</code></pre> <pre><code>void operator+=(Op const &amp;op);\nvoid operator+=(OpSum const &amp;ops);\nOpSum operator+(Op const &amp;op) const;\nOpSum operator+(OpSum const &amp;ops) const;\n</code></pre>"},{"location":"documentation/operators/opsum/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code># Define the 1D transverse-field Ising chain\nlet \n    N = 12\n    J = 1.0\n    h = 0.5\n    Sx = [0 1; 1 0]\n\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"ISING\", \"J\", [i-1, i % N])\n        ops += Op(\"SX\", h * Sx, i-1)\n    end\n\n    ops[\"J\"] = 1.0;\n    @show ops\n    @show defined(ops, \"J\")\n    @show isreal(ops)\n    @show isexplicit(ops)\nend\n</code></pre> <pre><code>// Define the 1D transverse-field Ising chain\nint N = 12;\ndouble J = 1.0;\ndouble h = 0.5;\nauto Sx = arma::mat(\"0 1; 1 0\");\n\nauto ops = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops += Op(\"ISING\", \"J\", {i, (i+1)%N});\n  ops += Op(\"SX\", arma::mat(h*Sx), i);\n}\nops[\"J\"] = 1.0;\nXDIAG_SHOW(ops);\nXDIAG_SHOW(ops.defined(\"J\"));\nXDIAG_SHOW(ops.isreal());\nXDIAG_SHOW(ops.isexplicit());\n</code></pre>"},{"location":"documentation/operators/symmetrize/","title":"symmetrize","text":"<p>Symmetrizes an operator with respect to a permutation symmetry group.</p> <p>Source symmetrize.hpp</p> JuliaC++ <pre><code>symmetrize(op::Op, group::PermutationGroup)\nsymmetrize(op::Op, group::PermutationGroup, irrep::Representation)\nsymmetrize(ops::OpSum, group::PermutationGroup)\nsymmetrize(ops::OpSum, group::PermutationGroup, irrep::Representation)\n</code></pre> <pre><code>OpSum symmetrize(Op const &amp;op, PermutationGroup const &amp;group);\nOpSum symmetrize(Op const &amp;op, PermutationGroup const &amp;group, Representation const &amp;irrep);\nOpSum symmetrize(OpSum const &amp;ops, PermutationGroup const &amp;group);\nOpSum symmetrize(OpSum const &amp;ops, PermutationGroup const &amp;group, Representation const &amp;irrep);\n</code></pre>"},{"location":"documentation/operators/symmetrize/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator to be symmetrized group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group <p>Symmetrization in this context means the following. In general, we are given an OpSum of the form,</p> \\[ O = \\sum_{A\\subseteq \\mathcal{L}} O_A,\\] <p>where \\(O_A\\) denotes a local operator acting on sites \\(A=\\{a_1, \\ldots, a_{l_A}\\}\\) and \\(L\\) denotes the lattice. A PermutationGroup \\(\\mathcal{G}\\) is defined through its permutations \\(\\pi_1, \\ldots, \\pi_M\\). The symmetrized operator returned by this function is then </p> \\[ O^\\mathcal{G} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}}  O_{\\pi(A)},\\] <p>where \\(\\pi(A) = \\{\\pi(a_1), \\ldots,\\pi(a_{l_A})\\}\\) denotes the permutated set of sites of the local operator \\(O_A\\). If a Representation called \\(\\rho\\) is given in addition, the following operator is constructed,</p> \\[ O^\\mathcal{G, \\rho} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}} \\chi_\\rho(\\pi) O_{\\pi(A)},\\] <p>where \\(\\chi_\\rho(\\pi)\\) denotes the characters of the representation \\(\\rho\\). This routine is useful to evaluate observables in symmetrized blocks.</p>"},{"location":"documentation/operators/symmetrize/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>let\n    N = 4\n    nup = 2\n    block = Spinhalf(N, nup)\n    p1 = Permutation([0, 1, 2, 3])\n    p2 = Permutation([1, 2, 3, 0])\n    p3 = Permutation([2, 3, 0, 1])\n    p4 = Permutation([3, 0, 1, 2])\n    group = PermutationGroup([p1, p2, p3, p4])\n    rep = Representation([1, 1, 1, 1])\n    block_sym = Spinhalf(N, group, rep)\n\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", 1.0, [i-1, i % N])\n    end\n\n    e0, psi = eig0(ops, block);\n    e0, psi_sym = eig0(ops, block_sym);\n\n    corr = Op(\"HB\", 1.0, [0, 1])\n    nn_corr = inner(corr, psi)\n    corr_sym = symmetrize(corr, group)\n    nn_corr_sym = inner(corr_sym, psi_sym)\n    @show nn_corr, nn_corr_sym\nend\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\nauto block = Spinhalf(N, nup);\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto rep = Representation({1, 1, 1, 1});\nauto block_sym = Spinhalf(N, group, rep);\n\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"HB\", 1.0, {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto [e0s, psi_sym] = eig0(ops, block_sym);\n\nauto corr = Op(\"HB\", 1.0, {0, 1});\nauto nn_corr = inner(corr, psi);\nauto corr_sym = symmetrize(corr, group);\nauto nn_corr_sym = innerC(corr_sym, psi_sym);\nXDIAG_SHOW(nn_corr);\nXDIAG_SHOW(nn_corr_sym);\n</code></pre>"},{"location":"documentation/states/create_state/","title":"Functions to create and modify states","text":"<p>Source create_state.hpp</p>"},{"location":"documentation/states/create_state/#product","title":"product","text":"<p>Creates a filled product state.</p> JuliaC++ <pre><code>product(block::Block, local_states::Vector{String}, real::Bool=true)\n</code></pre> <pre><code>State product(Block const &amp;block, std::vector&lt;std::string&gt; const &amp;local_state, bool real = true);\n</code></pre>"},{"location":"documentation/states/create_state/#parameters","title":"Parameters","text":"Name Description block block on which the state is defined local_states local configurations of the product state real flag whether real state is created"},{"location":"documentation/states/create_state/#rand","title":"rand","text":"<p>Create a filled random state with normal distributed coefficients.</p> JuliaC++ <pre><code>rand(block::Block, real::Bool=true, seed::Int64=42, normalized::Bool=true\n</code></pre> <pre><code>State rand(Block const &amp;block, bool real = true, int64_t seed = 42, bool normalized = true);\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_1","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created seed random seed determining the precise random numbers normalized flag whether the state is normalized"},{"location":"documentation/states/create_state/#zeros","title":"zeros","text":"<p>Create a filled state with all zero entries.</p> JuliaC++ <pre><code>zeros(block::Block, real::Bool=true, n_col::Int64=1)\n</code></pre> <pre><code>State zeros(Block const &amp;block, bool real = true, int64_t n_cols = 1);\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_2","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created n_col number of columns in the state"},{"location":"documentation/states/create_state/#zero","title":"zero","text":"<p>Set all coefficients of a given state to zero.</p> JuliaC++ <pre><code>zero(state::State)\n</code></pre> <pre><code>void zero(State &amp;state);\n</code></pre>"},{"location":"documentation/states/create_state/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>block = Spinhalf(2)\nstate = product(block, [\"Up\", \"Dn\"])\ndisplay(vector(state))\n\nzero(state)\ndisplay(vector(state))\n\nstate = rand(block, false, 1234, true)\ndisplay(vector(state))\n\nstate = zeros(block, true, 2)\ndisplay(matrix(state))\n</code></pre> <pre><code>auto block = Spinhalf(2);\nauto state = product(block, {\"Up\", \"Dn\"});\nXDIAG_SHOW(state.vector());\n\nzero(state);\nXDIAG_SHOW(state.vector());\n\nstate = rand(block, false, 1234, true);\nXDIAG_SHOW(state.vectorC());\n\nstate = zeros(block, true, 2);\nXDIAG_SHOW(state.vector());\n</code></pre>"},{"location":"documentation/states/fill/","title":"fill","text":"<p>Fills a State with a given model state, e.g. a ProductState or a RandomState.</p> <p>Source fill.hpp</p>"},{"location":"documentation/states/fill/#definition","title":"Definition","text":"JuliaC++ <pre><code>fill(state::State, pstate::ProductState, ncol::Int64 = 1)\nfill(state::State, rstate::RandomState, ncol::Int64 = 1)\n</code></pre> <pre><code>void fill(State &amp;state, ProductState const &amp;pstate, int64_t ncol = 0);\nvoid fill(State &amp;state, RandomState const &amp;rstate, int64_t ncol = 0);\n</code></pre>"},{"location":"documentation/states/fill/#parameters","title":"Parameters","text":"Name Description state State object to be filled pstate ProductState object rstate RandomState object ncol integer deciding which column of the State is filled (default: 1/0 (Julia/C++))"},{"location":"documentation/states/fill/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>block = Spinhalf(2)\nstate = State(block)\npstate = ProductState([\"Up\", \"Dn\"])\nfill(state, pstate)\ndisplay(vector(state))\n\nrstate = RandomState(1234)\nfill(state, rstate)\ndisplay(vector(state))\n</code></pre> <pre><code>auto block = Spinhalf(2);\nauto state = State(block);  \nauto pstate = ProductState({\"Up\", \"Dn\"});\nfill(state, pstate);\nXDIAG_SHOW(state.vector());\n\nauto rstate = RandomState(1234);\nfill(state, rstate);\nXDIAG_SHOW(state.vector());\n</code></pre>"},{"location":"documentation/states/product_state/","title":"ProductState","text":"<p>A product state of local configurations</p> <p>Source product_state.hpp</p>"},{"location":"documentation/states/product_state/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>ProductState(n_sites::Int64)\nProductState(local_states::Vector{String})\n</code></pre> <pre><code>ProductState(int64_t n_sites);\nProductState(std::vector&lt;std::string&gt; const &amp;local_states);\n</code></pre> Parameter Description n_sites construct a product state on n_sites local_states the local configurations of the product state"},{"location":"documentation/states/product_state/#iteration","title":"Iteration","text":"<p>A Product state can be iterated over, where at each iteration the string of the local configuration is retured. Here is an example:</p> JuliaC++ <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n</code></pre> <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n    Log(\"{}\", s);\n}\n</code></pre>"},{"location":"documentation/states/product_state/#methods","title":"Methods","text":"<p>n_sites</p> <p>Returns the number of sites of the product state</p> JuliaC++ <pre><code>n_sites(state::ProductState)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> <p>size</p> <p>Returns the number of sites of the product state. Same as \"n_sites\".</p> JuliaC++ <pre><code>size(state::ProductState)\n</code></pre> <pre><code>int64_t size() const\n</code></pre> <p>setindex! / operator[]</p> <p>Sets the local configuration at the given site index to the given string.</p> JuliaC++ <pre><code>setindex!(state::ProductState, local_state::String, idx::Int64)\n</code></pre> <pre><code>std::string &amp;operator[](int64_t i);\n</code></pre> <p>getindex / operator[]</p> <p>Returns the string of the local configuration at the given site index.</p> JuliaC++ <pre><code>getindex(state::ProductState, idx::Int64)\n</code></pre> <pre><code>std::string const &amp;operator[](int64_t i) const;\n</code></pre> <p>push! / push_back</p> <p>Adds a local configuration add the end of the product state.</p> JuliaC++ <pre><code>push!(state::ProductState, local_state::String\n</code></pre> <pre><code>void push_back(std::string l);\n</code></pre>"},{"location":"documentation/states/product_state/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n@show pstate\n\npstate = ProductState()\npush!(pstate, \"Dn\")\npush!(pstate, \"Up\")\npush!(pstate, \"Dn\")\n@show n_sites(pstate)\nfor s in pstate\n    @show s\nend\n@show pstate\n</code></pre> <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n\npstate = ProductState();\npstate.push_back(\"Dn\");\npstate.push_back(\"Up\");\npstate.push_back(\"Dn\");\nXDIAG_SHOW(pstate.n_sites());\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n</code></pre>"},{"location":"documentation/states/random_state/","title":"RandomState","text":"<p>A random state with normal distributed coefficients</p> <p>Source random_state.hpp</p>"},{"location":"documentation/states/random_state/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>RandomState(seed::Int64 = 42, normalized::Bool = true)\n</code></pre> <pre><code>RandomState(int64_t seed = 42, bool normalized = true);\n</code></pre> Parameter Description seed random seed determining which random numbers are put normalized flag whether the State is normalized"},{"location":"documentation/states/random_state/#methods","title":"Methods","text":"<p>seed</p> <p>Returns the seed of the random state</p> JuliaC++ <pre><code>seed(state::RandomState)\n</code></pre> <pre><code>int64_t seed() const;\n</code></pre> <p>size</p> <p>Returns whether the state is normalized.</p> JuliaC++ <pre><code>normalized(state::RandomState)\n</code></pre> <pre><code>bool normalized() const;\n</code></pre>"},{"location":"documentation/states/random_state/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>block = Spinhalf(2)\nstate = State(block, real=false)  # complex State\nrstate1 = RandomState(1234)\nfill(state, rstate1)\ndisplay(vector(state))\n\nrstate2 = RandomState(4321)\nfill(state, rstate2)\ndisplay(vector(state))\n\nfill(state, rstate1)\ndisplay(vector(state))\n</code></pre> <pre><code>auto block = Spinhalf(2);\nauto state = State(block, false);  // complex State\nauto rstate1 = RandomState(1234);\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n\nauto rstate2 = RandomState(4321);\nfill(state, rstate2);\nXDIAG_SHOW(state.vectorC());\n\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n</code></pre>"},{"location":"documentation/states/state/","title":"State","text":"<p>A generic state describing a quantum wave function</p> <p>Source state.hpp</p>"},{"location":"documentation/states/state/#constructors","title":"Constructors","text":"JuliaC++ <pre><code>State(block::Block; real::Bool = true, n_cols::Int64 = 1)\nState(block::Block, vec::Vector{Float64})\nState(block::Block, vec::Vector{ComplexF64})\nState(block::Block, mat::Matrix{Float64})\nState(block::Block, mat::Matrix{ComplexF64})\n</code></pre> <pre><code>State(Block const &amp;block, bool real = true, int64_t n_cols = 1);\n\ntemplate &lt;typename block_t, typename coeff_t&gt;\nState(block_t const &amp;block, arma::Col&lt;coeff_t&gt; const &amp;vector);\n\ntemplate &lt;typename block_t, typename coeff_t&gt;\nState(block_t const &amp;block, arma::Mat&lt;coeff_t&gt; const &amp;matrix);\n</code></pre> Parameter Description block The block of a Hilbertspace on which the state is defined real Flag whether or not the state has real coefficients n_cols Number of columns of the state (default 1) vector A vector containing the coefficients of the state. Must be same size as block. matrix A matrix containing the coefficients of the state. Number of rows must be same as block size ."},{"location":"documentation/states/state/#methods","title":"Methods","text":"<p>n_sites</p> <p>Returns the number of sites of the block the state is defined on.</p> JuliaC++ <pre><code>n_sites(state::State)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> <p>isreal</p> <p>Returns whether the state is real.</p> JuliaC++ <pre><code>isreal(state::State)\n</code></pre> <pre><code>int64_t isreal() const;\n</code></pre> <p>real</p> <p>Returns whether the real part of the State.</p> JuliaC++ <pre><code>real(state::State)\n</code></pre> <pre><code>State real() const;\n</code></pre> <p>imag</p> <p>Returns whether the imaginary part of the State.</p> JuliaC++ <pre><code>imag(state::State)\n</code></pre> <pre><code>State imag() const;\n</code></pre> <p>make_complex! / make_complex</p> <p>Turns a real State into a complex State. Does nothing if the state is already complex</p> JuliaC++ <pre><code>make_complex!(state::State)\n</code></pre> <pre><code>void make_complex();\n</code></pre> <p>dim</p> <p>Returns the dimension of the block the state is defined on.</p> JuliaC++ <pre><code>dim(block::Spinhalf)\n</code></pre> <pre><code>int64_t dim() const;\n</code></pre> <p>size</p> <p>Returns the size of the block  the state is defined on. locally. Same as \"dim\" for non-distributed Blocks but different for distributed blocks.</p> JuliaC++ <pre><code>size(block::Spinhalf)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>n_rows</p> <p>Returns number of rows of the local storage. Same as \"size\"</p> JuliaC++ <pre><code>n_rows(block::Spinhalf)\n</code></pre> <pre><code>int64_t n_rows() const;\n</code></pre> <p>n_cols</p> <p>Returns number of columns of the local storage.</p> JuliaC++ <pre><code>n_cols(block::Spinhalf)\n</code></pre> <pre><code>int64_t n_cols() const;\n</code></pre> <p>col</p> <p>Returns a state created from the n-th column of the storage. Whether or not the storage is copied can be specified by setting the flag \"copy\".</p> JuliaC++ <pre><code>col(state::State, n::Int64 = 1; copy::Bool = true)\n</code></pre> <pre><code>State col(int64_t n, bool copy = true) const;\n</code></pre> <p>vector/vectorC</p> <p>Returns a vector from the n-th column of the storage. In C++ use \"vector\"/\"vectorC\" to either get a real or complex vector.</p> JuliaC++ <pre><code>vector(state::State; n::Int64 = 1)\n# no vectorC method in julia\n</code></pre> <pre><code>arma::vec vector(int64_t n = 0, bool copy = true) const;\narma::cx_vec vectorC(int64_t n = 0, bool copy = true) const;\n</code></pre> <p>matrix/matrixC</p> <p>Returns matrix representing the storage. In C++ use \"matrix\"/\"matrixC\" to either get a real or complex matrix.</p> JuliaC++ <pre><code>matrix(state::State)\n# no matrixC method in julia\n</code></pre> <pre><code>arma::vec matrix(bool copy = true) const;\narma::cx_vec matrixC(bool copy = true) const;\n</code></pre>"},{"location":"documentation/states/state/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>block = Spinhalf(2)\npsi1 = State(block, [1.0, 2.0, 3.0, 4.0])\n@show psi1\ndisplay(vector(psi1))\nmake_complex!(psi1)\ndisplay(vector(psi1))\n\npsi2 = State(block, real=false, n_cols=3)\n@show psi2\ndisplay(matrix(psi2))\n\npsi3 = State(block, [1.0+4.0im, 2.0+3.0im, 3.0+2.0im, 4.0+1.0im])\ndisplay(vector(psi3))\ndisplay(vector(real(psi3)))\ndisplay(vector(imag(psi3)))\n</code></pre> <pre><code>auto block = Spinhalf(2);\nauto psi1 = State(block, arma::vec(\"1.0 2.0 3.0 4.0\"));\nXDIAG_SHOW(psi1);\nXDIAG_SHOW(psi1.vector());\npsi1.make_complex();\nXDIAG_SHOW(psi1.vectorC());\n\nauto psi2 = State(block, false, 3);\nXDIAG_SHOW(psi2);\nXDIAG_SHOW(psi2.matrixC());\n\nauto psi3 = State(block, arma::cx_vec(arma::vec(\"1.0 2.0 3.0 4.0\"),\n                      arma::vec(\"4.0 3.0 2.0 1.0\")));\nXDIAG_SHOW(psi3.vectorC());\nXDIAG_SHOW(psi3.real().vector());\nXDIAG_SHOW(psi3.imag().vector());\n</code></pre>"},{"location":"documentation/symmetries/permutation/","title":"Permutation","text":"<p>Permutations of indices or lattice sites</p> <p>Source permutation.hpp</p>"},{"location":"documentation/symmetries/permutation/#constructors","title":"Constructors","text":"<p>Creates an Permutation out of an array of integers, e.g. <code>[0, 2, 1, 3]</code>. If the input array is of size <code>N</code> then every number between <code>0</code> and <code>N-1</code> must occur exactly once, otherwise the Permutation is invalid.</p> JuliaC++ <pre><code>Permutation(array::Vector{Int64})\n</code></pre> <pre><code>Permutation(std::vector&lt;int64_t&gt; const &amp;array);\n</code></pre>"},{"location":"documentation/symmetries/permutation/#methods","title":"Methods","text":"<p>inverse</p> <p>Computes the inverse permutation.</p> JuliaC++ <pre><code>inverse(perm::Permutation)\n</code></pre> <pre><code>// As a member function\nPermutation inverse() const;\n\n// As a non-member function\nPermutation inverse(Permutation const &amp;p);\n</code></pre> <p>\"*\" operator</p> <p>Concatenates two permutations by overloading the <code>*</code> operator.</p> JuliaC++ <pre><code>Base.:*(p1::Permutation, p2::Permutation)\n</code></pre> <pre><code>Permutation operator*(Permutation const &amp;p1, Permutation const &amp;p2);\n</code></pre> <p>size</p> <p>Returns the size of the permutation, i.e. the number of indices being permuted.</p> JuliaC++ <pre><code>size(perm::Permutation)\n</code></pre> <pre><code>// As a member function\nint64_t size() const;\n\n// As a non-member function\nint64_t size(Permutation const &amp;p);\n</code></pre>"},{"location":"documentation/symmetries/permutation/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>p1 = Permutation([0, 2, 1, 3])\np2 = Permutation([2, 0, 1, 3])\n\n@show inverse(p1)\n@show p1 * p2\n</code></pre> <pre><code>Permutation p1 = {0, 2, 1, 3};\nPermutation p2 = {2, 0, 1, 3};\n\nXDIAG_SHOW(inverse(p1));\nXDIAG_SHOW(p1*p2);\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/","title":"Permutation","text":"<p>A group of permutations </p> <p>Source permutation_group.hpp</p>"},{"location":"documentation/symmetries/permutation_group/#constructor","title":"Constructor","text":"<p>Creates an PermutationGroup out of a vector of Permutation objects.</p> JuliaC++ <pre><code>PermutationGroup(permutations::Vector{Permutation})\n</code></pre> <pre><code>PermutationGroup(std::vector&lt;Permutation&gt; const &amp;permutations);\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#methods","title":"Methods","text":"<p>n_sites</p> <p>Returns the number of sites on which the permutations of the group acts.</p> JuliaC++ <pre><code>n_sites(group::PermutationGroup)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> <p>size</p> <p>Returns the size of the permutation group, i.e. the number permutations</p> JuliaC++ <pre><code>size(group::PermutationGroup)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>inverse</p> <p>Given an index of a permutation, it returns the index of the inverse permutation.</p> JuliaC++ <pre><code>inverse(group::PermutationGroup, idx::Integer)\n</code></pre> <pre><code>// As a member function\nint64_t inverse(int64_t sym) const;\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code># Define a cyclic group of order 3\np1 = Permutation([0, 1, 2])\np2 = Permutation([1, 2, 0])\np3 = Permutation([2, 0, 1])\nC3 = PermutationGroup([p1, p2, p3])\n\n@show size(C3)\n@show n_sites(C3)\n@show inverse(C3, 1) # = 2\n</code></pre> <pre><code>// Define a cyclic group of order 3\nPermutation p1 = {0, 1, 2};\nPermutation p2 = {1, 2, 0};\nPermutation p3 = {2, 0, 1};\nauto C3 = PermutationGroup({p1, p2, p3});\n\nXDIAG_SHOW(C3.size());\nXDIAG_SHOW(C3.n_sites());\nXDIAG_SHOW(C3.inverse(1)); // = 2\n</code></pre>"},{"location":"documentation/symmetries/representation/","title":"Representation","text":"<p>A (1D) irreducible representation of a finite group.</p> <p>Source representation.hpp</p>"},{"location":"documentation/symmetries/representation/#constructors","title":"Constructors","text":"<p>Creates a Representation from a vector of complex numbers</p> JuliaC++ <pre><code>Representation(characters::Vector{&lt;:Number})\n</code></pre> <pre><code>Representation(std::vector&lt;complex&gt; const &amp;characters);\n</code></pre>"},{"location":"documentation/symmetries/representation/#methods","title":"Methods","text":"<p>size</p> <p>Returns the size of the Representation, i.e. the number of characters.</p> JuliaC++ <pre><code>size(irrep::Representation)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> <p>isreal</p> <p>Returns the whether or not the Representation is real, I.E. the characters are real numbers and do not have an imaginary part.</p> JuliaC++ <pre><code>isreal(irrep::Representation; precision::Real=1e-12)\n</code></pre> <pre><code>bool isreal(double precision = 1e-12) const;\n</code></pre> <p>\"*\" operator</p> <p>Multiplies two Representations by overloading the <code>*</code> operator.</p> JuliaC++ <pre><code>Base.:*(p1::Representation, p2::Representation)\n</code></pre> <pre><code>Representation operator*(Representation const &amp;p1, Representation const &amp;p2);\n</code></pre>"},{"location":"documentation/symmetries/representation/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>r1 = Representation([1, -1, 1, -1])\nr2 = Representation([1, 1im, -1, -1im])\n\n@show r1 * r2\n</code></pre> <pre><code>Representation r1 = {1, -1, 1, -1};\nRepresentation r2 = {1, 1i, -1, -1i};\n\nXDIAG_SHOW(r1 * r2);\n</code></pre>"},{"location":"documentation/utilities/logging/","title":"Logging","text":""},{"location":"documentation/utilities/logging/#setting-the-verbosity","title":"Setting the verbosity","text":"<p>Algorithms implemented in XDiag do not output anything during their execution by default. However, it is typically useful to get some information on how the code is performing and even intermediary results at runtime. For this, the verbosity of the internal XDiag logging can be set using the function <code>set_verbosity</code>, which is defined as </p> JuliaC++ <pre><code>set_verbosity(level::Integer);\n</code></pre> <pre><code>void set_verbosity(int64_t level);\n</code></pre> <p>There are several levels of verbosity, defining how much information is shown.</p> level outputed information 0 no information 1 some information 2 detailed information <p>For example, when computing a ground state energy using the eigval0 function, we can set a higher verbosity level using</p> JuliaC++ <pre><code>set_verbosity(2);\ne0 = eigval0(bonds, block);\n</code></pre> <pre><code>set_verbosity(2);\ndouble e0 = eigval0(bonds, block);\n</code></pre> <p>This will print detailed information, which can look like this</p> <pre><code>Lanczos iteration 1\nMVM: 0.00289 secs\nalpha: -0.2756971549998545\nbeta: 1.7639347562074059\neigs: -0.2756971549998545\nLanczos iteration 2\nMVM: 0.00244 secs\nalpha: -0.7116140394927443\nbeta: 2.3044797637130743\neigs: -2.2710052270892791 1.2836940325966804\nLanczos iteration 3\nMVM: 0.00210 secs\nalpha: -1.2772539678430306\nbeta: 2.6627870395174456\neigs: -3.7522788386927637 -0.6474957945455240 2.1352094709026579\n</code></pre>"},{"location":"documentation/utilities/logging/#log-mechanism-c-only","title":"Log mechanism (C++ only)","text":"<p>Producing nicely formatted output is unfortunately a bit cumbersome in standard C++. For this, the <code>Log</code> mechanism in XDiag can help. To simply write out a line of information you can call,</p> <pre><code>Log(\"hello from the logger\");\n</code></pre> <p>By default, a new line is added. It is also possible to set verbosity by handing the level as the first argument,</p> <pre><code>Log(2, \"hello from the logger only if global verbosity is set to &gt;= 2\");\n</code></pre> <p>This message will only appear if the global verbosity level is set to a value \\(\\geq 2\\). Finally, XDiag also supports formatted output by using the fmtlib. For example, numbers can be formated this way</p> <pre><code>Log(\"pi is around {:.4f} and the answer is {}\", 3.141592, 42);\n</code></pre>"},{"location":"documentation/utilities/logging/#source","title":"Source","text":"<p>logger.hpp</p>"},{"location":"documentation/utilities/timing/","title":"Timing","text":"<p>In standard C++ measuring time is a bit awkward. To quickly monitor the CPU time spent by XDiag by simple functions.</p>"},{"location":"documentation/utilities/timing/#simple-timing-using-tic-toc","title":"Simple timing using tic() / toc()","text":"<p>Similar as in Matlab one can use <code>tic()</code> and <code>toc()</code> to measure the time spent between two points in the code. </p> <pre><code>tic();\ndouble e0 = eigval0(bonds, block);\ntoc();\n</code></pre> <p><code>toc()</code> will output the time spent since the last time <code>tic()</code> has been called.</p>"},{"location":"documentation/utilities/timing/#detailed-timing","title":"Detailed timing","text":"<p>To get the present time, simply call </p> <pre><code>auto time = rightnow();\n</code></pre> <p>A timing (in second) between two time points can be written to output using</p> <pre><code>timing(begin, end);\n</code></pre> <p>This can even be accompanied by a message about what is being timed and a verbosity level (see Logging) can also be set. The full call signature is</p> <pre><code>timing(begin, end, message, level);\n</code></pre> Name Description Default begin starting time computed using <code>rightnow()</code> end end time computed using <code>rightnow()</code> message message string to be prepended to timing \"\" level verbosity level at which timing is printed 0"},{"location":"documentation/utilities/xdiag_show/","title":"Debug printing","text":"<p>For quick debugging in C++, XDiag features a simple macro which outputs the name and content of a variable calles <code>XDIAG_SHOW(x)</code>. For example</p> <pre><code>Spinhalf block(16, 8);\nXDIAG_SHOW(block);\n</code></pre> <p>will write an output similar to</p> <pre><code>block:\n  n_sites  : 16\n  n_up     : 8\n  dimension: 12,870\n  ID       : 0xa9127434d66b9878\n</code></pre> <p>The <code>XDIAG_SHOW(x)</code> macro can be used on any XDiag object and several other standard C++ objects as well.</p>"},{"location":"examples/cmake_distributed/","title":"CMakeLists.txt for the distributed XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  tj_distributed_time_evolve\n)\n\nfind_package(xdiag_distributed REQUIRED HINTS ../../../install)\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre>"},{"location":"examples/cmake_normal/","title":"CMakeLists.txt for the normal XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"../../install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre>"},{"location":"examples/hello_world/","title":"Hello world!","text":"JuliaC++ <pre><code>   using XDiag\n   say_hello()\n</code></pre> <pre><code>   #include &lt;xdiag/all.hpp&gt;\n\n   using namespace xdiag;\n\n   int main() try {\n     say_hello();\n   } catch (Error e) {\n     error_trace(e);\n   }\n</code></pre>"},{"location":"examples/spinhalf_chain_e0/","title":"Groundstate energy","text":"JuliaC++ <pre><code>using XDiag\n\nlet \n    N = 16;\n    nup = N \u00f7 2;\n    block = Spinhalf(N, nup);\n\n    # Define the nearest-neighbor Heisenberg model\n    bonds = BondList()\n    for i in 1:N\n        bonds += Bond(\"HB\", \"J\", [i-1, i % N])\n    end\n    bonds[\"J\"] = 1.0;\n\n    set_verbosity(2);             # set verbosity for monitoring progress\n    e0 = eigval0(bonds, block);   # compute ground state energy\n\n    println(\"Ground state energy: $e0\");\nend\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += Op(\"HB\", \"J\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre>"},{"location":"examples/tj_distributed_time_evolve/","title":"\\(t\\)-\\(J\\) distributed time evolution","text":"<pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nvoid measure_density(int n_sites, State const &amp;v) {\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n  for (int i = 0; i &lt; n_sites; ++i) {\n    complex sz = innerC(Bond(\"NUMBER\", i), v);\n    if (rank == 0) {\n      printf(\"%.6f \", std::real(sz));\n    }\n  }\n  if (rank == 0) {\n    printf(\"\\n\");\n  }\n}\n\nint main(int argc, char **argv) try {\n  MPI_Init(&amp;argc, &amp;argv);\n\n  int L = 6;\n  int W = 4;\n  double t = 1.0;\n  double J = 0.1;\n  double mu_0 = 10;\n\n  int n_sites = L * W;\n  double precision = 1e-12;\n\n  // Create square lattice t-J model\n  OpSum ops;\n  for (int x = 0; x &lt; L-1; ++x) {\n    for (int y = 0; y &lt; W; ++y) {\n      int nx = (x + 1) % L;\n      int ny = (y + 1) % W;\n\n      int site = x * W + y;\n      int right = nx * W + y;\n      int top = x * W + ny;\n      ops += Op(\"HOP\", \"T\", {site, right});\n      ops += Op(\"EXCHANGE\", \"J\", {site, right});\n      ops += Op(\"HOP\", \"T\", {site, top});\n      ops += Op(\"EXCHANGE\", \"J\", {site, top});\n\n\n\n      if (x &lt; L / 2) {\n    Log(\"x {} y {} site {} t {} r {} +\", x, y, site, top, right);\n        ops += Op(\"NUMBER\", \"MUPLUS\", site);\n      } else {\n    Log(\"x {} y {} site {} t {} r {} -\", x, y, site, top, right);\n        ops += Op(\"NUMBER\", \"MUNEG\", site);\n      }\n    }\n  }\n  ops[\"T\"] = t;\n  ops[\"J\"] = J;\n  ops[\"MUPLUS\"] = mu_0;\n  ops[\"MUNEG\"] = mu_0;\n\n  auto block = tJDistributed(n_sites, n_sites / 2 - 1, n_sites / 2 - 1);\n\n  XDIAG_SHOW(block);\n\n  Log.set_verbosity(2);\n  tic();\n  auto [e0, v] = eig0(ops, block);\n  toc(\"gs\");\n\n  ops[\"MUPLUS\"] = 0;\n  ops[\"MUNEG\"] = 0;\n\n  measure_density(n_sites, v);\n\n  // Do the time evolution with a step size tau\n  double tau = 0.1;\n  for (int i = 0; i &lt; 40; ++i) {\n    tic();\n    v = time_evolve(ops, v, tau, precision);\n    toc(\"time evolve\");\n    tic();\n    measure_density(n_sites, v);\n    toc(\"measure\");\n  }\n\n  MPI_Finalize();\n  return EXIT_SUCCESS;\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre>"}]}