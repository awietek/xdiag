{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Quick Start Code on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>XDiag is a library for performing Exact Diagonalizations of quantum many-body systems. Key features include optimized combinatorical algorithms for navigating Hilbert spaces, iterative linear algebra algorithms,  shared and distributed memory parallelization. It consist of two packages:</p> <ul> <li>The core C++ library xdiag</li> <li>The convenient Julia wrapper library XDiag.jl</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Please support our work by citing XDiag and the implemented algorithms if it is used in your published research.</p> <pre><code>@article{Wietek2018,\n  title = {Sublattice coding algorithm and distributed memory parallelization for large-scale exact diagonalizations of quantum many-body systems},\n  author = {Wietek, Alexander and L\\\"auchli, Andreas M.},\n  journal = {Phys. Rev. E},\n  volume = {98},\n  issue = {3},\n  pages = {033309},\n  numpages = {10},\n  year = {2018},\n  month = {Sep},\n  publisher = {American Physical Society},\n  doi = {10.1103/PhysRevE.98.033309},\n  url = {https://link.aps.org/doi/10.1103/PhysRevE.98.033309}\n}\n</code></pre>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#introduction-to-exact-diagonalization-using-xdiag","title":"Introduction to Exact Diagonalization using XDiag","text":"<p>Supporting material for lecture held at Quant24 master's school at MPI PKS. Consists of a Jupyter notebook and a sample lattice file describing the \\(N=12\\) site triangular lattice Heisenberg model:</p> <ul> <li>ed_basic_tutorial.ipynb</li> <li>triangular.12.J1J2.toml</li> </ul> <p>This notebook uses the Julia verision of XDiag and covers the basic functionality:</p> <ul> <li>How to define a Hilbert space</li> <li>How to define an operator</li> <li>How to perform a full diagonalization</li> <li>How to use \\(S^z\\) conservation</li> <li>How to use translational symmetry</li> <li>How to use iterative algorithms for sparse diagonalization</li> <li>How to compute ground state observables</li> </ul>"},{"location":"examples/#basic-examples","title":"Basic examples","text":"<ul> <li> <p> Hello World</p> <p>Prints out a greeting containing information on the version of the code.</p> <p>source </p> </li> <li> <p> Groundstate energy</p> <p>Computes the ground state energy of a simple Heisenberg spin \\(S=1/2\\) chain</p> <p>source </p> </li> </ul>"},{"location":"examples/#distributed-examples","title":"Distributed examples","text":"<ul> <li> <p> \\(t\\)-\\(J\\) time evolution</p> <p>Computes the time evolution of a state in the \\(t\\)-\\(J\\) model with distributed parallelization</p> <p>source </p> </li> </ul>"},{"location":"examples/#cmakeliststxt-for-applications","title":"CMakeLists.txt for applications","text":"<ul> <li> <p> Normal XDiag</p> <p>Template <code>CMakeLists.txt</code> which can be used to compile applications with the normal XDiag library.</p> <p>source </p> </li> <li> <p> Distributed XDiag</p> <p>Template <code>CMakeLists.txt</code> which can be used to compile applications with the distributed XDiag library.</p> <p>source </p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#julia-installation","title":"Julia Installation","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and type: <pre><code>add XDiag\n</code></pre></p> <p>That's it!</p>"},{"location":"installation/#c-compilation","title":"C++ Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. Here we explain how to compile the library.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul>"},{"location":"installation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building the Julia wrapper locally</p> <p>First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> </li> </ul>"},{"location":"installation/#building-documentation","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To work on it locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"quickstart/","title":"Quick start","text":""},{"location":"quickstart/#hello-world","title":"Hello World","text":"<p>Let us set up our first program using the <code>xdiag</code> library. </p> JuliaC++ <pre><code>using XDiag\nsay_hello()\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information which exact XDiag version is used. In Julia this is all there is to it.</p> <p>For the C++ code we need to create two files to compile the program. The first is the actual <code>C++</code> code. What is maybe a bit unfamiliar is the <code>try / catch</code> block. XDiag implements a traceback mechanism for runtime errors, which is activated by this idiom. While not stricly necessary here, it is a good practice to make use of this.</p> <p>Now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/xdiag/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our first <code>xdiag</code> application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"quickstart/#computing-the-ground-state-energy-of-a-spin-chain","title":"Computing the ground state energy of a spin chain","text":"<p>We compute the ground state energy of the \\(S=1/2\\) Heisenberg chain on a periodic chain lattice in one dimension. The Hamiltonian is given by</p> \\[ H = J\\sum_{\\langle i,j \\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j\\] <p>where \\(\\mathbf{S}_i = (S_i^x, S_i^y, S_i^z)\\) are the spin \\(S=1/2\\) operators and \\(\\langle i,j \\rangle\\) denotes summation over nearest-meighbor sites \\(i\\) and \\(j\\).</p> <p>The following code, sets up the Hilbert space, defines the Hamiltonian and finally calls an iterative eigenvalue solver to compute the ground state energy.</p> JuliaC++ <pre><code>using XDiag\n\nlet \n    N = 16\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", \"J\", [i-1, i % N])\n    end\n    ops[\"J\"] = 1.0\n\n    set_verbosity(2)            # set verbosity for monitoring progress\n    e0 = eigval0(ops, block)    # compute ground state energy\n\n    println(\"Ground state energy: $e0\")\nend\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += Op(\"HB\", \"J\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#v023","title":"v0.2.3","text":"<p>Sep. 9, 2024</p> <p>Introduced 1-indexing everywhere in Julia version</p> <ul> <li>only changes to XDiag.jl, C++ untouched</li> <li>XDiag_jll.jl remains at v0.2.2</li> </ul>"},{"location":"releases/#v022","title":"v0.2.2","text":"<p>Aug. 27, 2024</p> <p>Lanczos routines and multicolumn States</p> <ul> <li>wrapped eigs_lanczos, eigvals_lanczos</li> <li>implemented apply for States with multiple columns</li> <li>changed wrapping of std::vectors of Op and Permutation</li> </ul>"},{"location":"releases/#v021","title":"v0.2.1","text":"<p>Aug. 16, 2024</p> <p>Small patch release providing small utility functions</p> <ul> <li>wrapped say_hello, print_version, and set_verbosity</li> <li>resorted to compiling wrapper with conventional OpenMP on aarch64 apple</li> <li>Fixed faulty behaviour of OpenMP on aarch64 apple</li> </ul>"},{"location":"releases/#v020","title":"v0.2.0","text":"<p>Aug. 15, 2024</p> <p>Basic functionality for three Hilbert space types, Spinhalf, tJ, and Electron, has been implemented. Features are:</p> <ul> <li>Algebra with and without permutation symmetries</li> <li>Parallelization with OpenMP and MPI</li> <li>CMake has been properly set up</li> <li>Iterative algorithms present, Lanczos, Arnoldi, time evolution</li> <li>A minimal Julia wrapper has been written</li> <li>The Julia wrapper compiles on several target 64bit systems using BinaryBuilder</li> </ul>"},{"location":"user_guide/","title":"User guide","text":"<p>A step-by-step guide to using XDiag</p> Installation Language Julia installation How to install the XDiag in Julia C++ compilation How to compile the XDiag C++ library First steps Language Writing code How to write an application using XDiag Compilation How to compile an application using XDiag in C++ Hilbert spaces How to define a Hilbert space Operators How to define an operator Ground state How compute a ground state (energy) Measurements How to measure an observable on a state Input/Output Language TOML How to read input from a TOML file"},{"location":"documentation/","title":"Documentation","text":"<p>XDiag uses the C++ library Armadillo as a linear algebra backend. Documentation for linear algebra operations can, therefore, be found in the Armadillo Documentation.</p>"},{"location":"documentation/#algebra","title":"Algebra","text":"Name Description Language matrix Creates the full matrix representation of an operator on a block apply Applies an operator to a state \\(\\vert \\phi \\rangle = O \\vert \\psi\\rangle\\) dot Computes the dot product between two states inner Computes an expectation value \\(\\langle \\psi \\vert O \\vert \\psi \\rangle\\) norm Computes the 2-norm of a state norm1 Computes the 1-norm of a state norminf Computes the \\(\\infty\\)-norm of a state"},{"location":"documentation/#algorithms","title":"Algorithms","text":"<p>Diagonalization</p> Name Description Language eigval0 Computes the lowest lying eigenvalue of an operator eig0 Computes the lowest lying eigenvalue and eigenvector of an operator eigvals_lanczos Performs an iterative eigenvalue calculation using the Lanczos algorithm eigs_lanczos Performs an iterative eigenvalue calculation building eigenvectors using the Lanczos algorithm <p>Time evolution</p> Name Description Language time_evolve Performs a real-time evolution \\(e^{ -iHt} \\vert \\psi \\rangle\\) of a State with a given Hermitian operator \\(H\\) imaginary_time_evolve Performs a imaginary-time evolution \\(e^{ -\\tau H}\\vert\\psi\\rangle\\) of a State with a given Hermitian operator \\(H\\) evolve_lanczos Computes the exponential $e^{z H}\\vert\\psi\\rangle $ of a Hermitian operator times a State for a real or complex \\(z\\) using the Lanczos algorithm time_evolve_expokit Performs a real-time evolution \\(e^{ -iHt} \\vert \\psi \\rangle\\) using a highly accurate Lanczos algorithm"},{"location":"documentation/#blocks","title":"Blocks","text":"<p>Shared memory</p> Name Description Language Spinhalf Block of a spin \\(S=1/2\\) type Hilbert space tJ Block of a \\(t-J\\) type Hilbert space Electron Block of a Electron type Hilbert space <p>Distributed memory</p> Name Description Language SpinhalfDistributed Block of a spin \\(S=1/2\\) type Hilbert space (distributed computing) tJDistributed Block of a \\(t-J\\) type Hilbert space  (distributed computing)"},{"location":"documentation/#building","title":"Building","text":"Name Description Language Compilation Advanced settings for compilation of the C++ library using CMake Documentation How to build and work on the documentation locally Julia Wrapper How to build and develop the Julia wrapper locally"},{"location":"documentation/#input-output","title":"Input / Output","text":"<p>TOML</p> Name Description Language FileToml A file handler for TOML files read_opsum reads an OpSum from a TOML file read_permutation_group reads a PermutationGroup from a TOML file read_representation reads a Representation from a TOML file <p>HDF5</p> Name Description Language FileH5 A file handler for hdf5 files"},{"location":"documentation/#operators","title":"Operators","text":"Operator types A summary of all the operator types defined in XDiag Name Description Language Op A linear operator acting on the Hilbert space OpSum Sum of couplings times operators hc Returns the hermitian conjugate of an Op or OpSum. symmetrize Symmetrizes an operator with a PermutationGroup or Representation"},{"location":"documentation/#states","title":"States","text":"Name Description Language State A generic state describing a quantum wave function ProductState A product state of local configurations RandomState A random state with normal distributed coefficients fill Fill a state with a given model state product_state Creates a filled product state random_state Create a filled random state with normal distributed coefficients zero_state Create a filled state with all zero entries zero Set all coefficients of a given state to zero"},{"location":"documentation/#symmetries","title":"Symmetries","text":"Name Description Language Permutation Permutations of indices or lattice sites PermutationGroup A group of permutations Representation A (1D) irreducible representation of a finite group"},{"location":"documentation/#utilities","title":"Utilities","text":"Name Description Language set_verbosity Sets how much information is printed during computations say_hello Prints a nice welcome message with version number print_version Prints the plain version number Logging Controling what is written to standard output Timing Measurng wall time straightforwardly XDIAG_SHOW Macro for printing debugging information"},{"location":"documentation/algebra/algebra/","title":"Algebra routines","text":"<p>Several basic algebraic operations for states and operators.</p> <p>Sources algebra.hpp algebra.cpp algebra.jl</p>"},{"location":"documentation/algebra/algebra/#dot","title":"dot","text":"<p>Computes the dot product \\(\\langle v \\vert w \\rangle\\) between two states \\(\\vert v \\rangle\\) and \\(\\vert w \\rangle\\). In C++, please use the dotC function if one of the two states is expected to be complex.</p> C++Julia <pre><code>double dot(State const &amp;v, State const &amp;w);\ncomplex dotC(State const &amp;v, State const &amp;w);\n</code></pre> <pre><code>dot(v::State, w::State)\n</code></pre>"},{"location":"documentation/algebra/algebra/#inner","title":"inner","text":"<p>Computes the expectation value \\(\\langle v | O |v \\rangle\\) of an operator \\(O\\) and a state \\(|v\\rangle\\). The operator can either be an Op or an OpSum object. In C++, please use the innerC function if either the operator or the state are complex.</p> C++Julia <pre><code>double inner(Op const &amp;op, State const &amp;v);\ndouble inner(OpSum const &amp;ops, State const &amp;v);\ncomplex innerC(Op const &amp;op, State const &amp;v);\ncomplex innerC(OpSum const &amp;ops, State const &amp;v);\n</code></pre> <pre><code>inner(op::Op, v::State)\ninner(ops::OpSum, v::State)\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm","title":"norm","text":"<p>Computes the 2-norm \\(\\parallel |v \\rangle \\parallel_2\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_2 = \\sum_n |\\langle n | v \\rangle |^2, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norm(State const &amp;v);\n</code></pre> <pre><code>norm(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm1","title":"norm1","text":"<p>Computes the 1-norm \\(\\parallel |v \\rangle \\parallel_1\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_1 = \\sum_n |\\langle n | v \\rangle |, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norm1(State const &amp;v);\n</code></pre> <pre><code>norm1(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#norminf","title":"norminf","text":"<p>Computes the \\(\\infty\\)-norm \\(\\parallel |v \\rangle \\parallel_\\infty\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_\\infty = \\max_n |\\langle n | v \\rangle |, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norminf(State const &amp;v);\n</code></pre> <pre><code>norminf(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#usage-examples","title":"Usage Examples","text":"C++Julia <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\n\nXDIAG_SHOW(norm(psi));\nXDIAG_SHOW(norm1(psi));\nXDIAG_SHOW(norminf(psi));\n\nXDIAG_SHOW(dot(psi, psi));\nXDIAG_SHOW(e0);\nXDIAG_SHOW(inner(ops, psi));\n\nauto phi = random_state(block);\nXDIAG_SHOW(phi.vector());\nXDIAG_SHOW(psi.vector());\nXDIAG_SHOW((psi + 2.0*phi).vector());\nXDIAG_SHOW((psi*complex(0,3.0) + phi/2.0).vectorC());\n</code></pre> <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    e0, psi = eig0(ops, block);\n\n    @show norm(psi)\n    @show norm1(psi)\n    @show norminf(psi)\n    @show dot(psi, psi)\n    @show e0, inner(ops, psi)\n\n    phi = random_state(block)\n    display(vector(phi))\n    display(vector(psi))\n    display(vector(psi + 2.0*phi))\n    display(vector(psi*3.0im + phi/2.0))\nend\n</code></pre>"},{"location":"documentation/algebra/apply/","title":"apply","text":"<p>Applies an operator given as an Op or OpSum to a State \\(\\vert w \\rangle = \\mathcal{O} \\vert v\\rangle\\).</p> <p>Sources apply.hpp apply.cpp apply.jl</p>"},{"location":"documentation/algebra/apply/#definition","title":"Definition","text":"<p>An operator \\(\\mathcal{O}\\) can be applied to a state \\(\\vert v\\rangle\\) in two ways:</p> <ol> <li> <p>Only the input state on which the operator acts is defined is given. The block of the output state is calculated and eventually created automatically.</p> C++Julia <pre><code>State apply(Op const &amp;op, State const &amp;v);\nState apply(OpSum const &amp;ops, State const &amp;v);\n</code></pre> <pre><code>apply(op::Op, v::State)\napply(ops::OpSum, v::State)\n</code></pre> </li> <li> <p>The output state is also handed as an argument which is overwritten. The compatibility of quantum numbers is checked. This way the output block is not created automatically and, thus, can be used to save computation time if the output block appears repeatedly in the computation.</p> C++Julia <pre><code>void apply(Op const &amp;op, State const &amp;v, State &amp;w);\nvoid apply(OpSum const &amp;ops, State const &amp;v, State &amp;w);\n</code></pre> <pre><code>apply(op::Op, v::State, w::State)\napply(ops::OpSum, v::State, w::State)\n</code></pre> </li> </ol>"},{"location":"documentation/algebra/apply/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator v Input State $\\vert v\\rangle  $ w Output State \\(\\vert w \\rangle = O \\vert v\\rangle\\)"},{"location":"documentation/algebra/apply/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto phi = apply(Op(\"S+\", 2), psi);\nXDIAG_SHOW(inner(ops, psi));\nXDIAG_SHOW(inner(ops, phi));\n</code></pre> <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    e0, psi = eig0(ops, block);\n    phi = apply(Op(\"S+\", 2), psi)\n    @show inner(ops, psi)\n    @show inner(ops, phi)\nend\n</code></pre>"},{"location":"documentation/algebra/matrix/","title":"matrix","text":"<p>Creates a numerical matrix with real (<code>matrix</code>) or complex (<code>matrixC</code>) coefficients given an Op or OpSum on a certain block. </p> <p>Sources matrix.hpp matrix.cpp matrix.jl</p>"},{"location":"documentation/algebra/matrix/#definition","title":"Definition","text":"<p>A matrix can be created in two ways:</p> <ol> <li> <p>Only the input block on which the operator is defined is given. The output block is calculated and eventually created automatically.</p> C++Julia <pre><code>arma::mat matrix(Op const &amp;op, Block const &amp;block);\narma::mat matrix(OpSum const &amp;ops, Block const &amp;block);\narma::cx_mat matrixC(Op const &amp;op, Block const &amp;block);\narma::cx_mat matrixC(OpSum const &amp;ops, Block const &amp;block);\n</code></pre> <pre><code>matrix(op::Op, block::Block)\nmatrix(ops::OpSum, block::Block)\n</code></pre> </li> <li> <p>The output block is also handed as an argument. The compatibility of quantum numbers is checked. This way the output block is not created automatically and, thus, can be used to save computation time if the output block appears repeatedly in the computation.</p> C++Julia <pre><code>arma::mat matrix(Op const &amp;op, Block const &amp;block_in, Block const &amp;block_out);\narma::mat matrix(OpSum const &amp;ops, Block const &amp;block_in, Block const &amp;block_out);\narma::cx_mat matrixC(Op const &amp;op, Block const &amp;block_in, Block const &amp;block_out);\narma::cx_mat matrixC(OpSum const &amp;ops, Block const &amp;block_in, Block const &amp;block_out);\n</code></pre> <pre><code>matrix(op::Op, block_in::Block, block_out::Block)\nmatrix(ops::OpSum, block_in::Block, block_out::Block)\n</code></pre> </li> </ol> <p>Comment: In Julia, depending on whether a real/complex matrix is generated also a  real/complex matrix is returned. The C++ version has to return a fixed type. If a real matrix is desired, use the function <code>matrix</code>. If a complex matrix is desired, use the function <code>matrixC</code>.</p>"},{"location":"documentation/algebra/matrix/#parameters","title":"Parameters","text":"Name Description ops OpSum or Op defining the operator block / block_in input block on which the operator is defined block_out output block the operator maps the input block to"},{"location":"documentation/algebra/matrix/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>// Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\nint N = 4;\nint nup = 3;\nint ndn = 2;\n\n// Define a Hubbard chain model\nauto ops = OpSum();\nfor (int i=0; i&lt; N; ++i){\n  ops += \"T\" * Op(\"Hop\", {i, (i+1) % N});\n}\nops+= \"U\" * Op(\"HubbardU\");\nops[\"T\"] = 1.0;\nops[\"U\"] = 5.0;\n\n// Create the a permutation group\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1.0, -1.0, 1.0, -1.0});\nauto block = Electron(N, nup, ndn, irrep);\nauto H = matrix(ops, block);\nH.print();\n</code></pre> <pre><code>let\n    # Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\n    N = 4\n    nup = 3\n    ndn = 2\n\n    # Define a Hubbard chain model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"T\" * Op(\"Hop\", [i, mod1(i+1, N)])\n    end\n    ops += \"U\" * Op(\"HubbardU\")\n    ops[\"T\"] = 1.0;\n    ops[\"U\"] = 5.0;\n\n    # Create the a permutation group\n    p = Permutation([2, 3, 4, 1])\n    group = PermutationGroup([p^0, p^1, p^2, p^3])\n    irrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\n    block = Electron(N, nup, ndn, irrep)\n\n    H = matrix(ops, block)\n    display(H)\nend\n</code></pre>"},{"location":"documentation/algorithms/eig0/","title":"eig0","text":"<p>Computes the groud state energy and the ground state of a Hermitian operator on a block by using an iterative Lanczos algorithm. This function is a shortcut for the eigs_lanczos function. We refer to eigs_lanczos for further details on the algorithm and the convergence criterion.</p> <p>Sources sparse_diag.hpp sparse_diag.cpp sparse_diag.jl</p>"},{"location":"documentation/algorithms/eig0/#definition","title":"Definition","text":"C++Julia <pre><code>std::tuple&lt;double, State&gt; eig0(OpSum const &amp;ops, Block const &amp;block,\n    double precision = 1e-12, int64_t max_iterations = 1000, \n    int64_t random_seed = 42);\n</code></pre> <pre><code>eig0(ops::OpSum, block::Block;  precision::Float64 = 1e-12, \n     max_iterations::Int64 = 1000, random_seed::Int64 = 42)\n</code></pre>"},{"location":"documentation/algorithms/eig0/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining a Hermitian operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eig0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue of <code>ops</code> State groundstate"},{"location":"documentation/algorithms/eig0/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\nauto [e0, gs] = eig0(ops, block);\n</code></pre> <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n    e0, gs = eig0(ops, block);\nend\n</code></pre>"},{"location":"documentation/algorithms/eigs_lanczos/","title":"eigs_lanczos","text":"<p>Performs an iterative eigenvalue calculation building eigenvectors using the Lanczos algorithm. Returns the tridiagonal matrix, eigenvalues, number of iterations and the stopping criterion. The Lanczos interations are performed twice, where at the second run the eigenvectors are built.</p> <p>Sources eigs_lanczos.hpp eigs_lanczos.cpp eigs_lanczos.jl</p>"},{"location":"documentation/algorithms/eigs_lanczos/#definition","title":"Definition","text":"<p>The Lanczos algorithm can be run in two distinct ways:</p> <ol> <li> <p>A random intial state \\(|\\psi_0\\rangle = |r\\rangle\\) with normal distributed entries is used.</p> C++Julia <pre><code>EigsLanczosResult\neigs_lanczos(OpSum const &amp;ops, Block const &amp;block, int64_t neigvals = 1,\n             double precision = 1e-12, int64_t max_iterations = 1000,\n             double deflation_tol = 1e-7, int64_t random_seed = 42);\n</code></pre> <pre><code>eigs_lanczos(ops::OpSum, block::Block; neigvals::Int64 = 1,\n             precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n             deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified</p> C++ <p><pre><code>EigsLanczosResult \neigs_lanczos(OpSum const &amp;ops, State const &amp;psi0, int64_t neigvals = 1,\n             double precision = 1e-12, int64_t max_iterations = 1000,\n             double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigs_lanczos(ops::OpSum, psi0::State; neigvals::Int64 = 1,\n             precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n             deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre></p> </li> </ol>"},{"location":"documentation/algorithms/eigs_lanczos/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining the bonds of the operator block block on which the operator is defined psi0 Initial State from which the Lanczos algorithm is started neigvals number of eigenvalues to converge 1 precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigs_lanczos/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description alphas diagonal elements of the tridiagonal matrix betas off-diagonal elements of the tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix eigenvectors State of shape $D \\times $<code>neigvals</code> holding all low-lying eigenvalues up to <code>neigvals</code> niterations number of iterations performed criterion string denoting the reason why the algorithm stopped"},{"location":"documentation/algorithms/eigs_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm terminates if the \\(k\\)-th (\\(k\\) is the argument <code>neigvals</code>) approximate eigenvalue changes only by a fraction smaller than \\(\\epsilon\\) (\\(k\\) is the argument <code>precision</code>), i.e.</p> \\[ (\\tilde{e}_k^{(n)} - \\tilde{e}_k^{(n-1)}) / \\tilde{e}_k^{(n)} &lt; \\epsilon.\\] <p>Here, \\(\\tilde{e}_k^{(n)}\\) denotes the Lanczos approximation to the \\(k\\)-th eigenvalue after \\(n\\) iterations.</p>"},{"location":"documentation/algorithms/eigs_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n\n// With random intial state\nauto res = eigs_lanczos(ops, block);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\nXDIAG_SHOW(res.eigenvectors);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    # With random intial state\n    res = eigs_lanczos(ops, block)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\n    @show res.eigenvectors\nend\n</code></pre>"},{"location":"documentation/algorithms/eigval0/","title":"eigval0","text":"<p>Computes the groud state energy of a Hermitian operator on a block by using an iterative Lanczos algorithm. This function is a shortcut for the eigvals_lanczos function. We refer to eigvals_lanczos for further details on the algorithm and the convergence criterion.</p> <p>Sources sparse_diag.hpp sparse_diag.cpp sparse_diag.jl</p>"},{"location":"documentation/algorithms/eigval0/#definition","title":"Definition","text":"C++Julia <pre><code>double eigval0(OpSum const &amp;ops, Block const &amp;block, double precision = 1e-12,\n               int64_t max_iterations = 1000, int64_t random_seed = 42);\n</code></pre> <pre><code>eigval0(ops::OpSum, block::Block;   precision::Float64 = 1e-12, \n        max_iterations::Int64 = 1000, random_seed::Int64 = 42)::Float64\n</code></pre>"},{"location":"documentation/algorithms/eigval0/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining a Hermitian operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigval0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue of <code>ops</code>"},{"location":"documentation/algorithms/eigval0/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\ndouble e0 = eigval0(ops, block);\n</code></pre> <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n    e0 = eigval0(ops, block);\nend\n</code></pre>"},{"location":"documentation/algorithms/eigvals_lanczos/","title":"eigvals_lanczos","text":"<p>Performs an iterative eigenvalue calculation using the Lanczos algorithm. Returns the tridiagonal matrix, eigenvalues, number of iterations and the stopping criterion.</p> <p>Sources eigvals_lanczos.hpp eigvals_lanczos.cpp eigvals_lanczos.jl</p>"},{"location":"documentation/algorithms/eigvals_lanczos/#definition","title":"Definition","text":"<p>The Lanczos algorithm can be run in thre distinct ways:</p> <ol> <li> <p>A random intial state \\(|\\psi_0\\rangle = |r\\rangle\\) with normal distributed entries is used.</p> C++Julia <pre><code>EigvalsLanczosResult\neigvals_lanczos(OpSum const &amp;ops, Block const &amp;block, int64_t neigvals = 1,\n                double precision = 1e-12, int64_t max_iterations = 1000,\n                double deflation_tol = 1e-7, int64_t random_seed = 42);\n</code></pre> <pre><code>eigvals_lanczos(ops::OpSum, block::Block; neigvals::Int64 = 1, \n                precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified. </p> C++Julia <pre><code>EigvalsLanczosResult \neigvals_lanczos(OpSum const &amp;ops, State psi0, int64_t neigvals = 1,\n                double precision = 1e-12, int64_t max_iterations = 1000,\n                double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigvals_lanczos(ops::OpSum, psi0::State; neigvals::Int64 = 1, \n                precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                deflation_tol::Float64 = 1e-7)\n</code></pre> <p>Notice this version copies the initial state, which requires memory but keeps the orginal state intact.</p> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified and overwritten in the process. This version can save memory, but the initial state  \\(|\\psi_0\\rangle\\) cannot be used later.</p> C++Julia <pre><code>EigvalsLanczosResult \neigvals_lanczos_inplace(OpSum const &amp;ops, State &amp;psi0, int64_t neigvals = 1,\n                        double precision = 1e-12, int64_t max_iterations = 1000,\n                        double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigvals_lanczos_inplace(ops::OpSum, psi0::State; neigvals::Int64 = 1, \n                        precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                        deflation_tol::Float64 = 1e-7)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/eigvals_lanczos/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining the bonds of the operator block block on which the operator is defined psi0 Initial State from which the Lanczos algorithm is started neigvals number \\(k\\) of eigenvalue to converge 1 precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigvals_lanczos/#returns","title":"Returns","text":"<p>A struct of type <code>EigvalsLanczosResult</code> with the following entries.</p> Entry Description alphas diagonal elements of the tridiagonal matrix betas off-diagonal elements of the tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix niterations number of iterations performed criterion string denoting the reason why the algorithm stopped"},{"location":"documentation/algorithms/eigvals_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm terminates if the \\(k\\)-th (\\(k\\) is the argument <code>neigvals</code>) approximate eigenvalue changes only by a fraction smaller than \\(\\epsilon\\) (\\(k\\) is the argument <code>precision</code>), i.e.</p> \\[ (\\tilde{e}_k^{(n)} - \\tilde{e}_k^{(n-1)}) / \\tilde{e}_k^{(n)} &lt; \\epsilon.\\] <p>Here, \\(\\tilde{e}_k^{(n)}\\) denotes the Lanczos approximation to the \\(k\\)-th eigenvalue after \\(n\\) iterations.</p>"},{"location":"documentation/algorithms/eigvals_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n\n// With random intial state\nauto res = eigvals_lanczos(ops, block);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\n\n// With specific initial state\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\nauto res2 = eigvals_lanczos(ops, psi0);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    # With random intial state\n    res = eigvals_lanczos(ops, block)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\n\n    # With specific initial state\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    res2 = eigvals_lanczos(ops, psi0)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\nend\n</code></pre>"},{"location":"documentation/algorithms/evolve_lanczos/","title":"evolve_lanczos","text":"<p>Computes the exponential of a Hermitian operator \\(H\\) with an arbitrary real or complex prefactor \\(z\\) applied to a State \\(\\vert \\psi_0\\rangle\\), </p> \\[\\vert \\psi(z) \\rangle = e^{z(H - \\delta)} \\vert \\psi_0\\rangle.\\] <p>Here, \\(\\delta\\) denotes a real number shifting the spectrum of \\(H\\). The algorithm implemented is described in the following publication.</p> <p>On Krylov Subspace Approximations to the Matrix Exponential Operator Marlis Hochbruck and Christian Lubich SIAM Journal on Numerical Analysis, Vol. 34, Iss. 5 (1997) DOI: 10.1137/S0036142995280572</p> <p>Sources evolve_lanczos.hpp evolve_lanczos.cpp evolve_lanczos.jl</p>"},{"location":"documentation/algorithms/evolve_lanczos/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>EvolveLanczosResult\nevolve_lanczos(OpSum const &amp;H, State psi, double t, double precision = 1e-12,\n               double shift = 0., bool normalize = false,\n               int64_t max_iterations = 1000, double deflation_tol = 1e-7);\n\nEvolveLanczosResult\nevolve_lanczos(OpSum const &amp;H, State psi, complex z, double precision = 1e-12,\n               double shift = 0., bool normalize = false,\n               int64_t max_iterations = 1000, double deflation_tol = 1e-7);\n</code></pre> <pre><code>evolve_lanczos(H::OpSum, psi::State, t::Float64; precision::Float64 = 1e-12,\n               shift::Float64=0.0, normalize::Bool=false,\n               max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n\nevolve_lanczos(H::OpSum, psi::State, z::ComplexF64; precision::Float64 = 1e-12,\n               shift::Float64=0.0, normalize::Bool=false,\n               max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n</code></pre> </li> <li> <p>An inplace variant <code>evolve_lanczos_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>evolve_lanczos</code>.</p> C++Julia <pre><code>EvolveLanczosInplaceResult\nevolve_lanczos_inplace(OpSum const &amp;H, State &amp;psi, double t, \n                       double precision = 1e-12, double shift = 0.,\n                       bool normalize = false, int64_t max_iterations = 1000, \n                       double deflation_tol = 1e-7);\n\nEvolveLanczosInplaceResult\nevolve_lanczos_inplace(OpSum const &amp;H, State &amp;psi, complex z, \n                       double precision = 1e-12, double shift = 0.,\n                       bool normalize = false, int64_t max_iterations = 1000, \n                       double deflation_tol = 1e-7);\n</code></pre> <pre><code>evolve_lanczos_inplace(H::OpSum, psi::State, t::Float64; precision::Float64 = 1e-12,\n                       shift::Float64=0.0, normalize::Bool=false,\n                       max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n\nevolve_lanczos_inplace(H::OpSum, psi::State, z::ComplexF64; precision::Float64 = 1e-12,\n                       shift::Float64=0.0, normalize::Bool=false,\n                       max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/evolve_lanczos/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(\\tau\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(t) \\rangle\\) 1e-12 shift the offset \\(\\delta\\) when computing \\(\\vert \\psi(t) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle\\) 0.0 normalize flag whether or not the evolved state should be normalized false max_iterations maximum number of Lanczos iterations performed 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 <p>The parameter <code>shift</code> can be used to turn all eigenvalues of the matrix \\(H - \\delta \\;\\textrm{Id}\\) positive whenever \\(\\delta &lt; E_0\\), where \\(E_0\\) denotes the ground state energy of \\(H\\).</p>"},{"location":"documentation/algorithms/evolve_lanczos/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description alphas diagonal elements of the Lanczos tridiagonal matrix betas off-diagonal elements of the Lanczos tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix niterations number of iterations performed criterion string denoting the reason why the Lanczosalgorithm stopped state time-evolved State \\(\\vert \\psi(t)\\rangle\\) (not defined for inplace variant)"},{"location":"documentation/algorithms/evolve_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm is estimating the following error,</p> \\[ \\varepsilon = \\parallel \\vert \\tilde{\\psi}(t)\\rangle - e^{z(H - \\delta)} \\vert \\psi_0\\rangle \\parallel_2, \\] <p>where \\(\\vert \\tilde{\\psi}(t) \\rangle\\) denotes the approximation computed during the algorithm. As the exact solution is not available this error is estimated using the method described by Algorithm 2 in</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p>"},{"location":"documentation/algorithms/evolve_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\n// Compute ground state energy\ndouble e0 = eigval0(ops, block);\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-12;\nauto res = evolve_lanczos(ops, psi0, time, precision, e0, true, 500);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    # Compute ground state energy\n    e0 = eigval0(ops, block)\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    res = evolve_lanczos(ops, psi0, time, precision=1e-12, shift=e0, normalize=true)\n    @show res.alphas\n    @show res.betas\nend\n</code></pre>"},{"location":"documentation/algorithms/imaginary_time_evolve/","title":"imaginary_time_evolve","text":"<p>Computes the imaginary-time evolution, </p> \\[\\vert \\psi(\\tau) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using an iterative algorithm. \\(\\delta\\) here denotes a real number which can be chosen as the ground state energy \\(\\delta=E_0\\) of \\(H\\).</p> <p>Sources imaginary_time_evolve.hpp imaginary_time_evolve.cpp imaginary_time_evolve.jl</p>"},{"location":"documentation/algorithms/imaginary_time_evolve/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>State imaginary_time_evolve(OpSum const &amp;H, State psi0, double time,\n                            double precision = 1e-12, double shift = 0.);\n</code></pre> <pre><code>imaginary_time_evolve(ops::OpSum, psi0::State, time::Float64; precision::Float64 = 1e-12, \n                      shift::Float64=0.0)::State\n</code></pre> </li> <li> <p>An inplace variant <code>imaginary_time_evolve_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>imaginary_time_evolve</code>.</p> C++Julia <pre><code>void imaginary_time_evolve_inplace(OpSum const &amp;H, State &amp;psi0, double time,\n                                   double precision = 1e-12, shift = 0.);\n</code></pre> <pre><code>imaginary_time_evolve_inplace(ops::OpSum, psi0::State, time::Float64; \n                              precision::Float64 = 1e-12, shift::Float64=0.0)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/imaginary_time_evolve/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(\\tau\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(\\tau) \\rangle\\) 1e-12 shift the offset \\(\\delta\\) when computing \\(\\vert \\psi(t) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle\\) 0.0 <p>The routine calls the subroutine evolve_lanczos implementing a Lanczos algorithm to perform the evolution. This routine can also be called explicitly if more control is desired. Please also confer to the page evolve_lanczos for further details on the specifics of the algorithm. The parameter <code>shift</code> can be used to turn all eigenvalues of the matrix \\(H - \\delta \\;\\textrm{Id}\\) positive whenever \\(\\delta &lt; E_0\\), where \\(E_0\\) denotes the ground state energy of \\(H\\).</p>"},{"location":"documentation/algorithms/imaginary_time_evolve/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\n// Compute ground state energy\ndouble e0 = eigval0(ops, block);\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-12;\nauto psi = imaginary_time_evolve(ops, psi0, time, precision, e0);\nimaginary_time_evolve_inplace(ops, psi0, time, precision, e0);\nXDIAG_SHOW(isapprox(psi0, psi));\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    # Compute ground state energy\n    e0 = eigval0(ops, block)\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    psi = imaginary_time_evolve(ops, psi0, time,\n                                precision=1e-12, shift=e0)\n    imaginary_time_evolve_inplace(ops, psi0, time, precision=1e-12, shift=e0)\n    @show isapprox(psi0, psi)\nend\n</code></pre>"},{"location":"documentation/algorithms/time_evolve/","title":"time_evolve","text":"<p>Computes the real-time evolution, </p> \\[\\vert \\psi(t) \\rangle = e^{-iHt} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using an iterative algorithm. </p> <p>Sources time_evolve.hpp time_evolve.cpp time_evolve.jl</p>"},{"location":"documentation/algorithms/time_evolve/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>State time_evolve(OpSum const &amp;H, State psi0, double time,\n                  double precision = 1e-12,\n                  std::string algorithm = \"lanczos\");\n</code></pre> <pre><code>time_evolve(ops::OpSum, psi0::State, time::Float64; \n            precision::Float64 = 1e-12, \n            algorithm::String = \"lanczos\")::State\n</code></pre> </li> <li> <p>An inplace variant <code>time_evolve_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>time_evolve</code>.</p> C++Julia <pre><code>void time_evolve_inplace(OpSum const &amp;H, State &amp;psi0, double time,\n                         double precision = 1e-12,\n                         std::string algorithm = \"lanczos\");\n</code></pre> <pre><code>time_evolve_inplace(ops::OpSum, psi0::State, time::Float64; \n                    precision::Float64 = 1e-12, \n                    algorithm::String = \"lanczos\")\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/time_evolve/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(t\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(t) \\rangle\\) 1e-12 algorithm iterative algorithm which is used, one of <code>lanczos</code> or <code>expokit</code> <code>lanczos</code> <p>The <code>algorithm</code> parameter decised which backend is run. If <code>lanczos</code> is chosen, the evolve_lanczos routine is called with the standard arguments. Alternatively, <code>expokit</code> chooses the time_evolve_expokit routine. For a detailed documentation of the algorithms we refer to the evolve_lanczos and time_evolve_expokit pages. Broadly speaking, the <code>expokit</code> can yield higher precision states at arbitrarily long times at the cost of increased memory and computing time. In practice, we recommend analysing the effect of the <code>precision</code> parameters on the time evolution series obtained in both cases. </p>"},{"location":"documentation/algorithms/time_evolve/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\nauto psi = time_evolve(ops, psi0, time);\ntime_evolve_inplace(ops, psi0, time);\nXDIAG_SHOW(isapprox(psi0, psi));\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    psi = time_evolve(ops, psi0, time)\n    time_evolve_inplace(ops, psi0, time)\n    @show isapprox(psi0, psi)\nend\n</code></pre>"},{"location":"documentation/algorithms/time_evolve_expokit/","title":"time_evolve_expokit","text":"<p>Computes the real-time evolution, </p> \\[\\vert \\psi(t) \\rangle = e^{-iHt} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using the iterative algorithm implemented by Expokit</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p> <p>The algorithm features automatic stepsize control and computes approximate solutions with high precision according to our tests. Yet, the evolve_lanczos implementation is currently faster and more memory efficient. </p> <p>Sources time_evolve_expokit.hpp time_evolve_expokit.cpp time_evolve_expokit.jl</p>"},{"location":"documentation/algorithms/time_evolve_expokit/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>TimeEvolveExpokitResult time_evolve_expokit(\n    OpSum const &amp;ops, State state, double time, double precision = 1e-12,\n    int64_t m = 30, double anorm = 0., int64_t nnorm = 2);\n</code></pre> <pre><code>time_evolve_expokit(ops::OpSum, state::State, time::Float64;\n                    precision::Float64=1e-12, m::Int64 = 30, \n                    anorm::Float64 = 0.0, nnorm::Int64 = 2)\n</code></pre> </li> <li> <p>An inplace variant <code>time_evolve_expokit_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>time_evolve_expokit</code>.</p> C++Julia <pre><code>TimeEvolveExpokitInplaceResult time_evolve_expokit_inplace(\n    OpSum const &amp;ops, State &amp;state, double time, double precision = 1e-12,\n    int64_t m = 30, double anorm = 0., int64_t nnorm = 2);\n</code></pre> <pre><code>time_evolve_expokit_inplace(ops::OpSum, state::State, time::Float64;\n                            precision::Float64=1e-12, m::Int64 = 30, \n                            anorm::Float64 = 0.0, nnorm::Int64 = 2)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/time_evolve_expokit/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(t\\) until which the state is evolved precision accuracy of the computed time evolved state 1e-12 m dimension of used Krylov space, main memory requirement 30 anorm 1-norm estimate of the operator \\(H\\), if unknown default 0. computes it fresh 0. nnorm number of random samples to estimate 1-norm, usually not more than 2 required 2"},{"location":"documentation/algorithms/time_evolve_expokit/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description error the computed error estimate during evolution hump the \"hump\" as defined in Expokit 10.1145/285861.285868 state time-evolved State \\(\\vert \\psi(t)\\rangle\\) (not defined for inplace variant)"},{"location":"documentation/algorithms/time_evolve_expokit/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm is estimating the following error,</p> \\[ \\varepsilon = \\parallel \\vert \\tilde{\\psi}(t)\\rangle - e^{z(H - \\delta)} \\vert \\psi_0\\rangle \\parallel_2, \\] <p>where \\(\\vert \\tilde{\\psi}(t) \\rangle\\) denotes the approximation computed during the algorithm. As the exact solution is not available this error is estimated using the method described by Algorithm 2 in</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p>"},{"location":"documentation/algorithms/time_evolve_expokit/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-8;\nauto res1 = time_evolve_expokit(ops, psi0, time, precision);\nauto res2 = time_evolve_expokit_inplace(ops, psi0, time, precision);\nXDIAG_SHOW(isapprox(psi0, res1.state));\nXDIAG_SHOW(res1.error);\nXDIAG_SHOW(res1.hump);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    res1 = time_evolve_expokit(ops, psi0, time, precision=1e-8)\n    res2 = time_evolve_expokit_inplace(ops, psi0, time, precision=1e-8)\n    @show isapprox(psi0, res1.state)\n    @show res1.error\n    @show res1.hump\nend\n</code></pre>"},{"location":"documentation/blocks/electron/","title":"Electron","text":"<p>A block in an Electron (fermions with \\(\\uparrow, \\downarrow\\) spin) Hilbert space. </p> <p>Sources electron.hpp, electron.cpp</p>"},{"location":"documentation/blocks/electron/#constructors","title":"Constructors","text":"C++Julia <pre><code>Electron(int64_t nsites, std::string backend = \"auto\");\nElectron(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\nElectron(int64_t nsites, Representation irrep, std::string backend = \"auto\");\nElectron(int64_t nsites, int64_t nup, int64_t ndn, Representation irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>Electron(nsites::Int64, backend::String=\"auto\")\nElectron(nsites::Int64, nup::Int64, ndn::Int64, backend::String=\"auto\")\nElectron(nsites::Int64, irrep::Representation, backend::String=\"auto\")\nElectron(nsites::Int64, nup::Int64, ndn::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code></p>"},{"location":"documentation/blocks/electron/#iteration","title":"Iteration","text":"<p>An Electron block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = Electron(4, 2, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre> <pre><code>block = Electron(4, 2, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/electron/#methods","title":"Methods","text":""},{"location":"documentation/blocks/electron/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJ block.</p> C++Julia <pre><code>int64_t index(tJ const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::tJ, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/electron/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(tJ const &amp;block);\n</code></pre> <pre><code>nsites(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(tJ const &amp;block) const;\n</code></pre> <pre><code>size(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(tJ const &amp;block) const;\n</code></pre> <pre><code>dim(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(tJ const &amp;block);\n</code></pre> <pre><code>isreal(block::tJ)::Bool\n</code></pre>"},{"location":"documentation/blocks/electron/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without number conservation\nauto block = Electron(N);\nXDIAG_SHOW(block);\n\n// with number conservation\nauto block_np = Electron(N, nup, ndn);\nXDIAG_SHOW(block_np);\n\n// with symmetries, without number conservation\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1, -1, 1, -1});\nauto block_sym = Electron(N, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and number conservation\nauto block_sym_np = Electron(N, nup, ndn, irrep);\nXDIAG_SHOW(block_sym_np);\nXDIAG_SHOW(block_sym_np.nsites());\nXDIAG_SHOW(block_sym_np.size());\n\n// Iteration\nfor (auto pstate : block_sym_np) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym_np, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without number conservation\nblock = Electron(N)\n@show block\n\n# with number conservation\nblock_np = Electron(N, nup, ndn)\n@show block_np\n\n# with symmetries, without number conservation\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = Electron(N, rep)\n@show block_sym\n\n# with symmetries and number conservation\nblock_sym_np = Electron(N, nup, ndn, rep)\n@show block_sym_np\n@show nsites(block_sym_np)\n@show size(block_sym_np)\n\n# Iteration\nfor pstate in block_sym_np\n    @show pstate, index(block_sym_np, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf/","title":"Spinhalf","text":"<p>A block in a spin \\(S=1/2\\)  Hilbert space. </p> <p>Sources spinhalf.hpp spinhalf.cpp spinhalf.jl</p>"},{"location":"documentation/blocks/spinhalf/#constructors","title":"Constructors","text":"C++Julia <pre><code>Spinhalf(int64_t nsites, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, int64_t nup, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, Representation const &amp;irrep, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, int64_t nup, Representation const &amp;irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>Spinhalf(nsites::Int64, backend::String=\"auto\")\nSpinhalf(nsites::Int64, nup::Int64, backend::String=\"auto\")\nSpinhalf(nsites::Int64, irrep::Representation, backend::String=\"auto\")\nSpinhalf(nsites::Int64, nup::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" spin setting spin (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>, <code>1sublattice</code>, <code>2sublattice</code>, <code>3sublattice</code>, <code>4sublattice</code>, and <code>5sublattice</code>. The backends <code>xsublattice</code> implement the sublattice coding algorithm described in Wietek, L\u00e4uchli, Phys. Rev. E 98, 033309 (2018). The sublattice coding algorithms impose certain constraints on the symmetries used, as described in the reference. </p>"},{"location":"documentation/blocks/spinhalf/#iteration","title":"Iteration","text":"<p>An Spinhalf block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = Spinhalf(4, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre> <pre><code>block = Spinhalf(4, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#methods","title":"Methods","text":""},{"location":"documentation/blocks/spinhalf/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the Spinhalf block.</p> C++Julia <pre><code>int64_t index(Spinhalf const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::Spinhalf, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/spinhalf/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(Spinhalf const &amp;block);\n</code></pre> <pre><code>nsites(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(Spinhalf const &amp;block) const;\n</code></pre> <pre><code>size(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(Spinhalf const &amp;block) const;\n</code></pre> <pre><code>dim(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(Spinhalf const &amp;block);\n</code></pre> <pre><code>isreal(block::Spinhalf)::Bool\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\n\n// without Sz conservation\nauto block = Spinhalf(N);\nXDIAG_SHOW(block);\n\n// with Sz conservation\nauto block_sz = Spinhalf(N, nup);\nXDIAG_SHOW(block_sz);\n\n// with symmetries, without Sz\nPermutation p1 = {0, 1, 2, 3};\nPermutation p2 = {1, 2, 3, 0};\nPermutation p3 = {2, 3, 0, 1};\nPermutation p4 = {3, 0, 1, 2};\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec({1, -1, 1, -1}));\nauto block_sym = Spinhalf(N, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and Sz\nauto block_sym_sz = Spinhalf(N, nup, irrep);\nXDIAG_SHOW(block_sym_sz);\n\nXDIAG_SHOW(block_sym_sz.nsites());\nXDIAG_SHOW(block_sym_sz.size());\n\n// Iteration\nfor (auto pstate : block_sym_sz) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym_sz, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\n\n# without Sz conservation\nblock = Spinhalf(N)\n@show block\n\n# with Sz conservation\nblock_sz = Spinhalf(N, nup)\n@show block_sz\n\n# with symmetries, without Sz\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = Spinhalf(N, rep)\n@show block_sym\n\n# with symmetries and Sz\nblock_sym_sz = Spinhalf(N, nup, rep)\n@show block_sym_sz\n@show nsites(block_sym_sz)\n@show size(block_sym_sz)\n\n# Iteration\nfor pstate in block_sym_sz\n    @show pstate, index(block_sym_sz, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/","title":"SpinhalfDistributed","text":"<p>A block in a spin \\(S=1/2\\) Hilbert space with distributed computing capabilities.</p> <p>Sources spinhalf_distributed.hpp, spinhalf_distributed.cpp</p>"},{"location":"documentation/blocks/spinhalf_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>SpinhalfDistributed(int64_t nsites, int64_t nup, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" spin setting spin (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/spinhalf_distributed/#iteration","title":"Iteration","text":"<p>An SpinhalfDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = SpinhalfDistributed(4, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/spinhalf_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the SpinhalfDistributed block.</p> C++ <pre><code>int64_t index(SpinhalfDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(SpinhalfDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(SpinhalfDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(SpinhalfDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(SpinhalfDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/tJ/","title":"tJ","text":"<p>A block in a  \\(t-J\\) type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin excluding doubly occupied sites. </p> <p>Sources tj.hpp tj.cpp tj.jl</p>"},{"location":"documentation/blocks/tJ/#constructors","title":"Constructors","text":"C++Julia <pre><code>tJ(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\ntJ(int64_t nsites, int64_t nup, int64_t ndn, Representation const &amp;irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>tJ(nsites::Int64, nup::Int64, ndn::Int64, backend::String=\"auto\")\ntJ(nsites::Int64, nup::Int64, ndn::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/tJ/#iteration","title":"Iteration","text":"<p>An tJ block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = tJ(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre> <pre><code>block = tJ(4, 2, 1)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/tJ/#methods","title":"Methods","text":""},{"location":"documentation/blocks/tJ/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJ block.</p> C++Julia <pre><code>int64_t index(tJ const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::tJ, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/tJ/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(tJ const &amp;block);\n</code></pre> <pre><code>nsites(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(tJ const &amp;block) const;\n</code></pre> <pre><code>size(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(tJ const &amp;block) const;\n</code></pre> <pre><code>dim(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(tJ const &amp;block);\n</code></pre> <pre><code>isreal(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without permutation symmetries\nauto block = tJ(N, nup, ndn);\nXDIAG_SHOW(block);\n\n// with permutation symmetries\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1, -1, 1, -1});\nauto block_sym = tJ(N, nup, ndn, irrep);\nXDIAG_SHOW(block_sym);\nXDIAG_SHOW(block_sym.nsites());\nXDIAG_SHOW(block_sym.size());\n\n// Iteration\nfor (auto pstate : block_sym) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without permutation symmetries\nblock = tJ(N, nup, ndn)\n@show block\n\n# with permutation symmetries\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = tJ(N, nup, ndn, rep)\n@show block_sym\n\n@show nsites(block_sym)\n@show size(block_sym)\n\n# Iteration\nfor pstate in block_sym\n    @show pstate, index(block_sym, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/","title":"tJDistributed","text":"<p>A block in a  \\(t-J\\) type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin excluding doubly occupied sites with distributed computing capabilities. </p> <p>Sources tj_distributed.hpp, tj_distributed.cpp</p>"},{"location":"documentation/blocks/tJ_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>tJDistributed(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/tJ_distributed/#iteration","title":"Iteration","text":"<p>An tJDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = tJDistributed(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/tJ_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJDistributed block.</p> C++ <pre><code>int64_t index(tJDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(tJDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(tJDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(tJDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(tJDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/compilation/advanced_compilation/","title":"Compilation","text":""},{"location":"documentation/compilation/advanced_compilation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul>"},{"location":"documentation/compilation/advanced_compilation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Shared / Static libraries</p> <p>XDiag can be built either as a static or shared library. By default, a static library is built. To build a shared library, use the option XDIAG_SHARED_LIBS, e.g. <pre><code>cmake -S . -B build -D XDIAG_SHARED_LIBS=On\n</code></pre> Typically, shared libraries can reduce the size of the executable and are often prefered. However, when building an application and linking to a static library, the resulting binary can be used standalone, without the shared library needing to be loaded. This means once an application code is compiled, it will run the same way indefinitely, even if the XDiag library changes. Thus, it is mostly more convenient to link against the static library.</p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> </ul>"},{"location":"documentation/compilation/advanced_compilation/#optimization","title":"Optimization","text":"<p>missing documentation</p>"},{"location":"documentation/compilation/building_documentation/","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To install it please run the following commands, <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre></p> <p>To work on the documentation locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"documentation/compilation/julia_wrapper/","title":"Building the Julia wrapper","text":"<p>In order to develop and extend the julia wrapper, one should work locally and build a local version of the <code>xdiag</code> Julia binaries. First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> <p>In order to test the new shared library <code>xdiagjl</code> together with the <code>XDiag.jl</code> library, we need to override the artifact associated with the <code>XDiag_jll.jl</code> package. For this, first we need to find out which artifact is associated with <code>XDiag_jll.jl</code>. For this enter julia and type the following commands:</p> <pre><code>julia\nusing XDiag_jll\nXDiag_jll.find_artifact_dir()\n</code></pre> <p>This gives the directory in which the artifact is defined. Now we have to add a line in the <code>Overrides.toml</code> file, typically located at <code>.julia/artifacts/Overrides.toml</code>.</p> <p>Here, we then add a line like this:</p> <pre><code>55ec928f6054024a4e9bf02e74e4da8b69175655 = \"/path/to/xdiag/install\"\n</code></pre> <p>The hash is to be replaced by the directory of the <code>XDiag_jll.jl</code> artifact.</p>"},{"location":"documentation/io/file_h5/","title":"FileH5","text":"<p>A file handler for hdf5 files. The proper tool to write results of XDiag simulations to disk. Only provided for the C++ version as Julia already provides good tools handling hdf5 files.</p> <p>Sources file_h5.hpp, file_h5.cpp</p>"},{"location":"documentation/io/file_h5/#constructors","title":"Constructors","text":"C++ <pre><code>FileH5(std::string filename, std::string iomode = \"w\");\n</code></pre> Name Description Default filename filename of the hdf5 file iomode whether to read or write to file <code>w</code> <p>There are four possible values of <code>iomode</code></p> <ol> <li><code>r</code>: read-only mode</li> <li><code>w</code>: secure write mode, new file is created if it does not exist</li> <li><code>w!</code>: forced write mode, existing file will be overwritten</li> <li><code>a</code>: append mode, new datasets in an existing file can be created</li> </ol>"},{"location":"documentation/io/file_h5/#methods","title":"Methods","text":""},{"location":"documentation/io/file_h5/#getindex-operator","title":"getindex / operator[]","text":"<p>Returns a handler to a value to be read or written from or to the hdf5 file.</p> C++ <pre><code>hdf5::FileH5Handler operator[](std::string key);\n</code></pre>"},{"location":"documentation/io/file_h5/#usage-example","title":"Usage Example","text":"C++ <pre><code>std::string filename = XDIAG_DIRECTORY \"/misc/data/hdf5/write.h5\";\nauto fl = FileH5(filename, \"w!\");\n\n// Write output to the hdf5 file\nfl[\"val\"] = 12;\nfl[\"test/to\"] = 22;\nfl[\"test/to2/group\"] = 32;\nfl[\"test/to3/group2/asdf\"] = 42;\n\nauto mat = arma::cx_mat(3, 5, arma::fill::randn);\nfl[\"a/b/c/mat\"] = mat;\n</code></pre>"},{"location":"documentation/io/file_toml/","title":"FileToml","text":"<p>A file handler for TOML files. Most funtionality is only provided for the C++ version as Julia already provides good tools handling TOML files.</p> <p>Sources file_toml.hpp, file_toml.cpp</p>"},{"location":"documentation/io/file_toml/#constructors","title":"Constructors","text":"C++Julia <pre><code>FileToml(const char *filename);\nFileToml(std::string filename);\n</code></pre> <pre><code>FileToml(filename::String)\n</code></pre> Name Description Default filename filename of the TOML file"},{"location":"documentation/io/file_toml/#methods","title":"Methods","text":""},{"location":"documentation/io/file_toml/#defined","title":"defined","text":"<p>Returns whether or not the TOML file has a certain key defined.</p> C++ <pre><code>bool defined(FileToml const &amp;fl, std::string key);\n</code></pre>"},{"location":"documentation/io/file_toml/#getindex-operator-c-only","title":"getindex / operator[] (C++ only)","text":"<p>Returns a handler to a value to be read from the TOML file.</p> C++ <pre><code>io::FileTomlHandler operator[](std::string key);\n</code></pre>"},{"location":"documentation/io/file_toml/#usage-example","title":"Usage Example","text":"C++ <pre><code>auto fl = FileToml(XDIAG_DIRECTORY \"/misc/data/toml/input.toml\");\nXDIAG_SHOW(defined(fl, \"N\"));\n\nint N = fl[\"N\"].as&lt;int&gt;();\nint nup = fl[\"nup\"].as&lt;int&gt;();\ndouble J1 = fl[\"J1\"].as&lt;double&gt;();\ndouble J2 = fl[\"J2\"].as&lt;double&gt;();\n\nauto block = Spinhalf(N, nup);\nauto H = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  H += J1 * Op(\"SdotS\", {i, (i+1)%N});\n  H += J2 * Op(\"SdotS\", {i, (i+2)%N});\n}\ndouble e0 = eigval0(H, block);\nXDIAG_SHOW(e0);\n</code></pre>"},{"location":"documentation/io/read_opsum/","title":"read_opsum","text":"<p>Reads an OpSum object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_opsum/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_opsum(FileToml file, std::string tag);\n</code></pre> <pre><code>read_opsum(file::FileToml, tag::String);\n</code></pre>"},{"location":"documentation/io/read_opsum/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the OpSum is read tag tag which holds the information in the TOML file about the OpSum"},{"location":"documentation/io/read_opsum/#data-format","title":"Data format","text":"<p>An OpSum can be defined in a TOML file as a simple list. The entries of the list are themselves also lists, which contain two or more entries:</p> <ol> <li>The first entry must be either a string or a real / complex number denoting the coupling constant of the term.</li> <li>The second entry must be a string and denotes the operator type</li> <li>The (optional) following entries are integer numbers which denote the sites of the Op</li> </ol> <p>Here is typical example of a OpSum specification in a TOML file:</p> <pre><code>Interactions = [\n  ['J1', 'SdotS', 0, 1],\n  ['J1', 'SdotS', 1, 2],\n  ['J1', 'SdotS', 2, 0],\n  ['Jchi', 'ScalarChirality', 0, 1, 2],\n]\n</code></pre>"},{"location":"documentation/io/read_opsum/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/triangular.9.hop.sublattices.tsl.toml\";\nauto fl = FileToml(file);\nauto ops = read_opsum(fl, \"Interactions\");\nXDIAG_SHOW(ops);\n</code></pre> <pre><code>\n</code></pre>"},{"location":"documentation/io/read_permutation_group/","title":"read_permutation_group","text":"<p>Reads an PermutationGroup object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_permutation_group/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_permutation_group(FileToml file, std::string tag);\n</code></pre> <pre><code>read_permutation_group(file::FileToml, tag::String);\n</code></pre>"},{"location":"documentation/io/read_permutation_group/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the PermutationGroup is read tag tag which holds the information in the TOML file about the PermutatioGroup"},{"location":"documentation/io/read_permutation_group/#data-format","title":"Data format","text":"<p>A  PermutationGroup can be defined in a TOML file as an integer matrix, where the rows are the integers of the permutation.</p> <p>A typical specification of a \\(C_4\\) PermutationGroup is shown here:</p> <pre><code>Symmetries = [\n  [0, 1, 2, 3],\n  [1, 2, 3, 0],\n  [2, 3, 0, 1],\n  [3, 0, 1, 2]\n]\n</code></pre> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/io/read_permutation_group/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/triangular.9.hop.sublattices.tsl.toml\";\nauto fl = FileToml(file);\nauto group = read_permutation_group(fl, \"Symmetries\");\nXDIAG_SHOW(group);\n</code></pre> <pre><code>\n</code></pre>"},{"location":"documentation/io/read_representation/","title":"read_representation","text":"<p>Reads an Representation object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_representation/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_representation(FileToml file, std::string irrep_tag, \n                          std::string group_tag = \"Symmetries\");\n</code></pre> <pre><code>read_representation(file::FileToml, irrep_tag::String, \n                    group_tag::String = \"Symmetries\");\n</code></pre>"},{"location":"documentation/io/read_representation/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the Representation is read irrep_tag tag which holds the information about the Representation in the TOML file group_tag tag which holds the information about the PermutationGroup in the TOML file \"Symmetries\""},{"location":"documentation/io/read_representation/#data-format","title":"Data format","text":"<p>A  Representation can be defined in a TOML file by specifying up two or three things:</p> <ol> <li>The PermutationGroup as an integer matrix</li> <li>The <code>characters</code> of the representation </li> <li>(optional) the <code>allowed_symmetries</code> of the representation, i.e. a list of the number of symmetries used in the irrep. By default all symmetries of the group are used in the representation.</li> </ol> <p>A typical specification of several Representations is shown here:</p> <pre><code>    Symmetries = [\n      [0, 1, 2, 3],\n      [1, 2, 3, 0],\n      [2, 3, 0, 1],\n      [3, 0, 1, 2]\n    ]\n\n    # real irrep, momentum 0\n    [k_0]\n    characters=[1.0, 1.0, 1.0, 1.0]\n\n    # complex irrep, momentum pi/2\n    [k_pi2]\n    characters=[\n      [1.0, 0.0], \n      [0.0, 1.0], \n      [-1.0, 0.0],\n      [0.0, -1.0]\n    ]\n\n    # real irrep, momentum pi\n    [k_pi]\n    characters=[1.0, -1.0, 1.0, -1.0]\n\n    # real irrep on subgroup\n    [k_pi2_half]\n    characters=[1.0, -1.0]\n    allowed_symmetries=[0, 2]\n</code></pre> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/io/read_representation/#usage-example","title":"Usage Example","text":"<p>The example reads the representation defined in the <code>irreps.toml</code> file, whose contents are shown up in the section Data format.</p> C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/irreps.toml\";\nauto fl = FileToml(file);\n\nauto k_0 = read_representation(fl, \"k_0\");\nXDIAG_SHOW(k_0);\nXDIAG_SHOW(isreal(k_0));\n\nauto k_pi2 = read_representation(fl, \"k_pi2\");\nXDIAG_SHOW(k_pi2);\nXDIAG_SHOW(isreal(k_pi2));\n\nauto k_pi = read_representation(fl, \"k_pi\");\nXDIAG_SHOW(k_pi);\nXDIAG_SHOW(isreal(k_pi));\n\nauto k_pi2_half = read_representation(fl, \"k_pi2_half\");\nXDIAG_SHOW(k_pi2_half);\nXDIAG_SHOW(isreal(k_pi2_half));\n</code></pre> <pre><code>\n</code></pre>"},{"location":"documentation/operators/hc/","title":"hc","text":"<p>Returns the hermitian conjugate \\(\\mathcal{O}^\\dagger\\) of an operator \\(\\mathcal{O}\\) represented by an Op or OpSum object. Please note the details when conjugating complex couplings, outlined in OpSum # Complex couplings.</p> <p>Sources hc.hpp hc.cpp hc.jl</p>"},{"location":"documentation/operators/hc/#definition","title":"Definition","text":"C++Julia <pre><code>Op hc(Op const &amp;op)\nOpSum hc(OpSum const &amp;ops)\n</code></pre> <pre><code>hc(op::OpSum)::Op\nhc(ops::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/hc/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto cdagup = Op(\"Cdagup\", 0);\nauto sdots = Op(\"SdotS\", {0, 1});\nauto hop = (1.0 + 1.0i) * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(cdagup == hc(cdagup));\nXDIAG_SHOW(sdots == hc(sdots));\nXDIAG_SHOW(hop == hc(hop));\n</code></pre> <pre><code>cdagup = Op(\"Cdagup\", 1)\nsdots = Op(\"SdotS\", [1, 2])\nhop = (1.0 + 1.0im) * Op(\"Hop\", [1, 2])\n@show cdagup == hc(cdagup)\n@show sdots == hc(sdots)\n@show hop == hc(hop)\n</code></pre>"},{"location":"documentation/operators/op/","title":"Op","text":"<p>Object describing a single linear operator acting on a Hilbert space.</p> <p>Sources op.hpp op.cpp op.jl</p> <p>Every operator is defined by up to three paramaters:</p> <ol> <li> <p>The type of the operator. This is a string argument which determines what kind of operator is represented. A detailed overview of the available types can be found at Operator types</p> </li> <li> <p>The sites of the operator. This defines which physical sites (or orbitals) the operator acts upon. While most operator types require sites, there are also operator types (e.g. <code>HubbardU</code>) which do not need to define sites.</p> </li> <li> <p>For special interactions, it can be necessary to additionally specify a numerical matrix, which can either be real or complex. An example is the operator type <code>Matrix</code> defining generic spin interactions.</p> </li> </ol>"},{"location":"documentation/operators/op/#constructors","title":"Constructors","text":"C++Julia <pre><code>Op(std::string type);\nOp(std::string type, int64_t site);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites);\nOp(std::string type, int64_t site, arma::mat const &amp;matrix);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites, arma::mat const &amp;matrix);\nOp(std::string type, int64_t site, arma::cx_mat const &amp;matrix);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites, arma::cx_mat const &amp;matrix);\n</code></pre> <pre><code>Op(type::String)\nOp(type::String, site::Int64)\nOp(type::String, sites::Vector{Int64})\nOp(type::String, site::Int64, matrix::Matrix{Float64})\nOp(type::String, sites::Vector{Int64}, matrix::Matrix{Float64})\nOp(type::String, site::Int64, matrix::Matrix{ComplexF64})\nOp(type::String, sites::Vector{Int64}, matrix::Matrix{ComplexF64})\n</code></pre> Parameter Description type a string which denotes what kind of operator is represented sites defines on which site(s) of the lattice the operator acts on. optional matrix defines a matrix which may be needed to describe an operator. optional <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of an Op, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/operators/op/#methods","title":"Methods","text":""},{"location":"documentation/operators/op/#isreal","title":"isreal","text":"<p>Returns whether an Op is a real operator.</p> C++Julia <pre><code>bool isreal(Op const &amp;op);\n</code></pre> <pre><code>isreal(op::Op)::Bool\n</code></pre>"},{"location":"documentation/operators/op/#isapprox","title":"isapprox","text":"<p>Returns whether two Ops are approximately equal.</p> C++Julia <pre><code>bool isapprox(Op const &amp;op1, OpSum const &amp;op2, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(op1::Op, op2::Op, rtol::Float64=1e-12, atol::Float64=1e-12)::Bool\n</code></pre>"},{"location":"documentation/operators/op/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Op to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Op const &amp;op);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Op const &amp;op);\n</code></pre> <pre><code>to_string(op::Op)::String\n</code></pre>"},{"location":"documentation/operators/op/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto op = \"T\" * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(op);\n\nop = 1.23 * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(op);\n\narma::cx_mat m(arma::mat(\"0 0; 0 0\"), arma::mat(\"0 -1; 1 0\"));\nop = Op(\"Matrix\", 0, m);\nXDIAG_SHOW(op);\nXDIAG_SHOW(isreal(op));\n</code></pre> <pre><code>op = \"T\" * Op(\"Hop\", [1, 2])\n@show op\n\nop = 1.23 * Op(\"Hop\",  [1, 2])\n@show op\n\nop = Op(\"Matrix\", 1, [0 -1.0im; 1.0im 0])\n@show op\n@show isreal(op)\n</code></pre>"},{"location":"documentation/operators/operator_types/","title":"Operator types","text":""},{"location":"documentation/operators/operator_types/#list-of-operator-types","title":"List of operator types","text":"<p>Generic operators in XDiag are represented as OpSum objects made up of a coupling, which can be a real/complex number or a string, and Op objects. Every Op is defined by a <code>type</code>. Here we list all the available types implemented in XDiag, their required number of sites, and the blocks for which they are available.</p> Type Description No. of sites Blocks <code>Hop</code> A hopping term for \\(\\uparrow\\) and \\(\\downarrow\\) spins of the form $$ \\textcolor{red}{-}\\sum_{\\sigma=\\uparrow\\downarrow} (tc^\\dagger_{i\\sigma}c_{j\\sigma} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed <code>Hopup</code> A hopping term for \\(\\uparrow\\) spins of the form $$ \\textcolor{red}{-}(tc^\\dagger_{i\\uparrow}c_{j\\uparrow} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed <code>Hopdn</code> A hopping term for \\(\\downarrow\\) spins of the form $$ \\textcolor{red}{-}(tc^\\dagger_{i\\downarrow}c_{j\\downarrow} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed <code>HubbardU</code> A uniform Hubbard interaction across the full lattice of the form $$ \\sum_i n_{i\\uparrow}n_{i\\downarrow}$$ 0 Electron <code>Cdagup</code> A fermionic creation operator for an \\(\\uparrow\\) spin \\(c^\\dagger_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed <code>Cdagdn</code> A fermionic creation operator for an \\(\\downarrow\\) spin \\(c^\\dagger_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Cup</code> A fermionic annihilation operator for an \\(\\uparrow\\) spin \\(c_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed <code>Cdn</code> A fermionic annihilation operator for an \\(\\downarrow\\) spin \\(c_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Nup</code> A number operator for an \\(\\uparrow\\) spin \\(n_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed <code>Ndn</code> A number operator for an \\(\\downarrow\\) spin \\(n_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>Ntot</code> A number operator \\(n_i = n_{i\\uparrow} + n_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed <code>NtotNtot</code> A density-density interaction \\(n_i n_j\\) 2 tJ, Electron, tJDistributed <code>SdotS</code> A Heisenberg interaction of the form $$ \\mathbf{S}_i \\cdot \\mathbf{S}_j = S^x_iS^x_j + S^y_iS^y_j + S^z_iS^z_j$$ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>SzSz</code> An Ising interaction of the form $ S^z_i S^z_j $ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>Exchange</code> A spin exchange interaction of the form $$ \\frac{1}{2}(JS^+_i S^-_j + J^*S^-_iS^+_j)$$ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>Sz</code> A local magnetic moment in the \\(z\\)-direction $ S^z_i$ 1 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed <code>S+</code> A local spin raising operator \\(S^+_i\\) 1 Spinhalf, SpinhalfDistributed <code>S-</code> A local spin lowering operator \\(S^-_i\\) 1 Spinhalf, SpinhalfDistributed <code>ScalarChirality</code> A scalar chirality interaction of the form $$ \\mathbf{S}_i \\cdot ( \\mathbf{S}_j \\times  \\mathbf{S}_k)$$ 3 Spinhalf <code>tJSzSz</code> An Ising interaction as encountered in the \\(t-J\\) model of the form $$  S^z_i S^z_j - \\frac{n_i n_j}{4}$$ 2 tJ, tJDistributed <code>tJSdotS</code> An Heisenberg  interaction as encountered in the \\(t-J\\) model of the form $$  \\mathbf{S}_i \\cdot \\mathbf{S}_j - \\frac{n_i n_j}{4}$$ 2 tJ, tJDistributed <code>Matrix</code> A generic spin interaction no an arbitrary number of sites defined via a coupling matrix arbitrary Spinhalf"},{"location":"documentation/operators/operator_types/#matrix-type","title":"Matrix type","text":"<p>The <code>Matrix</code> interaction type is a special type with whom one can define generic interactions for the Spinhalf block. In addition to the <code>type</code> and <code>sites</code> argument, also a numerical matrix is provided when constructing the Op object. The matrix describes the operator acting on the \\(2^n\\) dimensional space spanned by the \\(n\\) sites of the operator. For example, we can represent a \\(S^x\\) spin operator as,</p> C++ <pre><code>auto sx = arma::mat({{0, 1},{1, 0}});\nauto op = Op(\"Matrix\", 0, sx);\n</code></pre> <p>More generically, we can use this mechanism to construct arbitary spin interactions, e.g.   </p> C++ <pre><code>auto sx = arma::mat({{0, 1},{1, 0}});\nauto sz = arma::mat({{0.5, 1},{0, -0.5}});\n\narma::mat sxsz = arma::kron(sx, sz);\narma::mat sxszsxsz = arma::kron(sxsz, sxsz);\n\nauto op_sxsz = Op(\"Matrix\", {0, 1}, sxsz);\nauto op_sxszsxsz = Op(\"Matrix\", {0, 1, 2, 3}, sxsz);\n</code></pre> <p>Here we have been using the Kronecker product function <code>kron</code>.</p>"},{"location":"documentation/operators/opsum/","title":"OpSum","text":"<p>Object representing a generic many-body operator by a sum of operators of the form </p> \\[ \\mathcal{O} = \\sum_i c_i \\mathcal{O}_i. \\] <p>Sources opsum.hpp opsum.cpp opsum.jl</p> <p>An OpSum is consists of a sum of pairs given by</p> <ol> <li> <p>A coupling constant \\(c_i\\) which is given by a either a string name or a real/complex number.</p> </li> <li> <p>An operator \\(\\mathcal{O}_i\\) defined by an Op object.</p> </li> </ol> <p>Generically, an OpSum can thus have coupling constants defined by either strings or numerical real/complex numbers. We call an OpSum plain if its couplings are only numerical numbers, and not strings. String couplings can be defined by using the access <code>operator[]</code>. If all string coupling constants are defined, the OpSum can be converted to a plain OpSum using the <code>plain</code> method shown below.</p> <p>Thus, OpSums can be defined independently of the numerical values of the coupling constants, e.g. in an input file. Upon execution of the code, these constants can then be set. Most operations in XDiag require the OpSum to be convertible to a plain OpSum.</p> <p>OpSums can be added and subtracted, as well as multiplied with and divided by a scalar value, i.e. a real or complex number. Hence, OpSums carry the mathematical structure of a vector space.</p>"},{"location":"documentation/operators/opsum/#constructors","title":"Constructors","text":"<p>The following constructors create an OpSum with a single pair of coupling and operator. Additional terms can be added using the <code>+</code> and <code>+=</code> operators explained further below. If no coupling is given, a numerical coefficient of <code>1.0</code> is assumed.</p> C++Julia <pre><code>OpSum(Op const &amp;op);\nOpSum(double coupling, Op const &amp;op);\nOpSum(complex coupling, Op const &amp;op);\nOpSum(std::string coupling, Op const &amp;op);\n</code></pre> <pre><code>OpSum(op::Op)\nOpSum(coupling::Float64, op::Op)\nOpSum(coupling::ComplexF64, op::Op)\nOpSum(coupling::String, op::Op)\n</code></pre> Parameter Description Default coupling A coupling which is either a string or a real/complex number 1.0 op An Op which describes the type of operator <p>Alternatively, an OpSum can also be constructed via the <code>* operator</code>, for example:</p> C++Julia <pre><code>auto ops = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n    ops += \"J\" * Op(\"SzSz\", {i, (i + 1) % N});\n}\n</code></pre> <pre><code>ops = OpSum();\nfor i in 1:n\n    ops += \"J\" * Op(\"SzSz\", [i, mod1(i+1, N)]);\n</code></pre>"},{"location":"documentation/operators/opsum/#complex-couplings","title":"Complex couplings","text":"<p>XDiag allows all couplings to be complex. Depending on the operator type  a complex coupling can have two meanings:</p> <ol> <li> <p>A complex prefactor \\(c\\) which upon hermitian conjugation with hc gets     conjugated to \\(c^\\star\\). This is the case for the following interaction types:  <code>HubbardU</code>, <code>Cdagup</code>, <code>Cdagdn</code>, <code>Cup</code>, <code>Cdn</code>, <code>Nup</code>, <code>Ndn</code>, <code>Ntot</code>, <code>NtotNtot</code>,     <code>SdotS</code>, <code>SzSz</code>, <code>Sz</code>, <code>S+</code>, <code>S-</code>, <code>ScalarChirality</code>, <code>tJSzSz</code>, <code>tJSdotS</code>,     <code>Matrix</code>    Thus, a complex coupling can turn a Hermitian operator to a non-Hermitian operator.</p> </li> <li> <p>The coupling is part of the definition of the operator. For, example a hopping     operator of the form     $$ ( t c^\\dagger_{i\\sigma}c_{j\\sigma} + \\textrm{h.c.})  = ( t c^\\dagger_{i\\sigma}c_{j\\sigma} + t^\\star c^\\dagger_{j\\sigma}c_{i\\sigma}) $$    A complex coupling \\(t\\) gives the hopping a phase, but the overall operator remains    Hermitian and, thus, invariant under hc. This holds for the types     <code>Hop</code>, <code>Hopup</code>, <code>Hopdn</code>, <code>Exchange</code>. In the latter case, complex spin exchange     <code>Exchange</code> is defined as,    $$ \\frac{1}{2}( J S^+_i S^-_j + J^\\star S^-_iS^+_j)$$</p> </li> </ol>"},{"location":"documentation/operators/opsum/#methods","title":"Methods","text":""},{"location":"documentation/operators/opsum/#plain","title":"plain","text":"<p>Converts an OpSum with possible string couplings to an OpSum with purely numerical real/complex couplings.</p> C++Julia <pre><code>OpSum plain(OpSum const &amp;ops) const;\n</code></pre> <pre><code>plain(ops::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-creation","title":"operator* (Creation)","text":"<p>Creates an OpSum with a single pair of coupling constant and an Op object.</p> C++Julia <pre><code>OpSum operator*(double coupling, Op const &amp;op);\nOpSum operator*(complex coupling, Op const &amp;op);\nOpSum operator*(std::string coupling, Op const &amp;op);\n</code></pre> <pre><code>Base.:*(coupling::Float64, op::Op)::OpSum\nBase.:*(coupling::ComplexF64, op::Op)::OpSum\nBase.:*(coupling::String, op::Op)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator","title":"operator+ / operator +=","text":"<p>Adds two OpSum objects \\(\\mathcal{A} = \\sum_i a_i \\mathcal{A}_i\\) and \\(\\mathcal{B} = \\sum_i b_i \\mathcal{B}_i\\) to for the sum of the two operators,     $$ \\mathcal{A} + \\mathcal{B} = \\sum_i a_i \\mathcal{A}_i + \\sum_i b_i \\mathcal{B}_i$$</p> C++Julia <pre><code>OpSum &amp;operator+=(OpSum const &amp;ops);\nOpSum operator+(OpSum const &amp;ops) const;\n</code></pre> <pre><code>Base.:+(ops1::OpSum, ops2::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator-","title":"operator- / operator -=","text":"<p>Subtracts to OpSum objects.</p> C++Julia <pre><code>OpSum &amp;operator-=(OpSum const &amp;ops);\nOpSum operator-(OpSum const &amp;ops) const;\n</code></pre> <pre><code>Base.:-(ops::OpSum, ops2::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator-scalar-muliplicationdivision","title":"operator* , operator/ (scalar muliplication/division)","text":"<p>Multiplies an OpSum \\(\\mathcal{A} = \\sum_i a_i \\mathcal{A}_i\\) with a scalar \\(b\\) to form</p> \\[\\mathcal{B} = b \\sum_i a_i \\mathcal{A}_i\\] C++Julia <pre><code>OpSum &amp;operator*=(double scalar);\nOpSum &amp;operator*=(complex scalar);\nOpSum &amp;operator/=(double scalar);\nOpSum &amp;operator/=(complex scalar);\n\nOpSum operator*(double scalar, OpSum const &amp;op);\nOpSum operator*(complex scalar, OpSum const &amp;op);\nOpSum operator*(OpSum const &amp;op, double scalar);\nOpSum operator*(OpSum const &amp;op, complex scalar);\nOpSum operator/(OpSum const &amp;op, double scalar);\nOpSum operator/(OpSum const &amp;op, complex scalar);\n</code></pre> <pre><code>Base.:*(coupling::Float64, ops::OpSum)::OpSum\nBase.:*(coupling::ComplexF64, ops::OpSum)::OpSum\nBase.:*(ops::OpSum, coupling::Float64)::OpSum\nBase.:*(ops::OpSum, coupling::ComplexF64)::OpSum\nBase.:/(ops::OpSum, coupling::Float64)::OpSum\nBase.:/(ops::OpSum, coupling::ComplexF64)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator","title":"operator[]","text":"<p>Sets a coupling constant defined as a string to a numerical value.</p> C++Julia <pre><code>Scalar &amp;operator[](std::string name);\n</code></pre> <pre><code>Base.setindex!(ops::OpSum, cpl::Float64, name::String)\nBase.setindex!(ops::OpSum, cpl::ComplexF64, name::String)\n</code></pre>"},{"location":"documentation/operators/opsum/#constants","title":"constants","text":"<p>Returns a vector of strings with the coupling constants defined, i.e. the strings that define some of the coupling constants.</p> C++Julia <pre><code>std::vector&lt;std::string&gt; constants(OpSum const &amp;ops) const;\n</code></pre> <pre><code>constants(ops::OpSum)::Vector{String}\n</code></pre>"},{"location":"documentation/operators/opsum/#isreal","title":"isreal","text":"<p>Returns whether an OpSum is a real operator.</p> C++Julia <pre><code>bool isreal(OpSum const &amp;ops);\n</code></pre> <pre><code>isreal(ops::OpSum)::Bool\n</code></pre>"},{"location":"documentation/operators/opsum/#isapprox","title":"isapprox","text":"<p>Returns whether two OpSums are approximately equal.</p> C++Julia <pre><code>bool isapprox(OpSum const &amp;ops1, OpSum const &amp;ops2, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(ops1::OpSum, ops2::OpSum, rtol::Float64=1e-12, atol::Float64=1e-12)::Bool\n</code></pre>"},{"location":"documentation/operators/opsum/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the OpSum to a readable string representation.</p> C++Julia <pre><code>std::string to_string(OpSum const &amp;ops);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, OpSum const &amp;ops);\n</code></pre> <pre><code>to_string(ops::OpSum)::String\n</code></pre>"},{"location":"documentation/operators/opsum/#usage-example","title":"Usage Example","text":"C++ <pre><code>// Define the 1D transverse-field Ising chain\nint N = 12;\ndouble J = 1.0;\ndouble h = 0.5;\nauto Sx = arma::mat(\"0 1; 1 0\");\n\n// Option 1: coupling constants as numbers\nauto ops1 = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops1 += J * Op(\"SzSz\", {i, (i+1)%N});\n  ops1 += h * Op(\"Matrix\", i, Sx);\n}\n\n// Option 2: coupling constants as strings\nauto ops2 = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops2 += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n  ops2 += \"h\" * Op(\"Matrix\", i, Sx);\n}\nops2[\"J\"] = J;\nops2[\"h\"] = h;\n\nXDIAG_SHOW(isapprox(ops1, ops2));\nXDIAG_SHOW(isapprox(ops1 + ops2, 2.0 * ops1));\n</code></pre>"},{"location":"documentation/operators/symmetrize/","title":"symmetrize","text":"<p>Symmetrizes an operator with respect to a PermutationGroup or a Representation.</p> <p>Sources symmetrize.hpp symmetrize.cpp symmetrize.jl</p> <p>Symmetrization in this context means the following. In general, we are given an OpSum of the form,</p> \\[ O = \\sum_{A\\subseteq \\mathcal{L}} O_A,\\] <p>where \\(O_A\\) denotes a local operator acting on sites \\(A=\\{a_1, \\ldots, a_{l_A}\\}\\) and \\(L\\) denotes the lattice. A PermutationGroup \\(\\mathcal{G}\\) is defined through its permutations \\(\\pi_1, \\ldots, \\pi_M\\). The symmetrized operator returned by this function is then </p> \\[ O^\\mathcal{G} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}}  O_{\\pi(A)},\\] <p>where \\(\\pi(A) = \\{\\pi(a_1), \\ldots,\\pi(a_{l_A})\\}\\) denotes the permutated set of sites of the local operator \\(O_A\\). If a Representation called \\(\\rho\\) is given in addition, the following operator is constructed,</p> \\[ O^\\mathcal{G, \\rho} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}} \\chi_\\rho(\\pi) O_{\\pi(A)},\\] <p>where \\(\\chi_\\rho(\\pi)\\) denotes the characters of the representation \\(\\rho\\). This routine is useful to evaluate observables in symmetrized blocks.</p>"},{"location":"documentation/operators/symmetrize/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum symmetrize(Op const &amp;op, PermutationGroup const &amp;group);\nOpSum symmetrize(Op const &amp;op, Representation const &amp;irrep);\nOpSum symmetrize(OpSum const &amp;ops, PermutationGroup const &amp;group);\nOpSum symmetrize(OpSum const &amp;ops, Representation const &amp;irrep);\n</code></pre> <pre><code>symmetrize(op::Op, group::PermutationGroup)::OpSum\nsymmetrize(op::Op, irrep::Representation)::OpSum\nsymmetrize(ops::OpSum, group::PermutationGroup)::OpSum\nsymmetrize(ops::OpSum, irrep::Representation)::OpSum\n</code></pre>"},{"location":"documentation/operators/symmetrize/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator to be symmetrized group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group"},{"location":"documentation/operators/symmetrize/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nauto block = Spinhalf(N, nup);\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto rep = Representation(group);\nauto block_sym = Spinhalf(N, rep);\n\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto [e0s, psi_sym] = eig0(ops, block_sym);\n\nauto corr = Op(\"SdotS\", {0, 1});\nauto nn_corr = inner(corr, psi);\nauto corr_sym = symmetrize(corr, group);\nauto nn_corr_sym = innerC(corr_sym, psi_sym);\nXDIAG_SHOW(nn_corr);\nXDIAG_SHOW(nn_corr_sym);\n</code></pre> <pre><code>let\n    N = 4\n    nup = 2\n    block = Spinhalf(N, nup)\n    p1 = Permutation([1, 2, 3, 4])\n    p2 = Permutation([2, 3, 4, 1])\n    p3 = Permutation([3, 4, 1, 2])\n    p4 = Permutation([4, 1, 2, 3])\n    group = PermutationGroup([p1, p2, p3, p4])\n    rep = Representation(group)\n    block_sym = Spinhalf(N, rep)\n\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    e0, psi = eig0(ops, block);\n    e0, psi_sym = eig0(ops, block_sym);\n\n    corr = Op(\"SdotS\", [1, 2])\n    nn_corr = inner(corr, psi)\n    corr_sym = symmetrize(corr, group)\n    nn_corr_sym = inner(corr_sym, psi_sym)\n    @show nn_corr, nn_corr_sym\nend\n</code></pre>"},{"location":"documentation/states/create_state/","title":"Creating specific States","text":"<p>Sources create_state.hpp, create_state.cpp</p>"},{"location":"documentation/states/create_state/#product_state","title":"product_state","text":"<p>Creates a filled product state.</p> C++Julia <pre><code>State product_state(Block const &amp;block, std::vector&lt;std::string&gt; const &amp;local_state, bool real = true);\n</code></pre> <pre><code>product_state(block::Block, local_states::Vector{String}; real::Bool=true)\n</code></pre>"},{"location":"documentation/states/create_state/#parameters","title":"Parameters","text":"Name Description block block on which the state is defined local_states local configurations of the product state real flag whether real state is created"},{"location":"documentation/states/create_state/#random_state","title":"random_state","text":"<p>Create a filled random state with normal \\(\\mathcal{N}(0, 1)\\) distributed coefficients.</p> C++Julia <pre><code>State random_state(Block const &amp;block, bool real = true, int64_t seed = 42, bool normalized = true);\n</code></pre> <pre><code>random_state(block::Block; real::Bool=true, seed::Int64=42, normalized::Bool=true\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_1","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created seed random seed determining the precise random numbers normalized flag whether the state is normalized"},{"location":"documentation/states/create_state/#zero_state","title":"zero_state","text":"<p>Create a filled state with all zero entries.</p> C++Julia <pre><code>State zero_state(Block const &amp;block, bool real = true, int64_t ncols = 1);\n</code></pre> <pre><code>zero_state(block::Block; real::Bool=true, ncols::Int64=1)\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_2","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created n_col number of columns in the state"},{"location":"documentation/states/create_state/#zero","title":"zero","text":"<p>Set all coefficients of a given state to zero.</p> C++Julia <pre><code>void zero(State &amp;state);\n</code></pre> <pre><code>zero(state::State)\n</code></pre>"},{"location":"documentation/states/create_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = product_state(block, {\"Up\", \"Dn\"});\nXDIAG_SHOW(state.vector());\n\nzero(state);\nXDIAG_SHOW(state.vector());\n\nstate = random_state(block, false, 1234, true);\nXDIAG_SHOW(state.vectorC());\n\nstate = zero_state(block, true, 2);\nXDIAG_SHOW(state.vector());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = product_state(block, [\"Up\", \"Dn\"])\ndisplay(vector(state))\n\nzero(state)\ndisplay(vector(state))\n\nstate = random_state(block, real=false, seed=1234, normalized=true)\ndisplay(vector(state))\n\nstate = zero_state(block, real=true, ncols=2)\ndisplay(matrix(state))\n</code></pre>"},{"location":"documentation/states/fill/","title":"fill","text":"<p>Fills a State with a given model state, e.g. a ProductState or a RandomState.</p> <p>Sources fill.hpp fill.cpp fill.jl</p>"},{"location":"documentation/states/fill/#definition","title":"Definition","text":"C++Julia <pre><code>void fill(State &amp;state, ProductState const &amp;pstate, int64_t ncol = 0);\nvoid fill(State &amp;state, RandomState const &amp;rstate, int64_t ncol = 0);\n</code></pre> <pre><code>fill(state::State, pstate::ProductState, ncol::Int64 = 1)\nfill(state::State, rstate::RandomState, ncol::Int64 = 1)\n</code></pre> Name Description state State object to be filled pstate ProductState object rstate RandomState object ncol integer deciding which column of the State is filled (default: 1/0 (Julia/C++))"},{"location":"documentation/states/fill/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = State(block);  \nauto pstate = ProductState({\"Up\", \"Dn\"});\nfill(state, pstate);\nXDIAG_SHOW(state.vector());\n\nauto rstate = RandomState(1234);\nfill(state, rstate);\nXDIAG_SHOW(state.vector());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = State(block)\npstate = ProductState([\"Up\", \"Dn\"])\nfill(state, pstate)\ndisplay(vector(state))\n\nrstate = RandomState(1234)\nfill(state, rstate)\ndisplay(vector(state))\n</code></pre>"},{"location":"documentation/states/product_state/","title":"ProductState","text":"<p>A product state of local configurations.</p> <p>Sources product_state.hpp product_state.cpp product_state.jl</p>"},{"location":"documentation/states/product_state/#constructors","title":"Constructors","text":"C++Julia <pre><code>ProductState(int64_t nsites);\nProductState(std::vector&lt;std::string&gt; const &amp;local_states);\n</code></pre> <pre><code>ProductState(nsites::Int64)\nProductState(local_states::Vector{String})\n</code></pre> Parameter Description nsites construct a product state on nsites local_states the local configurations of the product state"},{"location":"documentation/states/product_state/#iteration","title":"Iteration","text":"<p>A ProductState can be iterated over, where at each iteration the string of the local configuration is retured. Here is an example:</p> C++Julia <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n    Log(\"{}\", s);\n}\n</code></pre> <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n</code></pre>"},{"location":"documentation/states/product_state/#methods","title":"Methods","text":""},{"location":"documentation/states/product_state/#nsites","title":"nsites","text":"<p>Returns the number of sites of the product state</p> C++Julia <pre><code>int64_t nsites(ProductState const &amp;p);\n</code></pre> <pre><code>nsites(p::ProductState)\n</code></pre>"},{"location":"documentation/states/product_state/#size","title":"size","text":"<p>Returns the number of sites of the product state. Same as \"nsites\".</p> C++Julia <pre><code>int64_t size(ProductState const &amp;p);\n</code></pre> <pre><code>size(state::ProductState)\n</code></pre>"},{"location":"documentation/states/product_state/#setindex-operator","title":"setindex! / operator[]","text":"<p>Sets the local configuration at the given site index to the given string.</p> C++Julia <pre><code>std::string &amp;operator[](int64_t i);\n</code></pre> <pre><code>setindex!(state::ProductState, local_state::String, idx::Int64)\n</code></pre>"},{"location":"documentation/states/product_state/#getindex-operator","title":"getindex / operator[]","text":"<p>Returns the string of the local configuration at the given site index.</p> C++Julia <pre><code>std::string const &amp;operator[](int64_t i) const;\n</code></pre> <pre><code>getindex(state::ProductState, idx::Int64)\n</code></pre>"},{"location":"documentation/states/product_state/#push-push_back","title":"push! / push_back","text":"<p>Adds a local configuration add the end of the product state.</p> C++Julia <pre><code>void push_back(std::string l);\n</code></pre> <pre><code>push!(state::ProductState, local_state::String\n</code></pre>"},{"location":"documentation/states/product_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n\npstate = ProductState();\npstate.push_back(\"Dn\");\npstate.push_back(\"Up\");\npstate.push_back(\"Dn\");\nXDIAG_SHOW(pstate.nsites());\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n</code></pre> <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n@show pstate\n\npstate = ProductState()\npush!(pstate, \"Dn\")\npush!(pstate, \"Up\")\npush!(pstate, \"Dn\")\n@show nsites(pstate)\nfor s in pstate\n    @show s\nend\n@show pstate\n</code></pre>"},{"location":"documentation/states/random_state/","title":"RandomState","text":"<p>A random state with \\(\\mathcal{N}(0, 1)\\) normal distributed coefficients.</p> <p>Sources random_state.hpp random_state.cpp random_state.jl</p>"},{"location":"documentation/states/random_state/#constructors","title":"Constructors","text":"C++Julia <pre><code>RandomState(int64_t seed = 42, bool normalized = true);\n</code></pre> <pre><code>RandomState(seed::Int64 = 42, normalized::Bool = true)\n</code></pre> Parameter Description seed random seed determining which random numbers are put normalized flag whether the State is normalized"},{"location":"documentation/states/random_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = State(block, false);  // complex State\nauto rstate1 = RandomState(1234);\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n\nauto rstate2 = RandomState(4321);\nfill(state, rstate2);\nXDIAG_SHOW(state.vectorC());\n\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = State(block, real=false)  # complex State\nrstate1 = RandomState(1234)\nfill(state, rstate1)\ndisplay(vector(state))\n\nrstate2 = RandomState(4321)\nfill(state, rstate2)\ndisplay(vector(state))\n\nfill(state, rstate1)\ndisplay(vector(state))\n</code></pre>"},{"location":"documentation/states/state/","title":"State","text":"<p>A generic state describing a quantum wave function \\(|\\psi \\rangle\\).</p> <p>Sources state.hpp state.cpp state.jl</p>"},{"location":"documentation/states/state/#constructors","title":"Constructors","text":"<p>A state can be constructed in three ways:</p> <ol> <li> <p>By only specifying the block. In this case the state is initialized with all coefficients zero.</p> C++Julia <pre><code>State(Block const &amp;block, bool real = true, int64_t n_cols = 1);\n</code></pre> <pre><code>State(block::Block; real::Bool = true, n_cols::Int64 = 1)\n</code></pre> </li> <li> <p>By handing a vector of coefficients.</p> C++Julia <pre><code>State(Block const &amp;block, arma::vec const &amp;vector);\nState(Block const &amp;block, arma::cx_vec const &amp;vector);\n</code></pre> <pre><code>State(block::Block, vec::Vector{Float64})\nState(block::Block, vec::Vector{ComplexF64})\n</code></pre> </li> <li> <p>By handing a matrix whose columns describe several states at once.</p> C++Julia <pre><code>State(Block const &amp;block, arma::mat const &amp;matrix);\nState(Block const &amp;block, arma::cx_mat const &amp;matrix);\n</code></pre> <pre><code>State(block::Block, mat::Matrix{Float64})\nState(block::Block, mat::Matrix{ComplexF64})\n</code></pre> </li> </ol> Parameter Description block The block of a Hilbertspace on which the state is defined real Flag whether or not the state has real coefficients n_cols Number of columns of the state (default 1) vector A vector containing the coefficients of the state. Must be same size as block. matrix A matrix containing the coefficients of the state. Number of rows must be same as block size ."},{"location":"documentation/states/state/#methods","title":"Methods","text":""},{"location":"documentation/states/state/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block the state is defined on.</p> C++Julia <pre><code>int64_t nsites(State const &amp;s) const\n</code></pre> <pre><code>nsites(state::State)\n</code></pre>"},{"location":"documentation/states/state/#isapprox","title":"isapprox","text":"<p>Returns whether two states are approximately equal.</p> C++Julia <pre><code>bool isapprox(State const &amp;v, State const &amp;w, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(v::State, w::State, rtol::Float64, atol::Float64)\n</code></pre>"},{"location":"documentation/states/state/#isreal","title":"isreal","text":"<p>Returns whether the state is real.</p> C++Julia <pre><code>int64_t isreal(State const &amp;s) const;\n</code></pre> <pre><code>isreal(state::State)\n</code></pre>"},{"location":"documentation/states/state/#real","title":"real","text":"<p>Returns the real part of the State.</p> C++Julia <pre><code>State real(State const &amp;s) const;\n</code></pre> <pre><code>real(state::State)\n</code></pre>"},{"location":"documentation/states/state/#imag","title":"imag","text":"<p>Returns the imaginary part of the State.</p> C++Julia <pre><code>State imag(State const &amp;s) const;\n</code></pre> <pre><code>imag(state::State)\n</code></pre>"},{"location":"documentation/states/state/#make_complex-make_complex","title":"make_complex! / make_complex","text":"<p>Turns a real State into a complex State. Does nothing if the state is already complex</p> C++Julia <pre><code>void make_complex(State &amp;s);\n</code></pre> <pre><code>make_complex!(state::State)\n</code></pre>"},{"location":"documentation/states/state/#dim","title":"dim","text":"<p>Returns the dimension of the block the state is defined on.</p> C++Julia <pre><code>int64_t dim(State const &amp;s) const;\n</code></pre> <pre><code>dim(block::Spinhalf)\n</code></pre>"},{"location":"documentation/states/state/#size","title":"size","text":"<p>Returns the <code>size</code> of the block (also equal to <code>nrows</code>) times the number of columns <code>ncols</code>. For distributed blocks the local size of a Block is not the same as the dimension <code>dim</code>, which is the overall dimension of the block across all processes.</p> C++Julia <pre><code>int64_t size(State const &amp;s);\n</code></pre> <pre><code>size(s::State)\n</code></pre>"},{"location":"documentation/states/state/#nrows","title":"nrows","text":"<p>Returns number of rows of the local storage.</p> C++Julia <pre><code>int64_t nrows(State const &amp;s);\n</code></pre> <pre><code>nrows(s::State)\n</code></pre>"},{"location":"documentation/states/state/#n_cols","title":"n_cols","text":"<p>Returns number of columns.</p> C++Julia <pre><code>int64_t ncols(State const &amp;s);\n</code></pre> <pre><code>ncols(s::State)\n</code></pre>"},{"location":"documentation/states/state/#col","title":"col","text":"<p>Returns a state created from the n-th column of the storage. Whether or not the storage is copied can be specified by setting the flag \"copy\".</p> C++Julia <pre><code>State col(State const &amp;s, int64_t n, bool copy = true);\n</code></pre> <pre><code>col(s::State, n::Int64 = 1; copy::Bool = true)\n</code></pre>"},{"location":"documentation/states/state/#vectorvectorc","title":"vector/vectorC","text":"<p>Returns a vector from the n-th column of the storage. In C++ use \"vector\"/\"vectorC\" to either get a real or complex vector.</p> C++Julia <pre><code>arma::vec vector(State const &amp;s, int64_t n = 0, bool copy = true);\narma::cx_vec vectorC(State const &amp;s, int64_t n = 0, bool copy = true);\n</code></pre> <pre><code>vector(state::State; n::Int64 = 1, copy::Bool=true)\n# no vectorC method in julia\n</code></pre>"},{"location":"documentation/states/state/#matrixmatrixc","title":"matrix/matrixC","text":"<p>Returns matrix representing the storage. In C++ use \"matrix\"/\"matrixC\" to either get a real or complex matrix.</p> C++Julia <pre><code>arma::vec matrix(State const &amp;s, bool copy = true);\narma::cx_vec matrixC(State const &amp;s, bool copy = true);\n</code></pre> <pre><code>matrix(state::State, copy::Bool=true)\n# no matrixC method in julia\n</code></pre>"},{"location":"documentation/states/state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto psi1 = State(block, arma::vec(\"1.0 2.0 3.0 4.0\"));\nXDIAG_SHOW(psi1);\nXDIAG_SHOW(vector(psi1));\nmake_complex(psi1);\nXDIAG_SHOW(vectorC(psi1));\n\nauto psi2 = State(block, false, 3);\nXDIAG_SHOW(psi2);\nXDIAG_SHOW(matrixC(psi2));\n\nauto psi3 = State(block, arma::cx_vec(arma::vec(\"1.0 2.0 3.0 4.0\"),\n                      arma::vec(\"4.0 3.0 2.0 1.0\")));\nXDIAG_SHOW(vectorC(psi3));\nXDIAG_SHOW(vector(real(psi3)));\nXDIAG_SHOW(vector(imag(psi3)));\n</code></pre> <pre><code>block = Spinhalf(2)\npsi1 = State(block, [1.0, 2.0, 3.0, 4.0])\n@show psi1\ndisplay(vector(psi1))\nmake_complex!(psi1)\ndisplay(vector(psi1))\n\npsi2 = State(block, real=false, n_cols=3)\n@show psi2\ndisplay(matrix(psi2))\n\npsi3 = State(block, [1.0+4.0im, 2.0+3.0im, 3.0+2.0im, 4.0+1.0im])\ndisplay(vector(psi3))\ndisplay(vector(real(psi3)))\ndisplay(vector(imag(psi3)))\n</code></pre>"},{"location":"documentation/symmetries/permutation/","title":"Permutation","text":"<p>Permutations of indices or lattice sites. Basic building block of a PermutationGroup. Permutations can be multiplied, inverted and raised to a power.</p> <p>Sources permutation.hpp permutation.cpp permutation.jl</p>"},{"location":"documentation/symmetries/permutation/#constructors","title":"Constructors","text":""},{"location":"documentation/symmetries/permutation/#from-an-array","title":"From an array","text":"<p>Creates an Permutation out of an array of integers, e.g. <code>{0, 2, 1, 3}</code>. If the input array is of size <code>N</code> then every number between <code>0</code> and <code>N-1</code> must occur exactly once, otherwise the Permutation is invalid.</p> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p> C++Julia <pre><code>Permutation(std::initializer_list&lt;int64_t&gt; list);\nPermutation(std::vector&lt;int32_t&gt; const &amp;array);\nPermutation(std::vector&lt;int64_t&gt; const &amp;array);\n</code></pre> <pre><code>Permutation(array::Vector{Int64})\n</code></pre> Name Description array array of integers, e.g. list initializer list of the permutation ptr pointer to memory as an array size size of the array"},{"location":"documentation/symmetries/permutation/#for-identity","title":"For identity","text":"<p>Constructs an identity permutation of a given size, e.g. <code>{0, 1, 2, 3}</code>.</p> C++Julia <pre><code>Permutation(int64_t size);\n</code></pre> <pre><code>Permutation(size::Int64)\n</code></pre> Name Description size size of the identity permutation"},{"location":"documentation/symmetries/permutation/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/permutation/#inv","title":"inv","text":"<p>Computes the inverse permutation.</p> C++Julia <pre><code>Permutation inv(Permutation const &amp;p);\n</code></pre> <pre><code>inv(perm::Permutation)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#operator","title":"* operator","text":"<p>Concatenates two permutations by overloading the <code>*</code> operator.</p> C++Julia <pre><code>Permutation operator*(Permutation const &amp;p1, Permutation const &amp;p2);\n</code></pre> <pre><code>Base.:*(p1::Permutation, p2::Permutation)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#operator-pow","title":"^ operator, pow","text":"<p>Raises a permutation to an integer power.</p> C++Julia <pre><code>Permutation pow(Permutation const &amp;p, int64_t power);\n</code></pre> <pre><code>Base.:^(p::Permutation, power::Int64)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#size","title":"size","text":"<p>Returns the size of a Permutation.</p> C++Julia <pre><code>int64_t size(Permutation const &amp;p);\n</code></pre> <pre><code>size(p::Permutation)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Permutation to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Permutation const &amp;perm);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Permutation const &amp;perm);\n</code></pre> <pre><code>to_string(perm::Permutation)::String\n</code></pre>"},{"location":"documentation/symmetries/permutation/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>Permutation p1 = {0, 2, 1, 3};\nPermutation p2 = {2, 0, 1, 3};\n\nXDIAG_SHOW(inv(p1));\nXDIAG_SHOW(p1*p2);\n</code></pre> <pre><code>p1 = Permutation([1, 3, 2, 4])\np2 = Permutation([3, 1, 2, 4])\n\n@show inv(p1)\n@show p1 * p2\n@show p1 ^ 2\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/","title":"PermutationGroup","text":"<p>A group of permutations. Group axioms are verified during construction.</p> <p>Sources permutation_group.hpp permutation_group.cpp permutation_group.jl</p>"},{"location":"documentation/symmetries/permutation_group/#constructor","title":"Constructor","text":""},{"location":"documentation/symmetries/permutation_group/#from-permutations","title":"From Permutations","text":"<p>Creates an PermutationGroup out of a vector of Permutation objects.</p> C++Julia <pre><code>PermutationGroup(std::vector&lt;Permutation&gt; const &amp;permutations);\n</code></pre> <pre><code>PermutationGroup(permutations::Vector{Permutation})\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#from-matrix","title":"From matrix","text":"<p>Creates a PermutationGroup out of a matrix whose rows specify the individual permutations. If a raw pointer is handed, the matrix is assumed to be in column-major form.</p> C++Julia <pre><code>PermutationGroup(arma::Mat&lt;int64_t&gt; const &amp;matrix);\nPermutationGroup(int64_t *ptr, int64_t n_permutations, int64_t nsites);\n</code></pre> <pre><code>PermutationGroup(matrix::Matrix{Int64})\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/permutation_group/#nsites","title":"nsites","text":"<p>Returns the number of sites on which the permutations of the group acts.</p> C++Julia <pre><code>int64_t nsites(PermutationGroup const &amp;group);\n</code></pre> <pre><code>nsites(group::PermutationGroup)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#size","title":"size","text":"<p>Returns the size of the permutation group, i.e. the number permutations.</p> C++Julia <pre><code>int64_t size(PermutationGroup const &amp;group);\n</code></pre> <pre><code>size(group::PermutationGroup)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the PermutationGroup to a readable string representation.</p> C++Julia <pre><code>std::string to_string(PermutationGroup const &amp;group);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, PermutationGroup const &amp;group);\n</code></pre> <pre><code>to_string(group::PermutationGroup)::String\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>// Define a cyclic group of order 3\nPermutation p1 = {0, 1, 2};\nPermutation p2 = {1, 2, 0};\nPermutation p3 = {2, 0, 1};\nauto C3 = PermutationGroup({p1, p2, p3});\n\nXDIAG_SHOW(C3.size());\nXDIAG_SHOW(C3.nsites());\n</code></pre> <pre><code># Define a cyclic group of order 3\np1 = Permutation([1, 2, 3])\np2 = Permutation([2, 3, 1])\np3 = Permutation([3, 1, 2])\nC3 = PermutationGroup([p1, p2, p3])\n\n@show size(C3)\n@show nsites(C3)\n</code></pre>"},{"location":"documentation/symmetries/representation/","title":"Representation","text":"<p>A (1D) irreducible representation of a finite group. Upon creation, the group homomorphism properties are verified.</p> <p>Sources representation.hpp representation.cpp representation.jl</p>"},{"location":"documentation/symmetries/representation/#constructors","title":"Constructors","text":""},{"location":"documentation/symmetries/representation/#trivial-representation","title":"Trivial representation","text":"<p>Creates the trivial representation (all characters equal to 1) of a PermutationGroup</p> C++Julia <pre><code>Representation(PermutationGroup const &amp;group);\n</code></pre> <pre><code>Representation(group::PermutationGroup)\n</code></pre>"},{"location":"documentation/symmetries/representation/#with-characters","title":"With characters","text":"<p>Creates a 1D representation of a PermutationGroup with given real or complex characters.</p> C++Julia <pre><code>template &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, std::vector&lt;T&gt; const &amp;characters);\ntemplate &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, arma::Col&lt;T&gt; const &amp;characters);\ntemplate &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, T *characters, int64_t n_characters);\n</code></pre> <pre><code>Representation(group::PermutationGroup, characters::Vector{Float64})\nRepresentation(group::PermutationGroup, characters::Vector{ComplexF64})\n</code></pre> Name Description group PermutationGroup of the Representation characters characters of the representation n_characters length of the array of characters <p>The template parameter <code>T</code> in C++ can either be <code>double</code> or <code>complex</code>.</p>"},{"location":"documentation/symmetries/representation/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/representation/#size","title":"size","text":"<p>Returns the size of the Representation, i.e. the number of group elements represented.</p> C++Julia <pre><code>int64_t size(Representation const &amp;irrep);\n</code></pre> <pre><code>size(irrep::Representation)::Int64\n</code></pre>"},{"location":"documentation/symmetries/representation/#isreal","title":"isreal","text":"<p>Returns the whether or not the Representation is real, I.E. the characters are real numbers and do not have an imaginary part.</p> C++Julia <pre><code>bool isreal(Representation const &amp;irrep) const;\n</code></pre> <pre><code>isreal(irrep::Representation)::Bool\n</code></pre>"},{"location":"documentation/symmetries/representation/#operator","title":"* operator","text":"<p>Multiplies two Representations by overloading the <code>*</code> operator.</p> C++Julia <pre><code>Representation operator*(Representation const &amp;r1, Representation const &amp;r2);\n</code></pre> <pre><code>Base.:*(r1::Representation, r2::Representation)::Representation\n</code></pre>"},{"location":"documentation/symmetries/representation/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Representation to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Representation const &amp;irrep);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Representation const &amp;irrep);\n</code></pre> <pre><code>to_string(irrep::Representation)::String\n</code></pre>"},{"location":"documentation/symmetries/representation/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>Permutation p = {1, 2, 3, 0};\nauto C4 = PermutationGroup({pow(p, 0), pow(p, 1), pow(p, 2), pow(p, 3)});\nRepresentation r1(C4, arma::vec{1.0, -1.0, 1.0, -1.0});\nRepresentation r2(C4, arma::cx_vec{1.0, 1.0i, -1.0, -1.0i});\nXDIAG_SHOW(r1 * r2);\n</code></pre> <pre><code>p = Permutation([2, 3, 4, 1])\nC4 = PermutationGroup([p^0, p^1, p^2, p^3])\nr1 = Representation(C4, [1.0, -1.0, 1.0, -1.0])\nr2 = Representation(C4, [1.0, 1.0im, -1.0, -1.0im])\n@show r1 * r2\n</code></pre>"},{"location":"documentation/utilities/logging/","title":"Logging","text":"<p>Sources logger.hpp, logger.cpp</p>"},{"location":"documentation/utilities/logging/#setting-the-verbosity","title":"Setting the verbosity","text":"<p>Algorithms implemented in XDiag do not output anything during their execution by default. However, it is typically useful to get some information on how the code is performing and even intermediary results at runtime. For this, the verbosity of the internal XDiag logging can be set using the function <code>set_verbosity</code>, which is defined as </p> C++Julia <pre><code>void set_verbosity(int64_t level);\n</code></pre> <pre><code>set_verbosity(level::Integer);\n</code></pre> <p>There are several levels of verbosity, defining how much information is shown.</p> level outputed information 0 no information 1 some information 2 detailed information <p>For example, when computing a ground state energy using the eigval0 function, we can set a higher verbosity level using</p> C++Julia <pre><code>set_verbosity(2);\ndouble e0 = eigval0(bonds, block);\n</code></pre> <pre><code>set_verbosity(2);\ne0 = eigval0(bonds, block);\n</code></pre> <p>This will print detailed information, which can look like this</p> <pre><code>Lanczos iteration 1\nMVM: 0.00289 secs\nalpha: -0.2756971549998545\nbeta: 1.7639347562074059\neigs: -0.2756971549998545\nLanczos iteration 2\nMVM: 0.00244 secs\nalpha: -0.7116140394927443\nbeta: 2.3044797637130743\neigs: -2.2710052270892791 1.2836940325966804\nLanczos iteration 3\nMVM: 0.00210 secs\nalpha: -1.2772539678430306\nbeta: 2.6627870395174456\neigs: -3.7522788386927637 -0.6474957945455240 2.1352094709026579\n</code></pre>"},{"location":"documentation/utilities/logging/#log-mechanism-c-only","title":"Log mechanism (C++ only)","text":"<p>Producing nicely formatted output is unfortunately a bit cumbersome in standard C++. For this, the <code>Log</code> mechanism in XDiag can help. To simply write out a line of information you can call,</p> <pre><code>Log(\"hello from the logger\");\n</code></pre> <p>By default, a new line is added. It is also possible to set verbosity by handing the level as the first argument,</p> <pre><code>Log(2, \"hello from the logger only if global verbosity is set to &gt;= 2\");\n</code></pre> <p>This message will only appear if the global verbosity level is set to a value \\(\\geq 2\\). Finally, XDiag also supports formatted output by using the fmtlib library. For example, numbers can be formated this way</p> <pre><code>Log(\"pi is around {:.4f} and the answer is {}\", 3.141592, 42);\n</code></pre>"},{"location":"documentation/utilities/timing/","title":"Timing","text":"<p>In standard C++ measuring time is a bit awkward. To quickly monitor the CPU time spent by XDiag by simple functions.</p>"},{"location":"documentation/utilities/timing/#simple-timing-using-tic-toc","title":"Simple timing using tic() / toc()","text":"<p>Similar as in Matlab one can use <code>tic()</code> and <code>toc()</code> to measure the time spent between two points in the code. </p> <pre><code>tic();\ndouble e0 = eigval0(bonds, block);\ntoc();\n</code></pre> <p><code>toc()</code> will output the time spent since the last time <code>tic()</code> has been called.</p>"},{"location":"documentation/utilities/timing/#detailed-timing","title":"Detailed timing","text":"<p>To get the present time, simply call </p> <pre><code>auto time = rightnow();\n</code></pre> <p>A timing (in second) between two time points can be written to output using</p> <pre><code>timing(begin, end);\n</code></pre> <p>This can even be accompanied by a message about what is being timed and a verbosity level (see Logging) can also be set. The full call signature is</p> <pre><code>timing(begin, end, message, level);\n</code></pre> Name Description Default begin starting time computed using <code>rightnow()</code> end end time computed using <code>rightnow()</code> message message string to be prepended to timing \"\" level verbosity level at which timing is printed 0"},{"location":"documentation/utilities/utils/","title":"Utility functions","text":""},{"location":"documentation/utilities/utils/#set_verbosity","title":"set_verbosity","text":"<p>Set how much logging is generated my XDiag to monitor the progress and behaviour of the code. There are three verbosity levels that can be set:</p> <ul> <li>0: no output at all</li> <li>1: some output </li> <li>2: detailed output </li> </ul> <p>This can be useful, e.g. to monitor the progress of an iterative algorithm</p> C++Julia <pre><code>void set_verbosity(int64_t level);\n</code></pre> <pre><code>set_verbosity(level::Int64)\n</code></pre>"},{"location":"documentation/utilities/utils/#say_hello","title":"say_hello","text":"<p>Prints a nice welcome message containing the version number and git commit used.</p> C++Julia <pre><code>void say_hello()\n</code></pre> <pre><code>say_hello()\n</code></pre>"},{"location":"documentation/utilities/utils/#print_version","title":"print_version","text":"<p>If <code>say_hello</code> is too much flower power for you, one can also just have a boring print-out of the version number using this function. </p> C++Julia <pre><code>void print_version()\n</code></pre> <pre><code>print_version()\n</code></pre>"},{"location":"documentation/utilities/xdiag_show/","title":"Debug printing","text":"<p>For quick debugging in C++, XDiag features a simple macro which outputs the name and content of a variable calles <code>XDIAG_SHOW(x)</code>. For example</p> <pre><code>Spinhalf block(16, 8);\nXDIAG_SHOW(block);\n</code></pre> <p>will write an output similar to</p> <pre><code>block:\n  nsites  : 16\n  nup     : 8\n  dimension: 12,870\n  ID       : 0xa9127434d66b9878\n</code></pre> <p>The <code>XDIAG_SHOW(x)</code> macro can be used on any XDiag object and several other standard C++ objects as well.</p>"},{"location":"examples/cmake_distributed/","title":"CMakeLists.txt for the distributed XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  tj_distributed_time_evolve\n)\n\nfind_package(xdiag_distributed REQUIRED HINTS ../../../install)\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre>"},{"location":"examples/cmake_normal/","title":"CMakeLists.txt for the normal XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/xdiag/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre>"},{"location":"examples/hello_world/","title":"Hello world!","text":"JuliaC++ <pre><code>   using XDiag\n   say_hello()\n</code></pre> <pre><code>   #include &lt;xdiag/all.hpp&gt;\n\n   using namespace xdiag;\n\n   int main() try {\n     say_hello();\n   } catch (Error e) {\n     error_trace(e);\n   }\n</code></pre>"},{"location":"examples/spinhalf_chain_e0/","title":"Groundstate energy","text":"JuliaC++ <pre><code>using XDiag\n\nlet \n    N = 16\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"HB\", \"J\", [i-1, i % N])\n    end\n    ops[\"J\"] = 1.0\n\n    set_verbosity(2)            # set verbosity for monitoring progress\n    e0 = eigval0(ops, block)    # compute ground state energy\n\n    println(\"Ground state energy: $e0\")\nend\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += Op(\"HB\", \"J\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre>"},{"location":"examples/tj_distributed_time_evolve/","title":"\\(t\\)-\\(J\\) distributed time evolution","text":"<pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nvoid measure_density(int nsites, State const &amp;v) {\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n  for (int i = 0; i &lt; nsites; ++i) {\n    complex sz = innerC(Bond(\"Ntot\", i), v);\n    if (rank == 0) {\n      printf(\"%.6f \", std::real(sz));\n    }\n  }\n  if (rank == 0) {\n    printf(\"\\n\");\n  }\n}\n\nint main(int argc, char **argv) try {\n  MPI_Init(&amp;argc, &amp;argv);\n\n  int L = 6;\n  int W = 4;\n  double t = 1.0;\n  double J = 0.1;\n  double mu_0 = 10;\n\n  int nsites = L * W;\n  double precision = 1e-12;\n\n  // Create square lattice t-J model\n  OpSum ops;\n  for (int x = 0; x &lt; L-1; ++x) {\n    for (int y = 0; y &lt; W; ++y) {\n      int nx = (x + 1) % L;\n      int ny = (y + 1) % W;\n\n      int site = x * W + y;\n      int right = nx * W + y;\n      int top = x * W + ny;\n      ops += Op(\"Hop\", \"T\", {site, right});\n      ops += Op(\"Exchange\", \"J\", {site, right});\n      ops += Op(\"Hop\", \"T\", {site, top});\n      ops += Op(\"Exchange\", \"J\", {site, top});\n\n\n\n      if (x &lt; L / 2) {\n    Log(\"x {} y {} site {} t {} r {} +\", x, y, site, top, right);\n        ops += Op(\"Ntot\", \"MUPLUS\", site);\n      } else {\n    Log(\"x {} y {} site {} t {} r {} -\", x, y, site, top, right);\n        ops += Op(\"Ntot\", \"MUNEG\", site);\n      }\n    }\n  }\n  ops[\"T\"] = t;\n  ops[\"J\"] = J;\n  ops[\"MUPLUS\"] = mu_0;\n  ops[\"MUNEG\"] = mu_0;\n\n  auto block = tJDistributed(nsites, nsites / 2 - 1, nsites / 2 - 1);\n\n  XDIAG_SHOW(block);\n\n  Log.set_verbosity(2);\n  tic();\n  auto [e0, v] = eig0(ops, block);\n  toc(\"gs\");\n\n  ops[\"MUPLUS\"] = 0;\n  ops[\"MUNEG\"] = 0;\n\n  measure_density(nsites, v);\n\n  // Do the time evolution with a step size tau\n  double tau = 0.1;\n  for (int i = 0; i &lt; 40; ++i) {\n    tic();\n    v = time_evolve(ops, v, tau, precision);\n    toc(\"time evolve\");\n    tic();\n    measure_density(nsites, v);\n    toc(\"measure\");\n  }\n\n  MPI_Finalize();\n  return EXIT_SUCCESS;\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre>"},{"location":"user_guide/first_steps/","title":"First steps","text":""},{"location":"user_guide/first_steps/#writing-code","title":"Writing code","text":"<p>Let us set up our first program using the <code>xdiag</code> library. </p> JuliaC++ <pre><code>using XDiag\nsay_hello()\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information which exact XDiag version is used. In Julia this is all there is to it.</p> <p>For the C++ code we need to create two files to compile the program. The first is the actual <code>C++</code> code. What is maybe a bit unfamiliar is the <code>try / catch</code> block. XDiag implements a traceback mechanism for runtime errors, which is activated by this idiom. While not stricly necessary here, it is a good practice to make use of this.</p>"},{"location":"user_guide/first_steps/#compilation","title":"Compilation","text":"<p>Now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/xdiag/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <p><pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> and finally run our first XDiag application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"user_guide/first_steps/#hilbert-spaces","title":"Hilbert spaces","text":"<p>We are now ready to run our first actual calculation using XDiag. Our immediate goal will be to determine the ground state energy of a \\(S=1/2\\) Heisenberg model on a 1D chain lattice with periodic boundary conditions,</p> \\[ H = J \\sum_{\\langle i, j\\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j,\\] <p>where \\(\\mathbf{S}_i = (S^x_i, S^y_i, S^z_i)\\) denotes the vector of spin matrices at a given site \\(i\\). The notation \\(\\langle i, j\\rangle\\) refers to summatation over neighboring sites \\(i\\) and \\(j\\).</p> <p>The first thing to define before any computation, is the Hilbert space our model will be defined on. For the present example, we use the Hilbert space class Spinhalf. We consider a chain lattice with \\(N=8\\) sites and create a \\(S=1/2\\) Hilbert space:</p> C++ <pre><code>using namespace xdiag;\nint N = 8;\nauto hspace = Spinhalf(N);\n</code></pre> <p>We would like to know which spin configurations, the Hilbert space is made up of. To do so, we can iterate over the Hilbert space and print out the spin configurations. </p> C++ <pre><code>for (auto spins : hspace) {\n  Log(\"{}\", to_string(spins));\n}\n</code></pre> <p>This produces an output similar to the following:</p> <pre><code>\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\n\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2191\n\u2193\u2193\u2193\u2193\u2193\u2193\u2191\u2193\n\u2193\u2193\u2193\u2193\u2193\u2193\u2191\u2191\n\u2193\u2193\u2193\u2193\u2193\u2191\u2193\u2193\n\u2193\u2193\u2193\u2193\u2193\u2191\u2193\u2191\n\u2193\u2193\u2193\u2193\u2193\u2191\u2191\u2193\n...\n</code></pre> <p>Here we already see several things at work. XDiag features a convenient way to write logs, with the Log class. The first argument to <code>Log()</code> is a format string. In C++ we use the fmt library, to be able to write structured format and format our output. The second argument turns our <code>spins</code> into a string. <code>spins</code> is of type ProductState, whose configuration on each site can be individually addressed. </p> <p>Further, we notice that all \\(2^N\\) spin configurations are included in this Hilbert space. However, the Heisenberg model conserves the total \\(S^z = \\sum_i S^z_i\\), and thus we could limit ourselves to a block of the Hilbert space, which only contains configurations of a certain magnetization: </p> C++ <pre><code>int nup = 4;\nauto block = Spinhalf(N, nup);\nfor (auto spins : block) {\n  Log(\"{}\", to_string(spins));\n}\n</code></pre> <p>This produces an output similar to: <pre><code>\u2193\u2193\u2193\u2193\u2191\u2191\u2191\u2191\n\u2193\u2193\u2193\u2191\u2193\u2191\u2191\u2191\n\u2193\u2193\u2193\u2191\u2191\u2193\u2191\u2191\n\u2193\u2193\u2193\u2191\u2191\u2191\u2193\u2191\n\u2193\u2193\u2193\u2191\u2191\u2191\u2191\u2193\n\u2193\u2193\u2191\u2193\u2193\u2191\u2191\u2191\n\u2193\u2193\u2191\u2193\u2191\u2193\u2191\u2191\n...\n</code></pre></p> <p>We see that the block now only contains configurations, where the total number of spins pointing up is 4. We can now quickly check the dimension of the Hilbert spaces, and confirm that the dimension of the block is reduced from \\(2^8=256\\) to \\(\\begin{pmatrix} 8 \\\\ 4 \\end{pmatrix} = 70\\),</p> C++ <pre><code>XDIAG_SHOW(hspace.size());\nXDIAG_SHOW(block.size());\n</code></pre> <p>which should print: <pre><code>hspace.size():\n256\nblock.size():\n70\n</code></pre></p> <p>Here, we introduced another functionality of XDiag, the XDIAG_SHOW macro which can be used for quick debug printing of XDiag objects.</p>"},{"location":"user_guide/input_output/","title":"Input/Output","text":"<p>Julia features a variety of packages facilitating input and output of data. For C++, we provide convenient functionality for TOML and HDF5 files.</p>"},{"location":"user_guide/input_output/#toml","title":"TOML","text":"<p>For simulations is can often be useful to read input paramters from a file. The </p>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#julia-installation","title":"Julia installation","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and type: <pre><code>add XDiag\n</code></pre></p> <p>That's it!</p>"},{"location":"user_guide/installation/#c-compilation","title":"C++ compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. The library can be compiled in two different versions:</p> <ul> <li>Normal library: features parallelization using OpenMP only</li> <li>Distributed library: features distributed-memory parallelization using MPI. </li> </ul>"},{"location":"user_guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"user_guide/installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul> <p>The compilation process can be modified and also allows for further optimizations. We collect several common scenarios in the Advanced Compilation guide.</p>"}]}