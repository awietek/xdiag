{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Quick Start Code on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>XDiag is a library for performing Exact Diagonalizations of quantum many-body systems. Key features include optimized combinatorical algorithms for navigating Hilbert spaces, iterative linear algebra algorithms,  shared and distributed memory parallelization. It consist of two packages:</p> <ul> <li>The core C++ library xdiag</li> <li>The convenient Julia wrapper library XDiag.jl</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Our software paper in now available on the arXiv: XDiag software paper.</p> <p>Please support our work by citing XDiag and the implemented algorithms if it is used in your published research.</p> <pre><code>@article{xdiag,\nAuthor = {Alexander Wietek and Luke Staszewski and Martin Ulaga and Paul L. Ebert and Hannes Karlsson and Siddhartha Sarkar and Henry Shackleton and Aritra Sinha and Rafael D. Soares},\nTitle = {XDiag: Exact Diagonalization for quantum many-body systems},\nYear = {2025},\njournal = {arXiv preprints},\neprint = {arXiv:2505.02901},\narchivePrefix = {arXiv},\nprimaryClass = {cond-mat.str-el}\n}\n</code></pre> <p>If you are using the sublattice coding techniques or distributed memory parallelization, please also cite the following paper.</p> <pre><code>@article{Wietek2018,\n  title = {Sublattice coding algorithm and distributed memory parallelization for large-scale exact diagonalizations of quantum many-body systems},\n  author = {Wietek, Alexander and L\\\"auchli, Andreas M.},\n  journal = {Phys. Rev. E},\n  volume = {98},\n  issue = {3},\n  pages = {033309},\n  numpages = {10},\n  year = {2018},\n  month = {Sep},\n  publisher = {American Physical Society},\n  doi = {10.1103/PhysRevE.98.033309},\n  url = {https://link.aps.org/doi/10.1103/PhysRevE.98.033309}\n}\n</code></pre>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"about/","title":"About","text":""},{"location":"about/#main-developer","title":"Main developer","text":"Alexander Wietek  Group Leader   Superconductivity and Magnetic Correlations  Max Planck Institute for the Physics of Complex Systems www.pks.mpg.de/smc awietek _at_ pks.mpg.de"},{"location":"about/#scientific-advisor","title":"Scientific advisor","text":"Andreas M. L\u00e4uchli  Full Professor  \u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne [link] Paul Scherrer Institute [link]"},{"location":"about/#contributors","title":"Contributors","text":"<p> Feature implementation  Example implementation  Bug report and fix  Documentation</p> Paul Ebert  PhD Student  Max Planck Institute for the Physics of Complex Systems Hannes Karlsson  PhD Student  Max Planck Institute for the Physics of Complex Systems Siddhartha Sarkar PostDoc  Max Planck Institute for the Physics of Complex Systems Aritra Sinha PostDoc  Max Planck Institute for the Physics of Complex Systems Rafael D. Soares  PhD Student  Max Planck Institute for the Physics of Complex Systems Luke Staszewski  PhD Student  Max Planck Institute for the Physics of Complex Systems Martin Ulaga  PostDoc  Max Planck Institute for the Physics of Complex Systems"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>To properly highlight XDiag's paralellization performance, we benchmark the computation time of the key operation behind all main features implemented in XDiag: the execution of a single Lanczos iteration, consisting of a matrix-vector multiplication and a few vector operations. </p> <p>To evaluate performance across all Hilbert space types supported by XDiag\u2014namely the Spinhalf, Electron and tJ blocks - we consider three distinct models:</p> <ol> <li>The \\(S= 1/2\\) one-dimensional Heisenberg chain with nearest-neighbor interactions,</li> </ol> <p>$$    H = J \\sum_{\\langle i,j\\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j.    $$</p> <ol> <li>The one-dimensional Hubbard model,</li> </ol> <p>$$    H = -t \\sum_{\\langle i,j\\rangle, \\; \\sigma} \\left(c^\\dagger_{i,\\sigma}c_{j,\\sigma} + \\text{h.c.} \\right) + U \\sum_{i=0}^{N} n_{i,\\uparrow} n_{i,\\downarrow}.    $$</p> <ol> <li>The t-J model of spin-\\(\\frac{1}{2}\\) electrons,</li> </ol> <p>$$    H = -t \\sum_{\\langle i,j \\rangle, \\sigma} P \\left( c^\\dagger_{i,\\sigma} c_{j,\\sigma} + \\text{h.c.} \\right) P + J \\sum_{\\langle i , j \\rangle } \\mathbf{S}_i \\cdot \\mathbf{S}_j - n_i n_j/4.     $$</p> <p>XDiag supports both multithreading with OpenMP and multiprocessing with MPI. We provide benchmarks for all three computational models using both parallelisation strategies. Please note that in the current version, MPI-based parallelisation does not support lattice symmetries. </p> <p>Throughout the following, all reported computation times refer to wall time, not CPU time.</p>"},{"location":"benchmarks/#shared-memory-parallelization","title":"Shared memory parallelization","text":"<p>We demonstrate how the computation time for a single Lanczos step varies with the number of OpenMP threads used for shared-memory parallelisation. </p> <p>In addition to the U(1) symmetry\u2014associated with the conservation of total magnetization in the Heisenberg model, or the conservation of total particle number in the Hubbard and t-J models\u2014 we also exploit lattice translation symmetries to perform the calculations (see Symmetries). </p> <p>Concrealy we consider:</p> <ul> <li>Heisenberg model: \\(N=28\\), \\(N=32\\), \\(N=36\\) and \\(N=40\\) at zero magnetization.</li> <li>Hubbard model: \\(N = 16\\), \\(N = 18\\), and \\(N = 20\\) at half-filling.</li> <li>t-J model: \\(N=28\\), \\(N=30\\) and \\(N=32\\) with two holes and at zero magnetization.</li> </ul> <p>The benchmarks presented were performed on a single node equipped with an Intel Xeon\u00ae Platinum 8360Y (Ice Lake) 2.4 GHz processor.</p> <p> Figure: Scaling of the computation time for a single Lanczos iteration as a function of the total number of threads used. The calculations were done for the Heisenberg (a), Hubbard (b), and t-J (c) models. The solid black line in each panel represents ideal linear scaling. U(1) and lattice symmetries were used in all cases.</p> <p>In the figure above, we present the scaling of the computational time of a single Lanczos step with the total number of threads used. The time follows near-linear scaling with the number of OpenMP threads, decreasing with the inverse of the thread count.</p>"},{"location":"benchmarks/#table-computation-times-with-openmp-64-threads","title":"Table: Computation times with OpenMP (64 threads)","text":"Block N Symmetries Block Size Time (s) Spinhalf 40 U(1) and Lattice \\(1.7 \\cdot 10^{9}\\) \\(131 \\pm 1\\) Spinhalf 36 U(1) and Lattice \\(1.3 \\cdot 10^{8}\\) \\(7.60 \\pm 0.2\\) Spinhalf 32 U(1) and Lattice \\(9.3 \\cdot 10^{6}\\) \\((5.1 \\pm 0.1)\\cdot 10^{-1}\\) Spinhalf 28 U(1) and Lattice \\(7.2 \\cdot 10^{5}\\) \\((9 \\pm 2)\\cdot 10^{-2}\\) Electron 22 U(1) and Lattice \\(2.2 \\cdot 10^{10}\\) \\(138 \\pm 5\\) Electron 20 U(1) and Lattice \\(1.0 \\cdot 10^{9}\\) \\(10.9 \\pm 0.1\\) Electron 18 U(1) and Lattice \\(1.3 \\cdot 10^{8}\\) \\(7.64 \\pm 0.01\\) Electron 16 U(1) and Lattice \\(1.0 \\cdot 10^{7}\\) \\(5.37 \\pm 0.01\\) tJ 32 U(1) and Lattice \\(2.0 \\cdot 10^{9}\\) \\(75.9 \\pm 0.1\\) tJ 30 U(1) and Lattice \\(5.8 \\cdot 10^{8}\\) \\(17.95 \\pm 0.05\\) tJ 28 U(1) and Lattice \\(1.4 \\cdot 10^{8}\\) \\(3.84 \\pm 0.02\\) <p>We can observe that the multithreading parallelization of XDiag exhibits close-to-linear scaling up to 64 threads.</p>"},{"location":"benchmarks/#distributed-memory-parallelization","title":"Distributed memory parallelization","text":"<p>Figure: Scaling of the computation time for a single Lanczos iteration as a function of the total number of MPI processes used. Calculations were done for Heisenberg (a), Hubbard (b), and t-J (c) models. Ideal linear scaling is shown as a reference.</p> <p>XDiag also supports distributed-memory parallelization via MPI for the SpinhalfDistributed, ElectronDistributed, and  tJDistributed blocks. Benchmarks were performed on the Max Planck Society's Raven supercomputer (Intel Xeon\u00ae Platinum 8360Y, HDR100 interconnect, 72 cores per node).</p> <p>Only U(1) symmetries were used in these benchmarks, with the following parameters:</p> <ul> <li>Heisenberg model: \\(N=36\\), \\(N=40\\) and \\(N=42\\) at zero magnetization.</li> <li>Hubbard model: \\(N=20\\) (half-filling), \\(N=22\\) and \\(N=24\\) with \\(n_\\uparrow = n_\\downarrow = 8\\).</li> <li>t-J model: \\(N=28\\), \\(N=32\\) with two holes and at zero magnetization.</li> </ul>"},{"location":"benchmarks/#table-computation-times-with-mpi","title":"Table: Computation times with MPI","text":"Block N Symmetries Block Size MPI Processes Time (s) Spinhalf 42 U(1) \\(5.4 \\cdot 10^{11}\\) 18432 \\(31.4 \\pm 0.5\\) Spinhalf 40 U(1) \\(1.4 \\cdot 10^{11}\\) 18432 \\(7.9 \\pm 0.1\\) Spinhalf 36 U(1) \\(9.0 \\cdot 10^{9}\\) 2304 \\(3.1 \\pm 0.2\\) Electron 24 U(1) \\(5.4 \\cdot 10^{11}\\) 18432 \\(21.0 \\pm 0.2\\) Electron 22 U(1) \\(1.0 \\cdot 10^{11}\\) 18432 \\(4.3 \\pm 0.1\\) Electron 20 U(1) \\(3.4 \\cdot 10^{10}\\) 2304 \\(7.7 \\pm 0.5\\) tJ 32 U(1) \\(7.6 \\cdot 10^{10}\\) 4608 \\(42.2 \\pm 0.5\\) tJ 28 U(1) \\(3.9 \\cdot 10^{9}\\) 4608 \\(2.3 \\pm 0.4\\) <p>We observe that computation time scales nearly inversely with the number of MPI processes, demonstrating strong scaling up to several thousand processes.</p>"},{"location":"contributing/","title":"Contributing to XDiag","text":"<p>Thank you for considering contributing to xdiag! We welcome contributions from everyone. This document outlines the process and guidelines for contributing to this project.</p>"},{"location":"contributing/#major-contributions","title":"Major contributions","text":"<p>Our goal is to have regular software publications in SciPost Physics Codebases with updated major versions. We offer co-authorship for developers who provide major contributions. These include:</p> <ul> <li>Advanced new features: This may include implementation of a new block type, a new iterative algorithm, or novel operators and measurements</li> <li>Major contributions to the documentations: This would include writing extended tutorials, or contributing a significant number of examples. </li> </ul> <p>We recommend to propose a major new feature in the Discussions first, such that we can give feedback to a possible enhancement.</p>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Ensure the bug was not already reported by searching on GitHub under Issues. If you're unable to find an open issue addressing the problem, open a new one. Be sure to include a title and clear description, as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.</p>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>Open an issue with the label enhancement and describe your suggestion in detail. Explain why this enhancement would be useful to the project and how it can be implemented.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li>Fork the repository and create your branch from main.</li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> <li>Ensure the test suite passes.</li> <li>Issue that pull request!</li> </ul>"},{"location":"contributing/#code-review-process","title":"Code Review Process","text":"<p>All submissions, including submissions by project members, require review. Focus on the following aspects during the review: - Design: Is the code well-designed and appropriate for the use case? - Functionality: Does the code behave as expected? - Complexity: Could the code be made simpler? - Tests: Does the code have appropriate tests? - Documentation: Is the code well-documented?</p>"},{"location":"contributing/#community","title":"Community","text":"<p>Join our Discussions to engage with the community, ask questions, and share ideas.</p> <p>This guide provides a comprehensive overview of how to contribute to the xdiag project. If you have any questions or need further assistance, feel free to reach out to the maintainers or the community. Happy contributing!</p>"},{"location":"examples/","title":"Examples","text":"<p>While we present core functionality in the User Guide, we here provide several examples along with XDiag to demonstrate how we can build more advanced applications from these basic building blocks. The examples are provided in the directory <code>examples</code> in the C++ source code directory, and can be compiled using CMake.</p> <pre><code>cmake -S . -B build -D BUILD_EXAMPLES=On\ncmake --build build\n</code></pre> <p>The executables are then available in the directory <code>build/examples</code>. Most examples are also provided as a Julia script, and visualization scripts for the results are available.</p>"},{"location":"examples/#ground-states","title":"Ground states","text":"<ul> <li> <p> Ground state energy</p> <p>Computes the ground state energy of a simple Heisenberg spin \\(S=1/2\\) chain</p> <p>source </p> </li> <li> <p> Ground state correlators</p> <p>Computes ground state correlators of a simple Heisenberg spin \\(S=1/2\\) chain with the help of symmetries.</p> <p>source </p> </li> <li> <p> Entanglement entropy ground state</p> <p>Computes ground state entanglement entropy of an XXZ spin \\(S=1/2\\) chain.</p> <p></p> <p>source </p> </li> <li> <p> CDW in attractive Hubbard model</p> <p>Computes charge correlations in the ground state of the attractive 2D Hubbard model.</p> <p></p> <p>source </p> </li> <li> <p> Kitaev-Heisenberg honeycomb model</p> <p>Computes the ground state of the Heisenberg-Kitaev model throughout its phase diagram</p> <p></p> <p>source </p> </li> </ul>"},{"location":"examples/#full-exact-diagonalization","title":"Full exact diagonalization","text":"<ul> <li> <p> Specific heat random t-J model</p> <p>Computes the specific heat of the random t-J model via full ED over multiple disorder realizations.</p> <p></p> <p>source </p> </li> <li> <p> Specific heat triangular t-J model</p> <p>Computes the specific heat of the triangular t-J model via full ED.</p> <p></p> <p>source </p> </li> <li> <p> Spin chain level statistics</p> <p>Demonstrates Poissonian and Wigner-Dyson level statistics of integrable and non-integrable spin chains, respectively.</p> <p></p> <p>source </p> </li> <li> <p> Many-body localization</p> <p>Studies hallmark diagonstics of a many-body localized system.</p> <p></p> <p>source </p> </li> </ul>"},{"location":"examples/#tower-of-states","title":"Tower of States","text":"<ul> <li> <p> TOS \\(\\alpha \\text{XX}\\) chain</p> <p>Performs a tower of states analysis for the \\(\\alpha \\text{XX}\\) chain.</p> <p></p> <p>source </p> </li> <li> <p> Heisenberg chain momentum resolved</p> <p>Performs a (momentum) tower of states analysis for the antiferromagnetic chain.</p> <p></p> <p>source </p> </li> <li> <p> Square lattice Heisenberg model</p> <p>Performs a tower of states analysis for the Heisenberg model in the square lattice.</p> <p></p> <p>source </p> </li> <li> <p> \\(J_1 - J_2\\) model triangular lattice</p> <p>Performs a tower of states analysis for the \\(J_1 - J_2\\) model in the triangular lattice.</p> <p></p> <p>source </p> </li> <li> <p> \\(J_1 - J_2 - J_3\\) Model in the kagome lattice</p> <p>Performs a tower of states analysis for an extended kagome lattice Heisenberg antiferromagnet.</p> <p></p> <p>source </p> </li> <li> <p> Attractive Hubbard model</p> <p>Performs a tower of states analysis for the superconducting state in the attractive Hubbard model. </p> <p>source </p> </li> </ul>"},{"location":"examples/#dynamical-spectral-functions","title":"Dynamical spectral functions","text":"<ul> <li> <p> Spin structure factor</p> <p>Computes the dynamical spin structure factor of a spin \\(S=1/2\\) chain</p> <p></p> <p>source </p> </li> <li> <p> Green's function</p> <p>Computes the Green's function in a 2D Hubbard model</p> <p></p> <p>source </p> </li> <li> <p> Optical conductivity</p> <p>Computes the optical conductivity of one hole in a t-J model.</p> <p></p> <p>source </p> </li> </ul>"},{"location":"examples/#time-evolution","title":"Time Evolution","text":"<ul> <li> <p> Domain wall dynamics</p> <p>Demonstrates the time evolution of a domain wall in the \\(S=1/2\\) XXZ chain. </p> <p>source </p> </li> <li> <p> Slow quench</p> <p>Demonstrates the implementation of slow quench in the \\(S=1/2\\) Ising chain.</p> <p></p> <p>source </p> </li> <li> <p> Hubbard interaction quench</p> <p>Demonstrates the implementation of an interaction quench in the 2D Hubbard model.</p> <p></p> <p>source </p> </li> </ul>"},{"location":"examples/#thermodynamics","title":"Thermodynamics","text":"<ul> <li> <p> Specific heat Shastry-Sutherland</p> <p>Computes the specific heat using the TPQ states (finite temperature Lanczos method) for the Shastry Sutherland model.</p> <p></p> <p>source </p> </li> <li> <p> Wilson ratio \\(J_1\\)-\\(J_2\\) square lattice</p> <p>Computes the Wilson ratio using the TPQ states (finite temperature Lanczos method) for the \\(J_1\\)-\\(J_2\\) model on the square lattice</p> <p></p> <p>source </p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#julia-installation","title":"Julia Installation","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and type: <pre><code>add XDiag\n</code></pre></p> <p>That's it!</p>"},{"location":"installation/#c-compilation","title":"C++ Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. Here we explain how to compile the library.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul>"},{"location":"installation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building the Julia wrapper locally</p> <p>First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> </li> </ul>"},{"location":"installation/#building-documentation","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To work on it locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#julia","title":"Julia","text":"<p>To install XDiag, enter the package mode in the Julia REPL using <code>]</code> and type</p> <pre><code>add XDiag\n</code></pre> <p>That's it! Now we are ready to perform our first exact diagonalization. We compute the ground state energy of the \\(S=1/2\\) Heisenberg chain on a periodic chain lattice in one dimension. The Hamiltonian is given by</p> \\[ H = J\\sum_{\\langle i,j \\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j\\] <p>where \\(\\mathbf{S}_i = (S_i^x, S_i^y, S_i^z)\\) are the spin \\(S=1/2\\) operators and \\(\\langle i,j \\rangle\\) denotes summation over nearest-meighbor sites \\(i\\) and \\(j\\).</p> <pre><code>using XDiag\n\nlet\n    say_hello()\n    N = 16\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    set_verbosity(2)            # set verbosity for monitoring progress\n    e0 = eigval0(ops, block)    # compute ground state energy\n\n    println(\"Ground state energy: $e0\")\nend\n</code></pre> <p>For more examples, see our Example Collection.</p>"},{"location":"quick_start/#c","title":"C++","text":"<p>Using XDiag with C++, we first need to compile the XDiag library, see the Library compilation instructions. Then, our application code looks like this:</p> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <p>The <code>try / catch</code> clause implements an error trace mechanism, which we recommend for every XDiag application. The application is then compiled as well, see Application compilation instructions, resulting in our final executable.</p> <p>The C++ versions offers the opportunity to optimize compilation the code for the target architecture, see C++ optimization</p>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#v032","title":"v0.3.2","text":"<p>Apr. 3, 2025</p> <p>ElectronDistributed and further enhancements</p> <ul> <li>Adds new block type: ElectronDistributed</li> <li>Added benchmarks</li> <li>linking to threaded Intel MKL enabled</li> <li>several enhancements and bugfixes</li> </ul>"},{"location":"releases/#v031","title":"v0.3.1","text":"<p>Feb. 11, 2025</p> <p>New API and operator logic</p> <ul> <li>Updated to a new streamlined API</li> <li>Implemented operator logic including symmetries</li> <li>Completed wrapper for Julia</li> <li>w = apply(ops, v) works now</li> </ul>"},{"location":"releases/#v023","title":"v0.2.3","text":"<p>Sep. 9, 2024</p> <p>Introduced 1-indexing everywhere in Julia version</p> <ul> <li>only changes to XDiag.jl, C++ untouched</li> <li>XDiag_jll.jl remains at v0.2.2</li> </ul>"},{"location":"releases/#v022","title":"v0.2.2","text":"<p>Aug. 27, 2024</p> <p>Lanczos routines and multicolumn States</p> <ul> <li>wrapped eigs_lanczos, eigvals_lanczos</li> <li>implemented apply for States with multiple columns</li> <li>changed wrapping of std::vectors of Op and Permutation</li> </ul>"},{"location":"releases/#v021","title":"v0.2.1","text":"<p>Aug. 16, 2024</p> <p>Small patch release providing small utility functions</p> <ul> <li>wrapped say_hello, print_version, and set_verbosity</li> <li>resorted to compiling wrapper with conventional OpenMP on aarch64 apple</li> <li>Fixed faulty behaviour of OpenMP on aarch64 apple</li> </ul>"},{"location":"releases/#v020","title":"v0.2.0","text":"<p>Aug. 15, 2024</p> <p>Basic functionality for three Hilbert space types, Spinhalf, tJ, and Electron, has been implemented. Features are:</p> <ul> <li>Algebra with and without permutation symmetries</li> <li>Parallelization with OpenMP and MPI</li> <li>CMake has been properly set up</li> <li>Iterative algorithms present, Lanczos, Arnoldi, time evolution</li> <li>A minimal Julia wrapper has been written</li> <li>The Julia wrapper compiles on several target 64bit systems using BinaryBuilder</li> </ul>"},{"location":"user_guide/","title":"User guide","text":"<p>A step-by-step guide to using XDiag</p>"},{"location":"user_guide/#installation","title":"Installation","text":""},{"location":"user_guide/#julia-library","title":"Julia library","text":"<p>XDiag can conveniently be installed via the Julia package manager. First, a Julia interpreter needs to be opened from a command line using <code>julia</code>. Then, the \"package mode\" can be entered by typing <code>]</code>, and XDiag is installed using <code>add XDiag</code>. In summary:</p> Bash <pre><code>$ julia\njulia&gt; ]\npkg&gt; add XDiag\n</code></pre>"},{"location":"user_guide/#c-library","title":"C++ library","text":"<p>The first step in employing the C++ version is to compile the library. The source code can be obtained from github by cloning using git.</p> Bash <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre> <p>The compilation and installation is then performed with CMake </p> Bash <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre> <p>By default, the resulting library is installed at <code>/path/to/where/xdiag/should/be/install</code>. There are various options when compiling, including optimizations that can be used. For more details on the compilation process, we refer to the compilation guide.</p>"},{"location":"user_guide/#writing-application-code","title":"Writing application code","text":"<p>To employ the XDiag library, an application code is written. The simplest application using XDiag is a <code>hello_world</code> program.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nsay_hello()\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information on which exact XDiag version is used. We would like to emphasize the <code>try / catch</code> block in the C++ version. XDiag implements a traceback mechanism for runtime errors, which is activated by the <code>error_trace</code> function. While not strictly necessary here, it is a good practice to employ this.</p>"},{"location":"user_guide/#application-compilation","title":"Application compilation","text":"<p>In C++, now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> CMake <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(hello_world)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/where/xdiag/should/be/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>/path/to/where/xdiag/should/be/install</code> with the appropriate directory where your XDiag library is installed after compilation. We then compile the application code,</p> Bash <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our first XDiag application.</p> Bash <pre><code>./build/main\n</code></pre>"},{"location":"user_guide/#usage-guide","title":"Usage Guide","text":"<p>After installation or library compilation, the user is ready to run the first calculation using XDiag. For the purpose of this usage guide, our immediate goal is to determine the ground state energy of a \\(S=1 / 2\\) Heisenberg model on a 1D chain lattice with periodic boundary conditions,</p> \\[ H=J \\sum_{\\langle i, j\\rangle} \\mathbf{S}_{i} \\cdot \\mathbf{S}_{j}, \\] <p>where \\(\\mathbf{S}_{i}=\\left(S_{i}^{x}, S_{i}^{y}, S_{i}^{z}\\right)\\) denotes the vector of spin matrices at a given site \\(i\\). The notation \\(\\langle i, j\\rangle\\) refers to summation over neighboring sites \\(i\\) and \\(j\\). In the following, we will discuss how to set up such a calculation and give an overview of further functionality in XDiag.</p>"},{"location":"user_guide/#hilbert-spaces","title":"Hilbert spaces","text":"<p>The first thing to define before any computation is the Hilbert space our model will be defined on. For this, we create an object of type Spinhalf and hand as an argument the number of physical sites \\(N\\).</p> C++Julia <pre><code>int N = 8;\nauto hs = Spinhalf(N);\n</code></pre> <pre><code>N = 8\nhs = Spinhalf(8)\n</code></pre> <p>We would like to know which spin configurations the Hilbert space is made up of. To do so, we can iterate over the Hilbert space and print out the configurations and the total Hilbert space dimension.</p> C++Julia <pre><code>for (auto spins : hs) {\n  Log(\"{}\", to_string(spins));\n  Log(\"{}\", index(hs, spins));\n}\nLog(\"dim: {}\", size(hs));\n</code></pre> <pre><code>for spins in hs\n    println(to_string(spins))\n    println(index(hs, spins))\nend\nprintln(\"dim: \", size(hs))\n</code></pre> <p>XDiag features a convenient way to write logs in C++, with the Log class. The first argument to <code>Log()</code> is a format string. In C++ we use the fmt library to be able to write formatted output. The second argument turns our spins into a string. <code>spins</code> is of type ProductState, whose configuration on each site can be individually addressed by using the <code>[]</code> operator. The opposite task of computing the index of a given <code>ProductState</code> within the block basis can be addressed using the <code>index</code> function. An important difference between C++ and Julia is that indices are counted starting from <code>0</code> in C++ and <code>1</code> in Julia. Hence, also in the above code snippet, the C++ version will start counting the indices from <code>0</code> and Julia from <code>1</code>.</p> <p>The precise output depends on which Hilbert space is chosen. At present, XDiag features three distinct types of Hilbert spaces:</p> <ul> <li>Spinhalf: \\(S=1/2\\) spins; each site is either occupied by an \\(\\uparrow\\)-spin or a \\(\\downarrow\\)-spin.</li> <li>Electron: spin \\(S=1/2\\) electrons; each site is either empty \\(\\emptyset\\), occupied by an \\(\\uparrow\\)-spin or \\(\\downarrow\\)-spin electron, or is doubly occupied \\(\\updownarrow\\).</li> <li>tJ: spin \\(S=1/2\\) electrons without double occupancies; each site is either empty \\(\\emptyset\\), occupied by an \\(\\uparrow\\)-spin or \\(\\downarrow\\)-spin electron.</li> </ul> <p>Frequently, many-body systems feature certain symmetries and conservation laws. Common conservation laws include particle number, spin, or momentum conservation. The Hilbert space can then be subdivided into blocks, which are labeled by the respective conserved quantities. Blocks of a Hilbert space with a given particle number can be easily created by handing further arguments when constructing the Hilbert space specifying the particle numbers. The number of \\(\\uparrow\\)-spins in a Spinhalf block can be specified via,</p> C++Julia <pre><code>int nup = 2;\nauto b1 = Spinhalf(N, nup);\n\nint ndn = 1;\nauto b2 = tJ(N, nup, ndn);\nauto b3 = Electron(N, nup, ndn);\n</code></pre> <pre><code>nup = 2\nb1 = Spinhalf(N, nup)\n\nndn = 1\nb2 = tJ(N, nup, ndn)\nb3 = Electron(N, nup, ndn)\n</code></pre> <p>The result of printing out the configurations of specific blocks is shown in the figure below. This enumeration is important to interpret coefficients of wave functions. By printing out the basis states of spin configurations, the user can also assess how computational basis states are ordered internally in XDiag.</p> <p></p>"},{"location":"user_guide/#operators","title":"Operators","text":"<p>Besides Hilbert spaces, the second key objects in quantum mechanics are operators. In a many-body setting, we consider operators of the form, $$     O = \\sum_{A\\subseteq \\mathcal{L}} c_A O_A, $$ where \\(O_A\\) denotes a local operator acting on sites \\(A=\\{a_1, \\ldots, a_{l_A}\\}\\) and \\(\\mathcal{L}\\) denotes the lattice and \\(c_{A}\\) are coupling constants. In the case of the Heisenberg model, we would thus have \\(\\mathcal{O}_{A} = \\mathbf{S}_i\\cdot\\mathbf{S}_j\\) and \\(c_A = J\\). In XDiag, the local operators are represented via an Op object while the sum is represented by an OpSum object. These values of the coupling constants \\(c_A\\) can either be a real or complex number, or a string that later needs to be replaced. The Hamiltonian of a spin \\(S=1 / 2\\) Heisenberg chain is created in the following way:</p> C++Julia <pre><code>auto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n    int s1 = i;\n    int s2 = (i+1) % N\n    ops += \"J\" * Op(\"SdotS\", {s1, s2});\n}\nops[\"J\"] = 1.0;\n</code></pre> <pre><code>ops = OpSum()\nfor i in 1:N\n    s1 = i\n    s2 = mod1(i+1, N)\n    ops += \"J\" * Op(\"SdotS\", [s1, s2])\nend\nops[\"J\"] = 1.0\n</code></pre> <p>We first create an empty OpSum and then add additional terms to it. The first part of the product denotes the coupling constant, here given as a string. Alternatively, one could have directly used real / complex numbers here. The second part of the product is a single Op object. It is created with two inputs:</p> <ul> <li>The type, here <code>SdotS</code> denoting an operator of the form \\(\\mathbf{S}_{i} \\cdot \\mathbf{S}_{j}\\). XDiag features a wide variety of different operator types.</li> <li>An array defining which site the operator lives on. Notice, that in Julia we start counting the sites from 1, while in C++ we start counting the sites from 0.</li> </ul>"},{"location":"user_guide/#matrix-representation","title":"Matrix representation","text":"<p>Given an operator in the form of an OpSum object and a Hilbert space (block) in the form of a certain block, a dense matrix representation of the operator on the computational basis of the block can be computed using the matrix function.</p> C++Julia <pre><code>arma::mat H = matrix(ops, block);\nH.print();\n</code></pre> <pre><code>H = matrix(ops, block);\ndisplay(H)\n</code></pre> <p>In C++, XDiag is using the Armadillo library with the <code>arma</code> namespace. The Armadillo library serves as the linear algebra backend of XDiag and can be used to perform further calculations. To compute all eigenvalues and eigenvectors of a Hamiltonian, i.e. to perform a full exact diagonalization, standard linear algebra routines can be used.</p> C++Julia <pre><code>arma::vec evals;\narma::mat evecs;\narma::eig_sym(evals, evecs, H);\n</code></pre> <pre><code>(evals, evecs) = eigen(Symmetric(H))\n</code></pre> <p>In Julia, the <code>eigen</code> and <code>Symmetric</code> functions are part of the Linear Algebra standard library.</p>"},{"location":"user_guide/#states","title":"States","text":"<p>Quantum states \\(| \\psi \\rangle\\) are represented in XDiag by using a State object. A state with zero coefficients is created either implicitly by calling the constructor of <code>State</code> with a given block, or explicitly by calling the zero_state function.</p> C++Julia <pre><code>bool real = true;\nauto psi1 = State(b, real);\nauto psi2 = zero_state(b, real);\n</code></pre> <pre><code>real = true\npsi1 = State(b, real=real)\npsi2 = zero_state(b, real=real)\n</code></pre> <p>We hereby create a state with real (double precision) coefficients or complex (double precision) coefficients. The parameter <code>real</code> is optional, can be omitted and defaults to <code>true</code>. A state with a given vector of coefficients can also be created.</p> C++Julia <pre><code>int d = size(block)\narma::vec v(d, arma::fill::randu);\nauto psi = State(b, v);\n</code></pre> <pre><code>d = size(block)\nv = rand(d)\npsi = State(block, v)\n</code></pre> <p>Moreover, we can create product states as well as random states (with normal \\(\\mathcal{N}(0, 1)\\) distributed coefficients).</p> C++Julia <pre><code>auto psi1 = product_state(block, {\"Up\", \"Dn\"});\nauto psi2 = random_state(block);\n</code></pre> <pre><code>psi1 = product_state(block, [\"Up\", \"Dn\"])\npsi2 = random_state(block)\n</code></pre> <p>The \\(2\\)-norm \\(\\parallel  | \\psi \\rangle\\parallel_2\\) and dot product \\(\\langle \\psi_1 | \\psi_2 \\rangle\\) of states can easily be computed using the norm and dot/dotC functions.</p> C++Julia <pre><code>double nrm = norm(psi);\ndouble d = dot(psi1, psi2);\ncomplex dc = dotC(psi1, psi2);\n</code></pre> <pre><code>nrm = norm(psi)\ndot = dot(psi1, psi2)\n</code></pre> <p>The function dotC is only available in C++, and returns a complex (double precision) number whenever one of the involved states is complex. This is necessary, as the return type of a function must be known at compile time in C++, whereas Julia permits dynamic typing. The coefficients of a given state can be retrieved using the vector/vectorC.</p> C++Julia <pre><code>arma::vec v = vector(psi);\narma::cx_vec vc = vectorC(psi);\n</code></pre> <pre><code>v = vector(psi)\n</code></pre> <p>Again, the function vectorC only exists in the C++ version since the return type needs to be known at compile time. In Julia, the type of the vector is decided at runtime. </p> <p>Finally, we can apply an operator OpSum to a state using the apply function.</p> C++Julia <pre><code>auto phi = apply(H, psi);\n</code></pre> <pre><code>phi = apply(H, psi)\n</code></pre> <p>Importantly, if the block of the State object has a well-defined quantum number, for example, a conserved particle number, XDiag will automatically detect the quantum number of the resulting state or report an error if the operator does not have a well-defined quantum number. This could be the case, for example, when applying a raising or lowering operator on a particle number conserving state. The apply function acts on a state without creating a matrix representation of the operator, sometimes referred to as on-the-fly matrix application.</p>"},{"location":"user_guide/#iterative-algorithms","title":"Iterative algorithms","text":"<p>XDiag features several iterative algorithms to perform diagonalization and time evolution, which do not require dense matrix storage of the involved operators. Instead, applications of operators are implemented on-the-fly (i.e. matrix-free) and to minimize memory requirements.</p>"},{"location":"user_guide/#diagonalization","title":"Diagonalization","text":"<p>A fundamental property of a quantum system is its ground state energy, which in XDiag can be easily computed using the eigval0 function.</p> C++Julia <pre><code>double e0 = eigval0(H, block);\n</code></pre> <pre><code>e0 = eigval0(H, block)\n</code></pre> <p>Similarly, the ground state can be computed using the eig0 function.</p> C++Julia <pre><code>auto [e0 , psi0] = eig0(H, block);\n</code></pre> <pre><code>e0, psi0 = eig0(H, block)\n</code></pre> <p>Here, <code>e0</code> is a double precision real number and <code>psi0</code> is a State object. We employ the Lanczos algorithm to perform iterative diagonalizations. While the functions eigval0 and eig0 are convenient, XDiag offers also more refined routines called eigvals_lanczos and eigs_lanczos which can target higher excited states and offer more control over the convergence properties. Moreover, they return the convergence criterion as well as the tridiagonal matrix in the Lanczos algorithm, which contains more information than only extremal eigenvalues. The functions eig0 and eigs_lanczos for computing eigenvalues perform the Lanczos iteration twice, first to compute the tridiagonal matrix and in a second run to build the corresponding eigenvectors in order to minimize memory requirements. For a precise description of these methods, we refer to their respective documentations.</p>"},{"location":"user_guide/#time-evolution","title":"Time evolution","text":"<p>Besides diagonalization, XDiag also offers iterative algorithms to perform (imaginary-) time evolutions of the form,</p> \\[ |\\phi(t)\\rangle = e^{-iHt} |\\psi_0\\rangle \\quad \\text{or} \\quad |\\eta(t)\\rangle = e^{-\\tau H} |\\psi_0\\rangle. \\] <p>The time evolution can be performed by two distinct algorithms. The first is the memory-efficient Lanczos algorithm described by Hochbruck and Lubich (1997) which runs a Lanczos algorithm twice, to first compute the tridiagonal matrix and then build the time-evolved state. The second is efficient algorithm proposed in Expokit. While this algorithm is computationally more efficient and highly accurate, it has higher memory requirements.</p> C++Julia <pre><code>double t = 1.0;\nauto phi = time_evolve(H, psi0, t);\n</code></pre> <pre><code>t = 1.0\nphi = time_evolve(H, psi0, t)\n</code></pre> <p>The algorithm employed can be set using the optional <code>algorithm</code> argument, which by default is set to <code>lanczos</code> using the memory-efficient algorithm of Hochbruck and Lubich (1997). Also, more direct control of both algorithms is provided by the functions evolve_lanczos and time_evolve_expokit which allow more control and return further data such as the tridiagonal matrix of the Lanczos algorithm or error estimates, respectively. </p>"},{"location":"user_guide/#measurements","title":"Measurements","text":"<p>Measurements in the form of expectation values of wavefunctions,</p> \\[   \\langle \\mathcal{O}\\rangle =  \\langle \\psi | \\mathcal{O} | \\psi \\rangle,\\] <p>can be evaluated using the inner function. For example, we compute a static spin correlation \\(\\langle S_{0}^{z} S_{j}^{z}\\rangle\\) between site \\(0\\) (resp. \\(1\\) in Julia) and \\(j\\).</p> C++Julia <pre><code>for (int i=0; i&lt;N; ++i) {\n  auto op = Op(\"SzSz\", {0, i});\n  double corr = inner(op, psi0);\n}\n</code></pre> <pre><code>for i in 1:N\n    op = Op(\"SzSz\", {1, i})\n    corr = inner(op, psi0)\nend\n</code></pre> <p>Notice, that in Julia sites start counting from \\(1\\), whereas in C++ sites are counted from \\(0\\). Furthermore, if a complex wave function or operator is involved, the function innerC in C++ should be called, which returns a complex number. In Julia only inner is available whose return type is decided at runtime. </p>"},{"location":"user_guide/#input-output","title":"Input / Output","text":"<p>Julia features a variety of packages facilitating input and output of data. For C++, XDiag provides convenient functionality for TOML and HDF5 files.</p>"},{"location":"user_guide/#reading-from-toml","title":"Reading from TOML","text":"<p>While XDiag allows for defining a Hamiltonian or other operators in code, it is often preferable to define objects in advance in an input file. In XDiag, we use the TOML language to define basic objects in simple files. Among those, operators represented as an OpSum can be specified in a simple format. As an example, the Hamiltonian of the \\(N=8\\) site Heisenberg chain we created above can be defined in the following way.</p> TOML <pre><code># content of spinhalf_chain.toml\n\nInteractions = [\n    [\"J\", \"SdotS\", 0, 1],\n    [\"J\", \"SdotS\", 1, 2],\n    [\"J\", \"SdotS\", 2, 3],\n    [\"J\", \"SdotS\", 3, 4],\n    [\"J\", \"SdotS\", 4, 5],\n    [\"J\", \"SdotS\", 5, 6],\n    [\"J\", \"SdotS\", 6, 7],\n    [\"J\", \"SdotS\", 7, 0]\n]\n</code></pre> <p>The first entry in every list element denotes the coupling constant \\(J\\), the second entry denotes the type SdotS, and the following two entries are the sites of the operator. To read in such a Hamiltonian from a TOML file we can use the FileToml object together with the read_opsum function,</p> C++Julia <pre><code>auto fl = FileToml(\"spinhalf_chain.toml\");\nauto ops = read_opsum(fl, \"Interactions\");\nops[\"J\"] = 1.0\n</code></pre> <pre><code>fl = FileToml(\"spinhalf_chain.toml\")\nops = read_opsum(fl, \"Interactions\")\nops[\"J\"] = 1.0\n</code></pre> <p>In the TOML file, the coupling constant \\(J\\) is defined as a string, which is then set to a numerical value in the application code. Alternatively, the coupling constant could also explicitly defined by a numerical value in the TOML file. Complex numbers \\(x + iy\\) can be represented by a size-two array or the form <code>[x, y]</code>. XDiag also features the functions read_permutation_group and read_representation to conveniently read PermutationGroup and Representation objects used to describe symmetries from file; see Reading symmetries from TOML files.</p> <p>The TOML input files assume that counting starts at \\(0\\) for both the C++ and Julia version, such that the same input file can be used for both languages. In Julia, however, the site index is increased by one after reading in the OpSum.</p>"},{"location":"user_guide/#writing-results-to-hdf5","title":"Writing results to HDF5","text":"<p>The results of numerical simulation are typically stored in output files. A standard scientific data format is the HDF5 format. Julia supports input and output to HDF5 with the HDF5.jl package. For C++ we provide a convenient way of writing results to HDF5 files. In general all numerical data, including scalar real/complex numbers as well as Armadillo vectors and matrices can be easily written to files using the FileH5 object.</p> C++ <pre><code>auto f1 = FileH5(\"output.h5\", \"w!\");\nf1[\"e0\"] = e0;\nf1[\"evals\"] = evals;\nf1[\"evecs\"] = evecs;\n</code></pre> <p>The second argument <code>\"w!\"</code> specifies the access mode to the file. <code>\"w!\"</code> is the forced write mode, where preexisting files are overwritten. Additionally, a protected write mode <code>\"w\"</code> raising an error for existing files, and a read mode <code>\"r\"</code> are provided.</p>"},{"location":"user_guide/#symmetries","title":"Symmetries","text":"<p>Symmetries are fundamental properties of any physical systems. In quantum mechanics, symmetries of a Hamiltonian lead to a set of conserved quantities, also referred to as quantum numbers. Mathematically, quantum numbers are irreducible representations of symmetry groups. A particularly important set of symmetries are space group symmetries like translation symmetries in a solid or point group symmetries in molecules. Abstractly, these symmetries are permutations of sites of the interaction graph. Permutation groups then have irreducible representations, which can denote the momentum for translation groups or angular momentum in point groups. XDiag features functionality to efficiently employ these symmetries to allow for more efficient computation but also physical insights, by e.g., allowing for tower-of-states analysis (see e.g. Wietek et al. (2017)). </p>"},{"location":"user_guide/#permutations","title":"Permutations","text":"<p>Mathematically, a permutation \\(\\pi\\) of order \\(n\\) is a bijective mapping, $$ \\pi : \\{ 1, 2, \\ldots, N\\} \\rightarrow  \\{ 1, 2, \\ldots, N\\},$$ where every integer in the range from \\(1\\) to \\(N\\) is mapped to a distinct number from \\(1\\) to \\(N\\). Such a mapping is usually written as,  $$     \\pi = \\begin{pmatrix}      1 &amp; 2&amp; \\ldots &amp; N \\\\     \\pi(1) &amp; \\pi(2) &amp; \\ldots &amp; \\pi(N) \\\\     \\end{pmatrix}  $$ For example, a translation operator \\(T\\) on a chain with periodic boundary conditions with \\(N=8\\) sites can be written as, $$     T = \\begin{pmatrix}      1 &amp; 2&amp; \\ldots &amp; N-1 &amp; N \\\\     2 &amp; 3&amp; \\ldots &amp; N &amp; 1 \\\\     \\end{pmatrix} $$ In XDiag, such a mapping is represented by a Permutation object, which is created by the integer vector of permuted indices.</p> C++Julia <pre><code>auto T = Permutation({1, 2, 3, 4, 5, 6, 7, 0});\n</code></pre> <pre><code>T = Permutation([2, 3, 4, 5, 6, 7, 8, 1])\n</code></pre> <p>Notice, that also here we start counting from 1 in Julia, and from 0 in C++. Permutation objects can be multiplied (i.e. concatenated), inverted, and raised to a power. A set of permutations can form a mathematical group. To define a mathematical permutation group, we can construct a PermutationGroup object by handing a vector of Permutation objects.</p> C++Julia <pre><code>auto group = PermutationGroup({\n  pow(T, 0), pow(T, 1), pow(T, 2), pow(T, 3),\n  pow(T, 4), pow(T, 5), pow(T, 6), pow(T, 7)});\n</code></pre> <pre><code>group = PermutationGroup([T^0, T^1, T^2, T^3, T^4, T^5, T^6, T^7])\n</code></pre> <p>Internally, the group axioms are validated, and an error will be thrown if not all group properties are fulfilled. This means that the existence of the identity permutation is required. Every permutation also necessitates its inverse to be present, and the product of two permutations needs to be defined as well.</p>"},{"location":"user_guide/#representations","title":"Representations","text":"<p>Mathematically, a representation \\(\\rho\\) of a group \\(G\\) is a mapping from a group to the group of invertible matrices \\(\\textrm{GL}(V)\\) on a vector space \\(V\\),  $$     \\rho: G \\mapsto \\textrm{GL}(V), $$ fulfilling the group homomorphism property, $$ \\rho(g \\cdot h) = \\rho(g) \\cdot \\rho(h) \\quad \\textrm{for all} \\quad g, h \\in G. $$ The dimension of \\(V\\), i.e. the dimension of the matrices is referred to as the dimension of the representation. The character \\(\\chi_\\rho\\) of a representation \\(\\rho\\) is denotes the trace of the representation matrices,  $$     \\chi_\\rho(g) = \\textrm{Tr}[\\rho(g)] \\in \\mathbf{C}. $$ One-dimensional representations play an important role in the theory of space groups. We identify the representation matrices of one-dimensional representations with their characters. </p> <p>An important example is the cyclic group \\(C_N\\) of order \\(N\\) consisting of e.g. translations \\(\\{ \\textrm{I}, T, T^2, \\ldots, T^{(N-1)}\\}\\), which has \\(N\\) irreducible one-dimensional representations. Those, can be labeled by numbers \\(2\\pi k /N\\), such that the characters are,  $$     \\chi_k(T^n) = e^{i k n}. $$ Hence, each irreducible representation (irrep) corresponds to a momentum in physical terms. In XDiag, a one-dimensional representation is represented by the Representation object and can be created by handing a PermutationGroup and the list of characters.</p> C++Julia <pre><code>auto chi = arma::vec({1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0});\nauto k = Representation(group, chi);\n</code></pre> <pre><code>chi = [1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0]\nk = Representation(group, chi)\n</code></pre> <p>Upon creation of a representation, XDiag verifies whether the group axioms as well as the homomorphism property of the characters is fulfilled, i.e., $$ f * g=h \\Rightarrow \\chi(f) \\cdot \\chi(g)=\\chi(h). $$</p>"},{"location":"user_guide/#symmetry-adapted-blocks","title":"Symmetry-adapted blocks","text":"<p>Representations \\(\\rho\\) of a permutation symmetry group \\(G\\) can then be used to create symmetry-adapted blocks. Given a computational basis state \\(|\\mathbf{\\sigma}\\rangle = |\\sigma_1\\sigma_2\\cdots\\sigma_N\\rangle\\), the corresponding symmetry-adapted state is given as,</p> \\[     |\\mathbf{\\sigma}_{\\rho}\\rangle \\equiv \\frac{1}{N_{\\rho,\\psi}} \\sum_{g \\in G} \\chi_{\\rho}(g)^{*} g |\\mathbf{\\sigma}\\rangle. \\] <p>Here, the action of a permutation \\(g\\) on a product state \\(|\\sigma\\rangle\\) is defined as, $$     g|\\mathbf{\\sigma}\\rangle = g|\\sigma_1\\sigma_2\\cdots\\sigma_N\\rangle =      |\\sigma_{g(1)}\\sigma_{g(2)}\\cdots\\sigma_{g(N)}\\rangle, $$ and the \\(N_{\\rho,\\psi}\\) denotes the normalization constant. For example, consider a spin \\(S=1/2\\) system on a four-site chain with a fourfold translation symmetry group \\(C_4\\), the computational basis state \\(|\\mathbf{\\sigma}\\rangle = |\\downarrow\\downarrow\\uparrow\\uparrow\\rangle\\) and the irreducible representation with \\(k=\\pi\\). Then the symmetry-adapted basis state of \\(|\\mathbf{\\sigma}\\rangle\\) is given as, $$    |\\mathbf{\\sigma}_\\pi\\rangle = \\frac{1}{2}\\left(     |\\downarrow\\downarrow\\uparrow\\uparrow\\rangle    -|\\downarrow\\uparrow\\uparrow\\downarrow\\rangle    +|\\uparrow\\uparrow\\downarrow\\downarrow\\rangle    -|\\uparrow\\downarrow\\downarrow\\uparrow\\rangle    \\right) $$ We refer to the states \\(\\{g|\\mathbf{\\sigma}\\rangle \\; | \\; g \\in G\\}\\) as the orbit of \\(|\\mathbf{\\sigma}\\rangle\\). XDiag represents each basis state by an integer value. To represent a symmetry-adapted basis state, XDiag uses the state in the orbit of \\(|\\mathbf{\\sigma}\\rangle\\) with the minimal associated integer value, which is then called the representative of the orbit. For more details on symmetry-adapted wavefunctions in the context of exact diagonalization we refer to Ref. Wei\u00dfe and Fehske (2008) or Wietek (2022).</p> <p>We can conveniently create a symmetry-adapted block in XDiag by handing a Representation object to the constructor of a block.</p> C++Julia <pre><code>auto blk = Spinhalf(N, nup, irrep);\n</code></pre> <pre><code>blk = Spinhalf(N, nup, irrep)\n</code></pre> <p>A symmetry-adapted block shares most functionality with conventional blocks. We can iterate over the basis states, i.e. the representatives of the symmetry-adapted basis states. </p> C++Julia <pre><code>for (auto spins: blk) {\n  Log(\"{}\", to_string(spins));\n}\n</code></pre> <pre><code>for spins in blk\n    println(to_string(spins))\nend\n</code></pre> <p>A sample output of symmetry-adapted blocks of different kinds is shown in the figure below. Symmetry-adapted blocks can, among other use cases, be used to create a representation of an operator in the symmetry-adapted basis using the matrix function and to create symmetric states by constructing State objects. Also symmetry-adapted operators, e.g. created using symmetrize as described in the section Symmetrized operators, in the form of an OpSum can be applied to symmetry-adapted states, where consistency of quantum numbers is validated.</p> <p></p>"},{"location":"user_guide/#reading-symmetries-from-toml-files","title":"Reading symmetries from TOML files","text":"<p>Permutation groups and representations can be defined in a TOML file and read in. A typical input TOML file defining a symmetry group and corresponding representations is shown below.</p> TOML <pre><code># content of symmetries.toml\n\nSymmetries = [\n    [0, 1, 2, 3],\n    [3, 0, 1, 2],\n    [2, 3, 0, 1],\n    [1, 2, 3, 0],\n]\n\n# Irreducible representations\n[k.zero]\ncharacters = [\n    [1.0, 0.0],\n    [1.0, 0.0],\n    [1.0, 0.0],\n    [1.0, 0.0],\n]\n\n[k.pihalf]\ncharacters = [\n    [1.0, 0.0],\n    [0.0, 1.0],\n    [-1.0, 0.0],\n    [0.0, -1.0],\n]\n\n[k.pi]\ncharacters = [\n    [1.0, 0.0],\n    [-1.0, 0.0],\n    [1.0, 0.0],\n    [-1.0, 0.0],\n]\n</code></pre> <p>The permutation group is defined as an integer matrix, whose rows correspond to individual permutations. Notice, that we start counting sites from \\(0\\) in this case. This holds regardless of whether the C++ version or the Julia version is used. The input TOML files always start counting at \\(0\\), in Julia, the symmetry number array is increased by one. The representations are given names, <code>\"k.zero\"</code>, <code>\"k.pihalf\"</code>, <code>\"k.pi\"</code>, and have an associated field <code>characters</code>, which is a vector of complex numbers. Complex numbers are represented by a two-element array. Technically, real representations are also allowed to have one single real number instead. </p> <p>The symmetry group and the irreducible representations are then easily read in using the functions read_permutation_group and read_representation.</p> C++Julia <pre><code>auto fl = FileToml(\"symmetries.toml\");\nauto group = read_permutation_group(fl, \"Symmetries\");\nauto irrep = read_representation(fl, \"k.zero\", \"Symmetries\");\n</code></pre> <pre><code>fl = FileToml(\"symmetries.toml\")\ngroup = read_permutation_group(fl, \"Symmetries\")\nirrep = read_representation(fl, \"k.zero\", \"Symmetries\")\n</code></pre> <p>Notice that the read_representation function is not just handed the name of the representation but also the tag that defines the permutation symmetry group, as the representation needs to know which group it is representing. </p>"},{"location":"user_guide/#symmetrized-operators","title":"Symmetrized operators","text":"<p>A useful feature to work with permutation symmetries is to symmetrize a non-symmetric operator. Symmetrization in this context means the following. In general, we are given an operator of the form, $$     O = \\sum_{A\\subseteq \\mathcal{L}} O_A, $$ where \\(O_A\\) denotes a local operator acting on sites \\(A=\\{a_1, \\ldots, a_{l_A}\\}\\) and \\(\\mathcal{L}\\) denotes the lattice. A permutation group \\(\\mathcal{G}\\) is defined through its permutations \\(\\pi_1, \\ldots, \\pi_M\\). The symmetrized operator is then defined as, $$     O^\\mathcal{G} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}}  O_{\\pi(A)}, $$ where \\(\\pi(A) = \\{\\pi(a_1), \\ldots,\\pi(a_{l_A})\\}\\) denotes the permutated set of sites of the local operator \\(O_A\\). Additionally, we can also symmetrize with respect to a representation \\(\\rho\\), $$     O^\\mathcal{G, \\rho} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}} \\chi_\\rho(\\pi) O_{\\pi(A)}, $$ where \\(\\chi_\\rho(\\pi)\\) denotes the characters of the representation \\(\\rho\\). Such symmetrizations of OpSum objects can be performed using the symmetrize function.</p> C++Julia <pre><code>auto og = symmetrize(ops, group);\nauto oi = symmetrize(ops, irrep);\n</code></pre> <pre><code>og = symmetrize(ops, group)\noi = symmetrize(ops, irrep)\n</code></pre> <p>A common use case of symmetrizing operators is to evaluate expectation values of non-symmetric operators on a symmetric State. For example we might be interested in the ground state of a model with translation symmetry and then evaluate two-point correlation functions. The ground state is then going to be defined on a symmetric block, but the two-point correlation function is not symmetric with respect to the translation symmetry group. However, the symmetrized two-point correlation function is, in fact, symmetric, and its expectation value on a symmetric state will evaluate to the same number. This is a typical use case of symmetrizing an operator with respect to a group.</p> <p>Another use case of the symmetrize function is to create operators at a certain momentum, e.g. $$   S^z(\\mathbf{q}) = \\frac{1}{M} \\sum e^{i\\mathbf{q}\\cdot\\mathbf{r}} S^z_{\\mathbf{r}}, $$ Notice that such an operator can be written as \\(O^\\mathcal{G, \\rho}\\) for an appropriate representation \\(\\rho\\) of a lattice symmetry.  Hence, it can be easily created using the symmetrize function with the irrep describing the momentum \\(\\mathbf{q}\\). We provide several examples along XDiag demonstrating this functionality and use cases.</p>"},{"location":"user_guide/#distributed-computing","title":"Distributed computing","text":"<p>The standard XDiag library features shared memory parallelization using OpenMP for both the C++ and Julia version. However, we also provide distributed memory parallelization in a separate C++-only library that needs to be compiled independently. To do so, we have to use the flag <code>XDIAG_DISTRIBUTED</code> when setting up the compilation using CMake.</p> <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre> <p>This will create a distinct <code>xdiag_distributed</code> library, which is different from the standard <code>xdiag</code> library. To link an application code to the distributed library, we can use the following <code>CMakeLists.txt</code> file.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\nproject(hello_world)\nfind_package(xdiag_distributed REQUIRED HINTS \"/path/to/where/xdiag/should/be/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag_distributed)  \n</code></pre> <p>Notice that this only differs from the original <code>CMakeLists.txt</code> file shown in the section Application compilation in two places, where we specify that the <code>xdiag_distributed</code> library instead of the standard <code>xdiag</code> library is used. The distributed memory library is built on top of the message passing interface (MPI). Every MPI application needs to initialize and finalize the MPI environment explicitly. Hence, a typical main routine for using the distributed XDiag library with MPI should look similar to the following listing.</p> C++ <pre><code>#include &lt;xdiag/all.hpp&gt;\nusing namespace xdiag;\nint main(int argc, char* argv[]) try {\n    MPI_Init(argc, argv);\n    // genuine XDiag code here\n    MPI_Finalize();\n} catch (Error e) {\n    error_trace(e);\n}\n</code></pre> <p>The functionality described in the previous sections is also available to some degree for the distributed library. Importantly, to use the distributed capabilities we have to change the types of blocks from the standard Spinhalf, tJ, and Electron blocks to the SpinhalfDistributed, tJDistributed, and ElectronDistributed blocks. An example to compute the ground state of a Heisenberg chain using the distributed capabilities is given by,</p> C++ <pre><code>auto block = SpinhalfDistributed(N, nup);\nOpSum ops;    \nfor (int i = 0; i &lt; N; ++i) {\n    ops += Op(\"SdotS\", {i, (i + 1) % N});\n}\ndouble e0 = eigval0(ops, block);\n</code></pre> <p>At present, one important difference between the distributed and standard library is that the distributed blocks do not yet support symmetrized blocks. This feature will be added in future versions of XDiag.</p>"},{"location":"documentation/","title":"Documentation","text":"<p>XDiag uses the C++ library Armadillo as a linear algebra backend. Documentation for linear algebra operations can, therefore, be found in the Armadillo Documentation.</p>"},{"location":"documentation/#algebra","title":"Algebra","text":"Name Description Language matrix Creates the full matrix representation of an operator on a block apply Applies an operator to a state \\(\\vert \\phi \\rangle = O \\vert \\psi\\rangle\\) dot Computes the dot product between two states inner Computes an expectation value \\(\\langle \\psi \\vert O \\vert \\psi \\rangle\\) norm Computes the 2-norm of a state norm1 Computes the 1-norm of a state norminf Computes the \\(\\infty\\)-norm of a state"},{"location":"documentation/#algorithms","title":"Algorithms","text":"<p>Diagonalization</p> Name Description Language eigval0 Computes the lowest lying eigenvalue of an operator eig0 Computes the lowest lying eigenvalue and eigenvector of an operator eigvals_lanczos Performs an iterative eigenvalue calculation using the Lanczos algorithm eigs_lanczos Performs an iterative eigenvalue calculation building eigenvectors using the Lanczos algorithm <p>Time evolution</p> Name Description Language time_evolve Performs a real-time evolution \\(e^{ -iHt} \\vert \\psi \\rangle\\) of a State with a given Hermitian operator \\(H\\) imaginary_time_evolve Performs a imaginary-time evolution \\(e^{ -\\tau H}\\vert\\psi\\rangle\\) of a State with a given Hermitian operator \\(H\\) evolve_lanczos Computes the exponential $e^{z H}\\vert\\psi\\rangle $ of a Hermitian operator times a State for a real or complex \\(z\\) using the Lanczos algorithm time_evolve_expokit Performs a real-time evolution \\(e^{ -iHt} \\vert \\psi \\rangle\\) using a highly accurate Lanczos algorithm"},{"location":"documentation/#blocks","title":"Blocks","text":"<p>Shared memory</p> Name Description Language Spinhalf Block of a spin \\(S=1/2\\) type Hilbert space tJ Block of a \\(t-J\\) type Hilbert space Electron Block of a Electron type Hilbert space <p>Distributed memory</p> Name Description Language SpinhalfDistributed Block of a spin \\(S=1/2\\) type Hilbert space (distributed computing) tJDistributed Block of a \\(t-J\\) type Hilbert space  (distributed computing) ElectronDistributed Block of a Electron type Hilbert space  (distributed computing)"},{"location":"documentation/#building","title":"Building","text":"Name Description Language Compilation Advanced settings for compilation of the C++ library using CMake Documentation How to build and work on the documentation locally Julia Wrapper How to build and develop the Julia wrapper locally"},{"location":"documentation/#input-output","title":"Input / Output","text":"<p>TOML</p> Name Description Language FileToml A file handler for TOML files read_opsum reads an OpSum from a TOML file read_permutation_group reads a PermutationGroup from a TOML file read_representation reads a Representation from a TOML file <p>HDF5</p> Name Description Language FileH5 A file handler for hdf5 files"},{"location":"documentation/#operators","title":"Operators","text":"Operator types A summary of all the operator types defined in XDiag Name Description Language Op A linear operator acting on the Hilbert space OpSum Sum of couplings times operators hc Returns the hermitian conjugate of an Op or OpSum. symmetrize Symmetrizes an operator with a PermutationGroup or Representation"},{"location":"documentation/#states","title":"States","text":"Name Description Language State A generic state describing a quantum wave function ProductState A product state of local configurations RandomState A random state with normal distributed coefficients fill Fill a state with a given model state product_state Creates a filled product state random_state Create a filled random state with normal distributed coefficients zero_state Create a filled state with all zero entries zero Set all coefficients of a given state to zero"},{"location":"documentation/#symmetries","title":"Symmetries","text":"Name Description Language Permutation Permutations of indices or lattice sites PermutationGroup A group of permutations Representation A (1D) irreducible representation of a finite group"},{"location":"documentation/#utilities","title":"Utilities","text":"Name Description Language set_verbosity Sets how much information is printed during computations say_hello Prints a nice welcome message with version number print_version Prints the plain version number Logging Controling what is written to standard output Timing Measurng wall time straightforwardly XDIAG_SHOW Macro for printing debugging information"},{"location":"documentation/algebra/algebra/","title":"Algebra routines","text":"<p>Several basic algebraic operations for states and operators.</p> <p>Sources algebra.hpp algebra.cpp algebra.jl</p>"},{"location":"documentation/algebra/algebra/#dot","title":"dot","text":"<p>Computes the dot product \\(\\langle v \\vert w \\rangle\\) between two states \\(\\vert v \\rangle\\) and \\(\\vert w \\rangle\\). In C++, please use the dotC function if one of the two states is expected to be complex.</p> C++Julia <pre><code>double dot(State const &amp;v, State const &amp;w);\ncomplex dotC(State const &amp;v, State const &amp;w);\n</code></pre> <pre><code>dot(v::State, w::State)\n</code></pre>"},{"location":"documentation/algebra/algebra/#inner","title":"inner","text":"<p>Computes the expectation value \\(\\langle v | O |v \\rangle\\) of an operator \\(O\\) and a state \\(|v\\rangle\\). The operator can either be an Op or an OpSum object. In C++, please use the innerC function if either the operator or the state are complex.</p> C++Julia <pre><code>double inner(Op const &amp;op, State const &amp;v);\ndouble inner(OpSum const &amp;ops, State const &amp;v);\ncomplex innerC(Op const &amp;op, State const &amp;v);\ncomplex innerC(OpSum const &amp;ops, State const &amp;v);\n</code></pre> <pre><code>inner(op::Op, v::State)\ninner(ops::OpSum, v::State)\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm","title":"norm","text":"<p>Computes the 2-norm \\(\\parallel |v \\rangle \\parallel_2\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_2 = \\sum_n |\\langle n | v \\rangle |^2, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norm(State const &amp;v);\n</code></pre> <pre><code>norm(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#norm1","title":"norm1","text":"<p>Computes the 1-norm \\(\\parallel |v \\rangle \\parallel_1\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_1 = \\sum_n |\\langle n | v \\rangle |, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norm1(State const &amp;v);\n</code></pre> <pre><code>norm1(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#norminf","title":"norminf","text":"<p>Computes the \\(\\infty\\)-norm \\(\\parallel |v \\rangle \\parallel_\\infty\\) of a state \\(|v \\rangle\\) defined as</p> \\[ \\parallel |v \\rangle \\parallel_\\infty = \\max_n |\\langle n | v \\rangle |, \\] <p>where \\(\\{ |n\\rangle \\}\\) denotes an orthonormal basis of the block.</p> C++Julia <pre><code>double norminf(State const &amp;v);\n</code></pre> <pre><code>norminf(state::State)::Float64\n</code></pre>"},{"location":"documentation/algebra/algebra/#usage-examples","title":"Usage Examples","text":"C++Julia <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\n\nXDIAG_SHOW(norm(psi));\nXDIAG_SHOW(norm1(psi));\nXDIAG_SHOW(norminf(psi));\n\nXDIAG_SHOW(dot(psi, psi));\nXDIAG_SHOW(e0);\nXDIAG_SHOW(inner(ops, psi));\n\nauto phi = random_state(block);\nXDIAG_SHOW(phi.vector());\nXDIAG_SHOW(psi.vector());\nXDIAG_SHOW((psi + 2.0*phi).vector());\nXDIAG_SHOW((psi*complex(0,3.0) + phi/2.0).vectorC());\n</code></pre> <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    e0, psi = eig0(ops, block);\n\n    @show norm(psi)\n    @show norm1(psi)\n    @show norminf(psi)\n    @show dot(psi, psi)\n    @show e0, inner(ops, psi)\n\n    phi = random_state(block)\n    display(vector(phi))\n    display(vector(psi))\n    display(vector(psi + 2.0*phi))\n    display(vector(psi*3.0im + phi/2.0))\nend\n</code></pre>"},{"location":"documentation/algebra/apply/","title":"apply","text":"<p>Applies an operator given as an Op or OpSum to a State \\(\\vert w \\rangle = \\mathcal{O} \\vert v\\rangle\\).</p> <p>Sources apply.hpp apply.cpp apply.jl</p>"},{"location":"documentation/algebra/apply/#definition","title":"Definition","text":"<p>An operator \\(\\mathcal{O}\\) can be applied to a state \\(\\vert v\\rangle\\) in two ways:</p> <ol> <li> <p>Only the input state on which the operator acts is defined is given. The block of the output state is calculated and eventually created automatically.</p> C++Julia <pre><code>State apply(Op const &amp;op, State const &amp;v);\nState apply(OpSum const &amp;ops, State const &amp;v);\n</code></pre> <pre><code>apply(op::Op, v::State)\napply(ops::OpSum, v::State)\n</code></pre> </li> <li> <p>The output state is also handed as an argument which is overwritten. The compatibility of quantum numbers is checked. This way the output block is not created automatically and, thus, can be used to save computation time if the output block appears repeatedly in the computation.</p> C++Julia <pre><code>void apply(Op const &amp;op, State const &amp;v, State &amp;w);\nvoid apply(OpSum const &amp;ops, State const &amp;v, State &amp;w);\n</code></pre> <pre><code>apply(op::Op, v::State, w::State)\napply(ops::OpSum, v::State, w::State)\n</code></pre> </li> </ol>"},{"location":"documentation/algebra/apply/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator v Input State $\\vert v\\rangle  $ w Output State \\(\\vert w \\rangle = O \\vert v\\rangle\\)"},{"location":"documentation/algebra/apply/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nauto block = Spinhalf(N,  N / 2);\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto phi = apply(Op(\"S+\", 2), psi);\nXDIAG_SHOW(inner(ops, psi));\nXDIAG_SHOW(inner(ops, phi));\n</code></pre> <pre><code>let \n    N = 8\n    block = Spinhalf(N,  N \u00f7 2)\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    e0, psi = eig0(ops, block);\n    phi = apply(Op(\"S+\", 2), psi)\n    @show inner(ops, psi)\n    @show inner(ops, phi)\nend\n</code></pre>"},{"location":"documentation/algebra/matrix/","title":"matrix","text":"<p>Creates a numerical matrix with real (<code>matrix</code>) or complex (<code>matrixC</code>) coefficients given an Op or OpSum on a certain block. </p> <p>Sources matrix.hpp matrix.cpp matrix.jl</p>"},{"location":"documentation/algebra/matrix/#definition","title":"Definition","text":"<p>A matrix can be created in two ways:</p> <ol> <li> <p>Only the input block on which the operator is defined is given. The output block is calculated and eventually created automatically.</p> C++Julia <pre><code>arma::mat matrix(Op const &amp;op, Block const &amp;block);\narma::mat matrix(OpSum const &amp;ops, Block const &amp;block);\narma::cx_mat matrixC(Op const &amp;op, Block const &amp;block);\narma::cx_mat matrixC(OpSum const &amp;ops, Block const &amp;block);\n</code></pre> <pre><code>matrix(op::Op, block::Block)\nmatrix(ops::OpSum, block::Block)\n</code></pre> </li> <li> <p>The output block is also handed as an argument. The compatibility of quantum numbers is checked. This way the output block is not created automatically and, thus, can be used to save computation time if the output block appears repeatedly in the computation.</p> C++Julia <pre><code>arma::mat matrix(Op const &amp;op, Block const &amp;block_in, Block const &amp;block_out);\narma::mat matrix(OpSum const &amp;ops, Block const &amp;block_in, Block const &amp;block_out);\narma::cx_mat matrixC(Op const &amp;op, Block const &amp;block_in, Block const &amp;block_out);\narma::cx_mat matrixC(OpSum const &amp;ops, Block const &amp;block_in, Block const &amp;block_out);\n</code></pre> <pre><code>matrix(op::Op, block_in::Block, block_out::Block)\nmatrix(ops::OpSum, block_in::Block, block_out::Block)\n</code></pre> </li> </ol> <p>Comment: In Julia, depending on whether a real/complex matrix is generated also a  real/complex matrix is returned. The C++ version has to return a fixed type. If a real matrix is desired, use the function <code>matrix</code>. If a complex matrix is desired, use the function <code>matrixC</code>.</p>"},{"location":"documentation/algebra/matrix/#parameters","title":"Parameters","text":"Name Description ops OpSum or Op defining the operator block / block_in input block on which the operator is defined block_out output block the operator maps the input block to"},{"location":"documentation/algebra/matrix/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>// Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\nint N = 4;\nint nup = 3;\nint ndn = 2;\n\n// Define a Hubbard chain model\nauto ops = OpSum();\nfor (int i=0; i&lt; N; ++i){\n  ops += \"T\" * Op(\"Hop\", {i, (i+1) % N});\n}\nops+= \"U\" * Op(\"HubbardU\");\nops[\"T\"] = 1.0;\nops[\"U\"] = 5.0;\n\n// Create the a permutation group\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1.0, -1.0, 1.0, -1.0});\nauto block = Electron(N, nup, ndn, irrep);\nauto H = matrix(ops, block);\nH.print();\n</code></pre> <pre><code>let\n    # Creates matrix H_{k=2} in Eq (18.23) of https://link.springer.com/content/pdf/10.1007/978-3-540-74686-7_18.pdf\n    N = 4\n    nup = 3\n    ndn = 2\n\n    # Define a Hubbard chain model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"T\" * Op(\"Hop\", [i, mod1(i+1, N)])\n    end\n    ops += \"U\" * Op(\"HubbardU\")\n    ops[\"T\"] = 1.0;\n    ops[\"U\"] = 5.0;\n\n    # Create the a permutation group\n    p = Permutation([2, 3, 4, 1])\n    group = PermutationGroup([p^0, p^1, p^2, p^3])\n    irrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\n    block = Electron(N, nup, ndn, irrep)\n\n    H = matrix(ops, block)\n    display(H)\nend\n</code></pre>"},{"location":"documentation/algorithms/eig0/","title":"eig0","text":"<p>Computes the groud state energy and the ground state of a Hermitian operator on a block by using an iterative Lanczos algorithm. This function is a shortcut for the eigs_lanczos function. We refer to eigs_lanczos for further details on the algorithm and the convergence criterion.</p> <p>Sources sparse_diag.hpp sparse_diag.cpp sparse_diag.jl</p>"},{"location":"documentation/algorithms/eig0/#definition","title":"Definition","text":"C++Julia <pre><code>std::tuple&lt;double, State&gt; eig0(OpSum const &amp;ops, Block const &amp;block,\n    double precision = 1e-12, int64_t max_iterations = 1000, \n    int64_t random_seed = 42);\n</code></pre> <pre><code>eig0(ops::OpSum, block::Block;  precision::Float64 = 1e-12, \n     max_iterations::Int64 = 1000, random_seed::Int64 = 42)\n</code></pre>"},{"location":"documentation/algorithms/eig0/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining a Hermitian operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eig0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue of <code>ops</code> State groundstate"},{"location":"documentation/algorithms/eig0/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\nauto [e0, gs] = eig0(ops, block);\n</code></pre> <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n    e0, gs = eig0(ops, block);\nend\n</code></pre>"},{"location":"documentation/algorithms/eigs_lanczos/","title":"eigs_lanczos","text":"<p>Performs an iterative eigenvalue calculation building eigenvectors using the Lanczos algorithm. Returns the tridiagonal matrix, eigenvalues, number of iterations and the stopping criterion. The Lanczos interations are performed twice, where at the second run the eigenvectors are built.</p> <p>Sources eigs_lanczos.hpp eigs_lanczos.cpp eigs_lanczos.jl</p>"},{"location":"documentation/algorithms/eigs_lanczos/#definition","title":"Definition","text":"<p>The Lanczos algorithm can be run in two distinct ways:</p> <ol> <li> <p>A random intial state \\(|\\psi_0\\rangle = |r\\rangle\\) with normal distributed entries is used.</p> C++Julia <pre><code>EigsLanczosResult\neigs_lanczos(OpSum const &amp;ops, Block const &amp;block, int64_t neigvals = 1,\n             double precision = 1e-12, int64_t max_iterations = 1000,\n             double deflation_tol = 1e-7, int64_t random_seed = 42);\n</code></pre> <pre><code>eigs_lanczos(ops::OpSum, block::Block; neigvals::Int64 = 1,\n             precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n             deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified</p> C++ <p><pre><code>EigsLanczosResult \neigs_lanczos(OpSum const &amp;ops, State const &amp;psi0, int64_t neigvals = 1,\n             double precision = 1e-12, int64_t max_iterations = 1000,\n             double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigs_lanczos(ops::OpSum, psi0::State; neigvals::Int64 = 1,\n             precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n             deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre></p> </li> </ol>"},{"location":"documentation/algorithms/eigs_lanczos/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining the bonds of the operator block block on which the operator is defined psi0 Initial State from which the Lanczos algorithm is started neigvals number of eigenvalues to converge 1 precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigs_lanczos/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description alphas diagonal elements of the tridiagonal matrix betas off-diagonal elements of the tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix eigenvectors State of shape $D \\times $<code>neigvals</code> holding all low-lying eigenvalues up to <code>neigvals</code> niterations number of iterations performed criterion string denoting the reason why the algorithm stopped"},{"location":"documentation/algorithms/eigs_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm terminates if the \\(k\\)-th (\\(k\\) is the argument <code>neigvals</code>) approximate eigenvalue changes only by a fraction smaller than \\(\\epsilon\\) (\\(k\\) is the argument <code>precision</code>), i.e.</p> \\[ (\\tilde{e}_k^{(n)} - \\tilde{e}_k^{(n-1)}) / \\tilde{e}_k^{(n)} &lt; \\epsilon.\\] <p>Here, \\(\\tilde{e}_k^{(n)}\\) denotes the Lanczos approximation to the \\(k\\)-th eigenvalue after \\(n\\) iterations.</p>"},{"location":"documentation/algorithms/eigs_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n\n// With random intial state\nauto res = eigs_lanczos(ops, block);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\nXDIAG_SHOW(res.eigenvectors);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    # With random intial state\n    res = eigs_lanczos(ops, block)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\n    @show res.eigenvectors\nend\n</code></pre>"},{"location":"documentation/algorithms/eigval0/","title":"eigval0","text":"<p>Computes the groud state energy of a Hermitian operator on a block by using an iterative Lanczos algorithm. This function is a shortcut for the eigvals_lanczos function. We refer to eigvals_lanczos for further details on the algorithm and the convergence criterion.</p> <p>Sources sparse_diag.hpp sparse_diag.cpp sparse_diag.jl</p>"},{"location":"documentation/algorithms/eigval0/#definition","title":"Definition","text":"C++Julia <pre><code>double eigval0(OpSum const &amp;ops, Block const &amp;block, double precision = 1e-12,\n               int64_t max_iterations = 1000, int64_t random_seed = 42);\n</code></pre> <pre><code>eigval0(ops::OpSum, block::Block;   precision::Float64 = 1e-12, \n        max_iterations::Int64 = 1000, random_seed::Int64 = 42)::Float64\n</code></pre>"},{"location":"documentation/algorithms/eigval0/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining a Hermitian operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigval0/#returns","title":"Returns","text":"Type Description real number lowest lying eigenvalue of <code>ops</code>"},{"location":"documentation/algorithms/eigval0/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\ndouble e0 = eigval0(ops, block);\n</code></pre> <pre><code>let \n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n    e0 = eigval0(ops, block);\nend\n</code></pre>"},{"location":"documentation/algorithms/eigvals_lanczos/","title":"eigvals_lanczos","text":"<p>Performs an iterative eigenvalue calculation using the Lanczos algorithm. Returns the tridiagonal matrix, eigenvalues, number of iterations and the stopping criterion.</p> <p>Sources eigvals_lanczos.hpp eigvals_lanczos.cpp eigvals_lanczos.jl</p>"},{"location":"documentation/algorithms/eigvals_lanczos/#definition","title":"Definition","text":"<p>The Lanczos algorithm can be run in thre distinct ways:</p> <ol> <li> <p>A random intial state \\(|\\psi_0\\rangle = |r\\rangle\\) with normal distributed entries is used.</p> C++Julia <pre><code>EigvalsLanczosResult\neigvals_lanczos(OpSum const &amp;ops, Block const &amp;block, int64_t neigvals = 1,\n                double precision = 1e-12, int64_t max_iterations = 1000,\n                double deflation_tol = 1e-7, int64_t random_seed = 42);\n</code></pre> <pre><code>eigvals_lanczos(ops::OpSum, block::Block; neigvals::Int64 = 1, \n                precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                deflation_tol::Float64 = 1e-7, random_seed::Int64 = 42)\n</code></pre> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified. </p> C++Julia <pre><code>EigvalsLanczosResult \neigvals_lanczos(OpSum const &amp;ops, State psi0, int64_t neigvals = 1,\n                double precision = 1e-12, int64_t max_iterations = 1000,\n                double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigvals_lanczos(ops::OpSum, psi0::State; neigvals::Int64 = 1, \n                precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                deflation_tol::Float64 = 1e-7)\n</code></pre> <p>Notice this version copies the initial state, which requires memory but keeps the orginal state intact.</p> </li> <li> <p>The initial state \\(|\\psi_0\\rangle\\) is explicitly specified and overwritten in the process. This version can save memory, but the initial state  \\(|\\psi_0\\rangle\\) cannot be used later.</p> C++Julia <pre><code>EigvalsLanczosResult \neigvals_lanczos_inplace(OpSum const &amp;ops, State &amp;psi0, int64_t neigvals = 1,\n                        double precision = 1e-12, int64_t max_iterations = 1000,\n                        double deflation_tol = 1e-7);\n</code></pre> <pre><code>eigvals_lanczos_inplace(ops::OpSum, psi0::State; neigvals::Int64 = 1, \n                        precision::Float64 = 1e-12, max_iterations::Int64 = 1000,\n                        deflation_tol::Float64 = 1e-7)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/eigvals_lanczos/#parameters","title":"Parameters","text":"Name Description Default ops OpSum defining the bonds of the operator block block on which the operator is defined psi0 Initial State from which the Lanczos algorithm is started neigvals number \\(k\\) of eigenvalue to converge 1 precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 random_seed random seed for setting up the initial vector 42"},{"location":"documentation/algorithms/eigvals_lanczos/#returns","title":"Returns","text":"<p>A struct of type <code>EigvalsLanczosResult</code> with the following entries.</p> Entry Description alphas diagonal elements of the tridiagonal matrix betas off-diagonal elements of the tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix niterations number of iterations performed criterion string denoting the reason why the algorithm stopped"},{"location":"documentation/algorithms/eigvals_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm terminates if the \\(k\\)-th (\\(k\\) is the argument <code>neigvals</code>) approximate eigenvalue changes only by a fraction smaller than \\(\\epsilon\\) (\\(k\\) is the argument <code>precision</code>), i.e.</p> \\[ (\\tilde{e}_k^{(n)} - \\tilde{e}_k^{(n-1)}) / \\tilde{e}_k^{(n)} &lt; \\epsilon.\\] <p>Here, \\(\\tilde{e}_k^{(n)}\\) denotes the Lanczos approximation to the \\(k\\)-th eigenvalue after \\(n\\) iterations.</p>"},{"location":"documentation/algorithms/eigvals_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += \"J\" * Op(\"SdotS\", {i, (i+1) % N});\n}\nops[\"J\"] = 1.0;\n\n// With random intial state\nauto res = eigvals_lanczos(ops, block);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\n\n// With specific initial state\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\nauto res2 = eigvals_lanczos(ops, psi0);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\nXDIAG_SHOW(res.eigenvalues);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    # With random intial state\n    res = eigvals_lanczos(ops, block)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\n\n    # With specific initial state\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    res2 = eigvals_lanczos(ops, psi0)\n    @show res.alphas\n    @show res.betas\n    @show res.eigenvalues\nend\n</code></pre>"},{"location":"documentation/algorithms/evolve_lanczos/","title":"evolve_lanczos","text":"<p>Computes the exponential of a Hermitian operator \\(H\\) with an arbitrary real or complex prefactor \\(z\\) applied to a State \\(\\vert \\psi_0\\rangle\\), </p> \\[\\vert \\psi(z) \\rangle = e^{z(H - \\delta)} \\vert \\psi_0\\rangle.\\] <p>Here, \\(\\delta\\) denotes a real number shifting the spectrum of \\(H\\). The algorithm implemented is described in the following publication.</p> <p>On Krylov Subspace Approximations to the Matrix Exponential Operator Marlis Hochbruck and Christian Lubich SIAM Journal on Numerical Analysis, Vol. 34, Iss. 5 (1997) DOI: 10.1137/S0036142995280572</p> <p>Sources evolve_lanczos.hpp evolve_lanczos.cpp evolve_lanczos.jl</p>"},{"location":"documentation/algorithms/evolve_lanczos/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>EvolveLanczosResult\nevolve_lanczos(OpSum const &amp;H, State psi, double t, double precision = 1e-12,\n               double shift = 0., bool normalize = false,\n               int64_t max_iterations = 1000, double deflation_tol = 1e-7);\n\nEvolveLanczosResult\nevolve_lanczos(OpSum const &amp;H, State psi, complex z, double precision = 1e-12,\n               double shift = 0., bool normalize = false,\n               int64_t max_iterations = 1000, double deflation_tol = 1e-7);\n</code></pre> <pre><code>evolve_lanczos(H::OpSum, psi::State, t::Float64; precision::Float64 = 1e-12,\n               shift::Float64=0.0, normalize::Bool=false,\n               max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n\nevolve_lanczos(H::OpSum, psi::State, z::ComplexF64; precision::Float64 = 1e-12,\n               shift::Float64=0.0, normalize::Bool=false,\n               max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n</code></pre> </li> <li> <p>An inplace variant <code>evolve_lanczos_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>evolve_lanczos</code>.</p> C++Julia <pre><code>EvolveLanczosInplaceResult\nevolve_lanczos_inplace(OpSum const &amp;H, State &amp;psi, double t, \n                       double precision = 1e-12, double shift = 0.,\n                       bool normalize = false, int64_t max_iterations = 1000, \n                       double deflation_tol = 1e-7);\n\nEvolveLanczosInplaceResult\nevolve_lanczos_inplace(OpSum const &amp;H, State &amp;psi, complex z, \n                       double precision = 1e-12, double shift = 0.,\n                       bool normalize = false, int64_t max_iterations = 1000, \n                       double deflation_tol = 1e-7);\n</code></pre> <pre><code>evolve_lanczos_inplace(H::OpSum, psi::State, t::Float64; precision::Float64 = 1e-12,\n                       shift::Float64=0.0, normalize::Bool=false,\n                       max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n\nevolve_lanczos_inplace(H::OpSum, psi::State, z::ComplexF64; precision::Float64 = 1e-12,\n                       shift::Float64=0.0, normalize::Bool=false,\n                       max_iterations::Int64 = 1000, deflation_tol::Float64 = 1e-7)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/evolve_lanczos/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(\\tau\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(t) \\rangle\\) 1e-12 shift the offset \\(\\delta\\) when computing \\(\\vert \\psi(t) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle\\) 0.0 normalize flag whether or not the evolved state should be normalized false max_iterations maximum number of Lanczos iterations performed 1000 deflation_tol tolerance for deflation, i.e. breakdown of Lanczos due to Krylow space exhaustion 1e-7 <p>The parameter <code>shift</code> can be used to turn all eigenvalues of the matrix \\(H - \\delta \\;\\textrm{Id}\\) positive whenever \\(\\delta &lt; E_0\\), where \\(E_0\\) denotes the ground state energy of \\(H\\).</p>"},{"location":"documentation/algorithms/evolve_lanczos/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description alphas diagonal elements of the Lanczos tridiagonal matrix betas off-diagonal elements of the Lanczos tridiagonal matrix eigenvalues the computed Ritz eigenvalues of the tridiagonal matrix niterations number of iterations performed criterion string denoting the reason why the Lanczosalgorithm stopped state time-evolved State \\(\\vert \\psi(t)\\rangle\\) (not defined for inplace variant)"},{"location":"documentation/algorithms/evolve_lanczos/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm is estimating the following error,</p> \\[ \\varepsilon = \\parallel \\vert \\tilde{\\psi}(t)\\rangle - e^{z(H - \\delta)} \\vert \\psi_0\\rangle \\parallel_2, \\] <p>where \\(\\vert \\tilde{\\psi}(t) \\rangle\\) denotes the approximation computed during the algorithm. As the exact solution is not available this error is estimated using the method described by Algorithm 2 in</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p>"},{"location":"documentation/algorithms/evolve_lanczos/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\n// Compute ground state energy\ndouble e0 = eigval0(ops, block);\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-12;\nauto res = evolve_lanczos(ops, psi0, time, precision, e0, true, 500);\nXDIAG_SHOW(res.alphas);\nXDIAG_SHOW(res.betas);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    # Compute ground state energy\n    e0 = eigval0(ops, block)\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    res = evolve_lanczos(ops, psi0, time, precision=1e-12, shift=e0, normalize=true)\n    @show res.alphas\n    @show res.betas\nend\n</code></pre>"},{"location":"documentation/algorithms/imaginary_time_evolve/","title":"imaginary_time_evolve","text":"<p>Computes the imaginary-time evolution, </p> \\[\\vert \\psi(\\tau) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using an iterative algorithm. \\(\\delta\\) here denotes a real number which can be chosen as the ground state energy \\(\\delta=E_0\\) of \\(H\\).</p> <p>Sources imaginary_time_evolve.hpp imaginary_time_evolve.cpp imaginary_time_evolve.jl</p>"},{"location":"documentation/algorithms/imaginary_time_evolve/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>State imaginary_time_evolve(OpSum const &amp;H, State psi0, double time,\n                            double precision = 1e-12, double shift = 0.);\n</code></pre> <pre><code>imaginary_time_evolve(ops::OpSum, psi0::State, time::Float64; precision::Float64 = 1e-12, \n                      shift::Float64=0.0)::State\n</code></pre> </li> <li> <p>An inplace variant <code>imaginary_time_evolve_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>imaginary_time_evolve</code>.</p> C++Julia <pre><code>void imaginary_time_evolve_inplace(OpSum const &amp;H, State &amp;psi0, double time,\n                                   double precision = 1e-12, shift = 0.);\n</code></pre> <pre><code>imaginary_time_evolve_inplace(ops::OpSum, psi0::State, time::Float64; \n                              precision::Float64 = 1e-12, shift::Float64=0.0)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/imaginary_time_evolve/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(\\tau\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(\\tau) \\rangle\\) 1e-12 shift the offset \\(\\delta\\) when computing \\(\\vert \\psi(t) \\rangle = e^{-(H - \\delta) \\tau} \\vert \\psi_0\\rangle\\) 0.0 <p>The routine calls the subroutine evolve_lanczos implementing a Lanczos algorithm to perform the evolution. This routine can also be called explicitly if more control is desired. Please also confer to the page evolve_lanczos for further details on the specifics of the algorithm. The parameter <code>shift</code> can be used to turn all eigenvalues of the matrix \\(H - \\delta \\;\\textrm{Id}\\) positive whenever \\(\\delta &lt; E_0\\), where \\(E_0\\) denotes the ground state energy of \\(H\\).</p>"},{"location":"documentation/algorithms/imaginary_time_evolve/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\n// Compute ground state energy\ndouble e0 = eigval0(ops, block);\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-12;\nauto psi = imaginary_time_evolve(ops, psi0, time, precision, e0);\nimaginary_time_evolve_inplace(ops, psi0, time, precision, e0);\nXDIAG_SHOW(isapprox(psi0, psi));\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    # Compute ground state energy\n    e0 = eigval0(ops, block)\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    psi = imaginary_time_evolve(ops, psi0, time,\n                                precision=1e-12, shift=e0)\n    imaginary_time_evolve_inplace(ops, psi0, time, precision=1e-12, shift=e0)\n    @show isapprox(psi0, psi)\nend\n</code></pre>"},{"location":"documentation/algorithms/time_evolve/","title":"time_evolve","text":"<p>Computes the real-time evolution, </p> \\[\\vert \\psi(t) \\rangle = e^{-iHt} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using an iterative algorithm. </p> <p>Sources time_evolve.hpp time_evolve.cpp time_evolve.jl</p>"},{"location":"documentation/algorithms/time_evolve/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>State time_evolve(OpSum const &amp;H, State psi0, double time,\n                  double precision = 1e-12,\n                  std::string algorithm = \"lanczos\");\n</code></pre> <pre><code>time_evolve(ops::OpSum, psi0::State, time::Float64; \n            precision::Float64 = 1e-12, \n            algorithm::String = \"lanczos\")::State\n</code></pre> </li> <li> <p>An inplace variant <code>time_evolve_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>time_evolve</code>.</p> C++Julia <pre><code>void time_evolve_inplace(OpSum const &amp;H, State &amp;psi0, double time,\n                         double precision = 1e-12,\n                         std::string algorithm = \"lanczos\");\n</code></pre> <pre><code>time_evolve_inplace(ops::OpSum, psi0::State, time::Float64; \n                    precision::Float64 = 1e-12, \n                    algorithm::String = \"lanczos\")\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/time_evolve/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(t\\) until which the state is evolved precision accuracy of the computed time evolved state \\(\\vert \\psi(t) \\rangle\\) 1e-12 algorithm iterative algorithm which is used, one of <code>lanczos</code> or <code>expokit</code> <code>lanczos</code> <p>The <code>algorithm</code> parameter decised which backend is run. If <code>lanczos</code> is chosen, the evolve_lanczos routine is called with the standard arguments. Alternatively, <code>expokit</code> chooses the time_evolve_expokit routine. For a detailed documentation of the algorithms we refer to the evolve_lanczos and time_evolve_expokit pages. Broadly speaking, the <code>expokit</code> can yield higher precision states at arbitrarily long times at the cost of increased memory and computing time. In practice, we recommend analysing the effect of the <code>precision</code> parameters on the time evolution series obtained in both cases. </p>"},{"location":"documentation/algorithms/time_evolve/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\nauto psi = time_evolve(ops, psi0, time);\ntime_evolve_inplace(ops, psi0, time);\nXDIAG_SHOW(isapprox(psi0, psi));\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    psi = time_evolve(ops, psi0, time)\n    time_evolve_inplace(ops, psi0, time)\n    @show isapprox(psi0, psi)\nend\n</code></pre>"},{"location":"documentation/algorithms/time_evolve_expokit/","title":"time_evolve_expokit","text":"<p>Computes the real-time evolution, </p> \\[\\vert \\psi(t) \\rangle = e^{-iHt} \\vert \\psi_0\\rangle,\\] <p>of a State \\(\\vert \\psi_0 \\rangle\\) and a Hermitian operator \\(H\\) using the iterative algorithm implemented by Expokit</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p> <p>The algorithm features automatic stepsize control and computes approximate solutions with high precision according to our tests. Yet, the evolve_lanczos implementation is currently faster and more memory efficient. </p> <p>Sources time_evolve_expokit.hpp time_evolve_expokit.cpp time_evolve_expokit.jl</p>"},{"location":"documentation/algorithms/time_evolve_expokit/#definition","title":"Definition","text":"<p>The method is provided in two variants:</p> <ol> <li> <p>Returning a new state while the input state remains untouched. This variant is safe to use and simple to code.</p> C++Julia <pre><code>TimeEvolveExpokitResult time_evolve_expokit(\n    OpSum const &amp;ops, State state, double time, double precision = 1e-12,\n    int64_t m = 30, double anorm = 0., int64_t nnorm = 2);\n</code></pre> <pre><code>time_evolve_expokit(ops::OpSum, state::State, time::Float64;\n                    precision::Float64=1e-12, m::Int64 = 30, \n                    anorm::Float64 = 0.0, nnorm::Int64 = 2)\n</code></pre> </li> <li> <p>An inplace variant <code>time_evolve_expokit_inplace</code>, where the input state is overwritten and contains the time evolved state upon exit. This version is more memory efficient than <code>time_evolve_expokit</code>.</p> C++Julia <pre><code>TimeEvolveExpokitInplaceResult time_evolve_expokit_inplace(\n    OpSum const &amp;ops, State &amp;state, double time, double precision = 1e-12,\n    int64_t m = 30, double anorm = 0., int64_t nnorm = 2);\n</code></pre> <pre><code>time_evolve_expokit_inplace(ops::OpSum, state::State, time::Float64;\n                            precision::Float64=1e-12, m::Int64 = 30, \n                            anorm::Float64 = 0.0, nnorm::Int64 = 2)\n</code></pre> </li> </ol>"},{"location":"documentation/algorithms/time_evolve_expokit/#parameters","title":"Parameters","text":"Name Description Default H OpSum defining the hermitian operator \\(H\\) for time evolution psi0 initial State \\(\\vert \\psi_0 \\rangle\\) of the time evolution time time \\(t\\) until which the state is evolved precision accuracy of the computed time evolved state 1e-12 m dimension of used Krylov space, main memory requirement 30 anorm 1-norm estimate of the operator \\(H\\), if unknown default 0. computes it fresh 0. nnorm number of random samples to estimate 1-norm, usually not more than 2 required 2"},{"location":"documentation/algorithms/time_evolve_expokit/#returns","title":"Returns","text":"<p>A struct with the following entries</p> Entry Description error the computed error estimate during evolution hump the \"hump\" as defined in Expokit 10.1145/285861.285868 state time-evolved State \\(\\vert \\psi(t)\\rangle\\) (not defined for inplace variant)"},{"location":"documentation/algorithms/time_evolve_expokit/#convergence-criterion","title":"Convergence criterion","text":"<p>The algorithm is estimating the following error,</p> \\[ \\varepsilon = \\parallel \\vert \\tilde{\\psi}(t)\\rangle - e^{z(H - \\delta)} \\vert \\psi_0\\rangle \\parallel_2, \\] <p>where \\(\\vert \\tilde{\\psi}(t) \\rangle\\) denotes the approximation computed during the algorithm. As the exact solution is not available this error is estimated using the method described by Algorithm 2 in</p> <p>Expokit: A Software Package for Computing Matrix Exponentials Roger B. Sidje ACM Trans. Math. Softw., 24(1):130-156, 1998. (1998) DOI: 10.1145/285861.285868</p>"},{"location":"documentation/algorithms/time_evolve_expokit/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 8;\nint nup = N / 2;\nauto block = Spinhalf(N, nup);\n\n// Define the nearest-neighbor Heisenberg model\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1) % N});\n}\n\nauto psi0 = product_state(block, {\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"});\ndouble time = 1.0;\ndouble precision = 1e-8;\nauto res1 = time_evolve_expokit(ops, psi0, time, precision);\nauto res2 = time_evolve_expokit_inplace(ops, psi0, time, precision);\nXDIAG_SHOW(isapprox(psi0, res1.state));\nXDIAG_SHOW(res1.error);\nXDIAG_SHOW(res1.hump);\n</code></pre> <pre><code>let\n    N = 8\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    psi0 = product_state(block, [\"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\", \"Up\", \"Dn\"])\n    time = 1.0\n    res1 = time_evolve_expokit(ops, psi0, time, precision=1e-8)\n    res2 = time_evolve_expokit_inplace(ops, psi0, time, precision=1e-8)\n    @show isapprox(psi0, res1.state)\n    @show res1.error\n    @show res1.hump\nend\n</code></pre>"},{"location":"documentation/blocks/electron/","title":"Electron","text":"<p>A block in an Electron (fermions with \\(\\uparrow, \\downarrow\\) spin) Hilbert space. </p> <p>Sources electron.hpp electron.cpp electron.jl</p>"},{"location":"documentation/blocks/electron/#constructors","title":"Constructors","text":"C++Julia <pre><code>Electron(int64_t nsites, std::string backend = \"auto\");\nElectron(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\nElectron(int64_t nsites, Representation irrep, std::string backend = \"auto\");\nElectron(int64_t nsites, int64_t nup, int64_t ndn, Representation irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>Electron(nsites::Int64, backend::String=\"auto\")\nElectron(nsites::Int64, nup::Int64, ndn::Int64, backend::String=\"auto\")\nElectron(nsites::Int64, irrep::Representation, backend::String=\"auto\")\nElectron(nsites::Int64, nup::Int64, ndn::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code></p>"},{"location":"documentation/blocks/electron/#iteration","title":"Iteration","text":"<p>An Electron block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = Electron(4, 2, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre> <pre><code>block = Electron(4, 2, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/electron/#methods","title":"Methods","text":""},{"location":"documentation/blocks/electron/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJ block.</p> C++Julia <pre><code>int64_t index(tJ const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::tJ, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/electron/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(tJ const &amp;block);\n</code></pre> <pre><code>nsites(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(tJ const &amp;block) const;\n</code></pre> <pre><code>size(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(tJ const &amp;block) const;\n</code></pre> <pre><code>dim(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/electron/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(tJ const &amp;block);\n</code></pre> <pre><code>isreal(block::tJ)::Bool\n</code></pre>"},{"location":"documentation/blocks/electron/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without number conservation\nauto block = Electron(N);\nXDIAG_SHOW(block);\n\n// with number conservation\nauto block_np = Electron(N, nup, ndn);\nXDIAG_SHOW(block_np);\n\n// with symmetries, without number conservation\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1, -1, 1, -1});\nauto block_sym = Electron(N, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and number conservation\nauto block_sym_np = Electron(N, nup, ndn, irrep);\nXDIAG_SHOW(block_sym_np);\nXDIAG_SHOW(block_sym_np.nsites());\nXDIAG_SHOW(block_sym_np.size());\n\n// Iteration\nfor (auto pstate : block_sym_np) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym_np, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without number conservation\nblock = Electron(N)\n@show block\n\n# with number conservation\nblock_np = Electron(N, nup, ndn)\n@show block_np\n\n# with symmetries, without number conservation\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = Electron(N, rep)\n@show block_sym\n\n# with symmetries and number conservation\nblock_sym_np = Electron(N, nup, ndn, rep)\n@show block_sym_np\n@show nsites(block_sym_np)\n@show size(block_sym_np)\n\n# Iteration\nfor pstate in block_sym_np\n    @show pstate, index(block_sym_np, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/electron_distributed/","title":"ElectronDistributed","text":"<p>A block in an electron type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin with distributed computing capabilities. </p> <p>Sources electron_distributed.hpp electron_distributed.cpp</p>"},{"location":"documentation/blocks/electron_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>ElectronDistributed(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/electron_distributed/#iteration","title":"Iteration","text":"<p>An ElectronDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = ElectronDistributed(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/electron_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/electron_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the ElectronDistributed block.</p> C++ <pre><code>int64_t index(ElectronDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/electron_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(ElectronDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/electron_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(ElectronDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/electron_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(ElectronDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/electron_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(ElectronDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/spinhalf/","title":"Spinhalf","text":"<p>A block in a spin \\(S=1/2\\)  Hilbert space. </p> <p>Sources spinhalf.hpp spinhalf.cpp spinhalf.jl</p>"},{"location":"documentation/blocks/spinhalf/#constructors","title":"Constructors","text":"C++Julia <pre><code>Spinhalf(int64_t nsites, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, int64_t nup, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, Representation const &amp;irrep, std::string backend = \"auto\");\nSpinhalf(int64_t nsites, int64_t nup, Representation const &amp;irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>Spinhalf(nsites::Int64, backend::String=\"auto\")\nSpinhalf(nsites::Int64, nup::Int64, backend::String=\"auto\")\nSpinhalf(nsites::Int64, irrep::Representation, backend::String=\"auto\")\nSpinhalf(nsites::Int64, nup::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" spin setting spin (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>, <code>1sublattice</code>, <code>2sublattice</code>, <code>3sublattice</code>, <code>4sublattice</code>, and <code>5sublattice</code>. The backends <code>xsublattice</code> implement the sublattice coding algorithm described in Wietek, L\u00e4uchli, Phys. Rev. E 98, 033309 (2018). The sublattice coding algorithms impose certain constraints on the symmetries used, as described in the reference. </p>"},{"location":"documentation/blocks/spinhalf/#iteration","title":"Iteration","text":"<p>An Spinhalf block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = Spinhalf(4, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre> <pre><code>block = Spinhalf(4, 2)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#methods","title":"Methods","text":""},{"location":"documentation/blocks/spinhalf/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the Spinhalf block.</p> C++Julia <pre><code>int64_t index(Spinhalf const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::Spinhalf, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/spinhalf/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(Spinhalf const &amp;block);\n</code></pre> <pre><code>nsites(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(Spinhalf const &amp;block) const;\n</code></pre> <pre><code>size(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(Spinhalf const &amp;block) const;\n</code></pre> <pre><code>dim(block::Spinhalf)::Int64\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(Spinhalf const &amp;block);\n</code></pre> <pre><code>isreal(block::Spinhalf)::Bool\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\n\n// without Sz conservation\nauto block = Spinhalf(N);\nXDIAG_SHOW(block);\n\n// with Sz conservation\nauto block_sz = Spinhalf(N, nup);\nXDIAG_SHOW(block_sz);\n\n// with symmetries, without Sz\nPermutation p1 = {0, 1, 2, 3};\nPermutation p2 = {1, 2, 3, 0};\nPermutation p3 = {2, 3, 0, 1};\nPermutation p4 = {3, 0, 1, 2};\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec({1, -1, 1, -1}));\nauto block_sym = Spinhalf(N, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and Sz\nauto block_sym_sz = Spinhalf(N, nup, irrep);\nXDIAG_SHOW(block_sym_sz);\n\nXDIAG_SHOW(block_sym_sz.nsites());\nXDIAG_SHOW(block_sym_sz.size());\n\n// Iteration\nfor (auto pstate : block_sym_sz) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym_sz, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\n\n# without Sz conservation\nblock = Spinhalf(N)\n@show block\n\n# with Sz conservation\nblock_sz = Spinhalf(N, nup)\n@show block_sz\n\n# with symmetries, without Sz\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = Spinhalf(N, rep)\n@show block_sym\n\n# with symmetries and Sz\nblock_sym_sz = Spinhalf(N, nup, rep)\n@show block_sym_sz\n@show nsites(block_sym_sz)\n@show size(block_sym_sz)\n\n# Iteration\nfor pstate in block_sym_sz\n    @show pstate, index(block_sym_sz, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/","title":"SpinhalfDistributed","text":"<p>A block in a spin \\(S=1/2\\) Hilbert space with distributed computing capabilities.</p> <p>Sources spinhalf_distributed.hpp spinhalf_distributed.cpp</p>"},{"location":"documentation/blocks/spinhalf_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>SpinhalfDistributed(int64_t nsites, int64_t nup, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" spin setting spin (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/spinhalf_distributed/#iteration","title":"Iteration","text":"<p>An SpinhalfDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = SpinhalfDistributed(4, 2);\nfor (auto pstate : block) {\n  Log(\"{} {}\", to_string(pstate), block.index(pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/spinhalf_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the SpinhalfDistributed block.</p> C++ <pre><code>int64_t index(SpinhalfDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(SpinhalfDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(SpinhalfDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(SpinhalfDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(SpinhalfDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/tJ/","title":"tJ","text":"<p>A block in a  \\(t-J\\) type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin excluding doubly occupied sites. </p> <p>Sources tj.hpp tj.cpp tj.jl</p>"},{"location":"documentation/blocks/tJ/#constructors","title":"Constructors","text":"C++Julia <pre><code>tJ(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\ntJ(int64_t nsites, int64_t nup, int64_t ndn, Representation const &amp;irrep, std::string backend = \"auto\");\n</code></pre> <pre><code>tJ(nsites::Int64, nup::Int64, ndn::Int64, backend::String=\"auto\")\ntJ(nsites::Int64, nup::Int64, ndn::Int64, irrep::Representation, backend::String=\"auto\")\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) irrep Irreducible Representation  of the symmetry group backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/tJ/#iteration","title":"Iteration","text":"<p>An tJ block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++Julia <pre><code>auto block = tJ(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre> <pre><code>block = tJ(4, 2, 1)\nfor pstate in block\n    @show pstate, index(block, pstate) \nend\n</code></pre>"},{"location":"documentation/blocks/tJ/#methods","title":"Methods","text":""},{"location":"documentation/blocks/tJ/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJ block.</p> C++Julia <pre><code>int64_t index(tJ const &amp;block, ProductState const &amp;pstate);\n</code></pre> <pre><code>index(block::tJ, pstate::ProductState)::Int64\n</code></pre> <p>1-indexing</p> <p>In the C++ version, the index count starts from \"0\" whereas in Julia the index count starts from \"1\".</p>"},{"location":"documentation/blocks/tJ/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++Julia <pre><code>int64_t nsites(tJ const &amp;block);\n</code></pre> <pre><code>nsites(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#size","title":"size","text":"<p>Returns the size of the block, i.e. its dimension.</p> C++Julia <pre><code>int64_t size(tJ const &amp;block) const;\n</code></pre> <pre><code>size(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#dim","title":"dim","text":"<p>Returns the dimension of the block, same as \"size\" for non-distributed blocks.</p> C++Julia <pre><code>int64_t dim(tJ const &amp;block) const;\n</code></pre> <pre><code>dim(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++Julia <pre><code>bool isreal(tJ const &amp;block);\n</code></pre> <pre><code>isreal(block::tJ)::Int64\n</code></pre>"},{"location":"documentation/blocks/tJ/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without permutation symmetries\nauto block = tJ(N, nup, ndn);\nXDIAG_SHOW(block);\n\n// with permutation symmetries\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation(group, arma::vec{1, -1, 1, -1});\nauto block_sym = tJ(N, nup, ndn, irrep);\nXDIAG_SHOW(block_sym);\nXDIAG_SHOW(block_sym.nsites());\nXDIAG_SHOW(block_sym.size());\n\n// Iteration\nfor (auto pstate : block_sym) {\n  Log(\"{} {}\", to_string(pstate), index(block_sym, pstate));\n}\n</code></pre> <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without permutation symmetries\nblock = tJ(N, nup, ndn)\n@show block\n\n# with permutation symmetries\np = Permutation([2, 3, 4, 1])\ngroup = PermutationGroup([p^0, p^1, p^2, p^3])\nrep = Representation(group, [1.0, -1.0, 1.0, -1.0])\nblock_sym = tJ(N, nup, ndn, rep)\n@show block_sym\n\n@show nsites(block_sym)\n@show size(block_sym)\n\n# Iteration\nfor pstate in block_sym\n    @show pstate, index(block_sym, pstate)\nend\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/","title":"tJDistributed","text":"<p>A block in a  \\(t-J\\) type Hilbert space, i.e. fermions with \\(\\uparrow, \\downarrow\\) spin excluding doubly occupied sites with distributed computing capabilities. </p> <p>Sources tj_distributed.hpp tj_distributed.cpp</p>"},{"location":"documentation/blocks/tJ_distributed/#constructors","title":"Constructors","text":"C++ <pre><code>tJDistributed(int64_t nsites, int64_t nup, int64_t ndn, std::string backend = \"auto\");\n</code></pre> Name Description Default nsites number of sites (integer) nup number of \"up\" electrons (integer) ndn number of \"dn\" electrons (integer) backend backend used for coding the basis states <code>auto</code> <p>The parameter <code>backend</code> chooses how the block is coded internally. By using the default parameter <code>auto</code> the backend is chosen automatically. Alternatives are <code>32bit</code>, <code>64bit</code>.</p>"},{"location":"documentation/blocks/tJ_distributed/#iteration","title":"Iteration","text":"<p>An tJDistributed block can be iterated over, where at each iteration a ProductState representing the corresponding basis state is returned.</p> C++ <pre><code>auto block = tJDistributed(4, 2, 1);\nfor (auto pstate : block) {\n    Log(\"{} {}\", to_string(pstate), index(block, pstate));\n}\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#methods","title":"Methods","text":""},{"location":"documentation/blocks/tJ_distributed/#index","title":"index","text":"<p>Returns the index of a given ProductState in the basis of the tJDistributed block.</p> C++ <pre><code>int64_t index(tJDistributed const &amp;block, ProductState const &amp;pstate);\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block.</p> C++ <pre><code>int64_t nsites(tJDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#size","title":"size","text":"<p>Returns the size of the block on a local process.</p> C++ <pre><code>int64_t size(tJDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#dim","title":"dim","text":"<p>Returns the dimension of the block, i.e. the sum of all sizes across all processes. </p> C++ <pre><code>int64_t dim(tJDistributed const &amp;block) const;\n</code></pre>"},{"location":"documentation/blocks/tJ_distributed/#isreal","title":"isreal","text":"<p>Returns whether the block can be used with real arithmetic.  Complex arithmetic is needed when a Representation is genuinely complex.</p> C++ <pre><code>bool isreal(tJDistributed const &amp;block);\n</code></pre>"},{"location":"documentation/compilation/building_documentation/","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To install it please run the following commands, <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre></p> <p>To work on the documentation locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"documentation/compilation/compilation/","title":"Compilation","text":""},{"location":"documentation/compilation/compilation/#library-compilation","title":"Library Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. The library can be compiled in two different versions:</p> <ul> <li>Normal library: features parallelization using OpenMP only</li> <li>Distributed library: features distributed-memory parallelization using MPI. </li> </ul>"},{"location":"documentation/compilation/compilation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (BLAS/LAPACK, Intel MKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"documentation/compilation/compilation/#download","title":"Download","text":"<p>The source code can be downloaded from Github using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p>"},{"location":"documentation/compilation/compilation/#default-library","title":"Default library","text":"<p><pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre> By default, the library is now installed in the subdirectory <code>install</code> of your XDiag path <code>/path/to/where/xdiag/should/be</code>. If you would like to install it to another directory, you could set up the CMake compilation using,</p> <pre><code>cmake -S . -B build -D CMAKE_INSTALL_PREFIX=/path/to/where/you/want/xdiag/installed\ncmake --build build\ncmake --install build\n</code></pre>"},{"location":"documentation/compilation/compilation/#distributed-library","title":"Distributed library","text":"<p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p>"},{"location":"documentation/compilation/compilation/#application-compilation","title":"Application Compilation","text":"<p>Once an application program is written, we next need to set up the compilation instructions using CMake. To do so we a second file called <code>CMakeLists.txt</code> in the application directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(xdiag_application)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/xdiag/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used with little alteration to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our XDiag application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"documentation/compilation/compilation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Shared / Static libraries</p> <p>XDiag can be built either as a static or shared library. By default, a static library is built. To build a shared library, use the option XDIAG_SHARED_LIBS, e.g. <pre><code>cmake -S . -B build -D XDIAG_SHARED_LIBS=On\n</code></pre> Typically, shared libraries can reduce the size of the executable and are often prefered. However, when building an application and linking to a static library, the resulting binary can be used standalone, without the shared library needing to be loaded. This means once an application code is compiled, it will run the same way indefinitely, even if the XDiag library changes. Thus, it is mostly more convenient to link against the static library.</p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building examples</p> <p>To compile and run the example programs, use <pre><code>cmake -S . -B build -D BUILD_EXAMPLES=On\ncmake --build build\nbuild/examples/usage_examples\n</code></pre></p> </li> </ul>"},{"location":"documentation/compilation/compilation/#optimization","title":"Optimization","text":"<ul> <li> <p>Native optimization</p> <p>Adds the flag <code>-march=native</code> to perform optimizations for the native architecture. This can have tremendous performance impact, especially on t-J models, since then the BMI2 instructions are activated whenever they are available (e.g. newer Intel and AMD processors) <pre><code>cmake -S . -B build -D XDIAG_OPTIMIZE_FOR_NATIVE=On\n</code></pre></p> </li> </ul>"},{"location":"documentation/compilation/julia_wrapper/","title":"Building the Julia wrapper","text":"<p>In order to develop and extend the julia wrapper, one should work locally and build a local version of the <code>xdiag</code> Julia binaries. First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> <p>In order to test the new shared library <code>xdiagjl</code> together with the <code>XDiag.jl</code> library, we need to override the artifact associated with the <code>XDiag_jll.jl</code> package. For this, first we need to find out which artifact is associated with <code>XDiag_jll.jl</code>. For this enter julia and type the following commands:</p> <pre><code>julia\nusing XDiag_jll\nXDiag_jll.find_artifact_dir()\n</code></pre> <p>This gives the directory in which the artifact is defined. Now we have to add a line in the <code>Overrides.toml</code> file, typically located at <code>.julia/artifacts/Overrides.toml</code>.</p> <p>Here, we then add a line like this:</p> <pre><code>55ec928f6054024a4e9bf02e74e4da8b69175655 = \"/path/to/xdiag/install\"\n</code></pre> <p>The hash is to be replaced by the directory of the <code>XDiag_jll.jl</code> artifact.</p>"},{"location":"documentation/io/file_h5/","title":"FileH5","text":"<p>A file handler for hdf5 files. The proper tool to write results of XDiag simulations to disk. Only provided for the C++ version as Julia already provides good tools handling hdf5 files.</p> <p>Sources file_h5.hpp, file_h5.cpp</p>"},{"location":"documentation/io/file_h5/#constructors","title":"Constructors","text":"C++ <pre><code>FileH5(std::string filename, std::string iomode = \"w\");\n</code></pre> Name Description Default filename filename of the hdf5 file iomode whether to read or write to file <code>w</code> <p>There are four possible values of <code>iomode</code></p> <ol> <li><code>r</code>: read-only mode</li> <li><code>w</code>: secure write mode, new file is created if it does not exist</li> <li><code>w!</code>: forced write mode, existing file will be overwritten</li> <li><code>a</code>: append mode, new datasets in an existing file can be created</li> </ol>"},{"location":"documentation/io/file_h5/#methods","title":"Methods","text":""},{"location":"documentation/io/file_h5/#getindex-operator","title":"getindex / operator[]","text":"<p>Returns a handler to a value to be read or written from or to the hdf5 file.</p> C++ <pre><code>hdf5::FileH5Handler operator[](std::string key);\n</code></pre>"},{"location":"documentation/io/file_h5/#usage-example","title":"Usage Example","text":"C++ <pre><code>std::string filename = XDIAG_DIRECTORY \"/misc/data/hdf5/write.h5\";\nauto fl = FileH5(filename, \"w!\");\n\n// Write output to the hdf5 file\nfl[\"val\"] = 12;\nfl[\"test/to\"] = 22;\nfl[\"test/to2/group\"] = 32;\nfl[\"test/to3/group2/asdf\"] = 42;\n\nauto mat = arma::cx_mat(3, 5, arma::fill::randn);\nfl[\"a/b/c/mat\"] = mat;\n</code></pre>"},{"location":"documentation/io/file_toml/","title":"FileToml","text":"<p>A file handler for TOML files. Most funtionality is only provided for the C++ version as Julia already provides good tools handling TOML files.</p> <p>Sources file_toml.hpp, file_toml.cpp</p>"},{"location":"documentation/io/file_toml/#constructors","title":"Constructors","text":"C++Julia <pre><code>FileToml(const char *filename);\nFileToml(std::string filename);\n</code></pre> <pre><code>FileToml(filename::String)\n</code></pre> Name Description Default filename filename of the TOML file"},{"location":"documentation/io/file_toml/#methods","title":"Methods","text":""},{"location":"documentation/io/file_toml/#defined","title":"defined","text":"<p>Returns whether or not the TOML file has a certain key defined.</p> C++ <pre><code>bool defined(FileToml const &amp;fl, std::string key);\n</code></pre>"},{"location":"documentation/io/file_toml/#getindex-operator-c-only","title":"getindex / operator[] (C++ only)","text":"<p>Returns a handler to a value to be read from the TOML file.</p> C++ <pre><code>io::FileTomlHandler operator[](std::string key);\n</code></pre>"},{"location":"documentation/io/file_toml/#usage-example","title":"Usage Example","text":"C++ <pre><code>auto fl = FileToml(XDIAG_DIRECTORY \"/misc/data/toml/input.toml\");\nXDIAG_SHOW(defined(fl, \"N\"));\n\nint N = fl[\"N\"].as&lt;int&gt;();\nint nup = fl[\"nup\"].as&lt;int&gt;();\ndouble J1 = fl[\"J1\"].as&lt;double&gt;();\ndouble J2 = fl[\"J2\"].as&lt;double&gt;();\n\nauto block = Spinhalf(N, nup);\nauto H = OpSum();\nfor (int i=0; i&lt;N; ++i){\n  H += J1 * Op(\"SdotS\", {i, (i+1)%N});\n  H += J2 * Op(\"SdotS\", {i, (i+2)%N});\n}\ndouble e0 = eigval0(H, block);\nXDIAG_SHOW(e0);\n</code></pre>"},{"location":"documentation/io/read_opsum/","title":"read_opsum","text":"<p>Reads an OpSum object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_opsum/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_opsum(FileToml file, std::string tag);\n</code></pre> <pre><code>read_opsum(file::FileToml, tag::String)::OpSum\n</code></pre>"},{"location":"documentation/io/read_opsum/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the OpSum is read tag tag which holds the information in the TOML file about the OpSum"},{"location":"documentation/io/read_opsum/#data-format","title":"Data format","text":"<p>An OpSum can be defined in a TOML file as a simple list. The entries of the list are themselves also lists, which contain two or more entries:</p> <ol> <li>The first entry must be either a string or a real / complex number denoting the coupling constant of the term.</li> <li>The second entry must be a string and denotes the operator type</li> <li>The (optional) following entries are integer numbers which denote the sites of the Op</li> </ol> <p>Here is typical example of a OpSum specification in a TOML file:</p> <pre><code>Interactions = [\n  ['J1', 'SdotS', 0, 1],\n  ['J1', 'SdotS', 1, 2],\n  ['J1', 'SdotS', 2, 0],\n  ['Jchi', 'ScalarChirality', 0, 1, 2],\n]\n</code></pre>"},{"location":"documentation/io/read_opsum/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/triangular.9.hop.sublattices.tsl.toml\";\nauto fl = FileToml(file);\nauto ops = read_opsum(fl, \"Interactions\");\nXDIAG_SHOW(ops);\n</code></pre> <pre><code>file = \"triangular.9.hop.sublattices.tsl.toml\"\nfl = FileToml(file)\nops = read_opsum(fl, \"Interactions\")\n@show ops\n</code></pre>"},{"location":"documentation/io/read_permutation_group/","title":"read_permutation_group","text":"<p>Reads an PermutationGroup object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_permutation_group/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_permutation_group(FileToml file, std::string tag);\n</code></pre> <pre><code>read_permutation_group(file::FileToml, tag::String)::PermutationGroup\n</code></pre>"},{"location":"documentation/io/read_permutation_group/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the PermutationGroup is read tag tag which holds the information in the TOML file about the PermutatioGroup"},{"location":"documentation/io/read_permutation_group/#data-format","title":"Data format","text":"<p>A  PermutationGroup can be defined in a TOML file as an integer matrix, where the rows are the integers of the permutation.</p> <p>A typical specification of a \\(C_4\\) PermutationGroup is shown here:</p> <pre><code>Symmetries = [\n  [0, 1, 2, 3],\n  [1, 2, 3, 0],\n  [2, 3, 0, 1],\n  [3, 0, 1, 2]\n]\n</code></pre> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/io/read_permutation_group/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/triangular.9.hop.sublattices.tsl.toml\";\nauto fl = FileToml(file);\nauto group = read_permutation_group(fl, \"Symmetries\");\nXDIAG_SHOW(group);\n</code></pre> <pre><code>file = \"triangular.9.hop.sublattices.tsl.toml\"\nfl = FileToml(file)\ngroup = read_permutation_group(fl, \"Symmetries\")\n@show group\n</code></pre>"},{"location":"documentation/io/read_representation/","title":"read_representation","text":"<p>Reads an Representation object from a TOML file.</p> <p>Sources read.hpp, read.cpp</p>"},{"location":"documentation/io/read_representation/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum read_representation(FileToml file, std::string irrep_tag, \n                          std::string group_tag = \"Symmetries\");\n</code></pre> <pre><code>read_representation(file::FileToml, irrep_tag::String, \n                    group_tag::String = \"Symmetries\")::Representation\n</code></pre>"},{"location":"documentation/io/read_representation/#parameters","title":"Parameters","text":"Name Description file FileToml object from which the Representation is read irrep_tag tag which holds the information about the Representation in the TOML file group_tag tag which holds the information about the PermutationGroup in the TOML file \"Symmetries\""},{"location":"documentation/io/read_representation/#data-format","title":"Data format","text":"<p>A  Representation can be defined in a TOML file by specifying up two or three things:</p> <ol> <li>The PermutationGroup as an integer matrix</li> <li>The <code>characters</code> of the representation </li> <li>(optional) the <code>allowed_symmetries</code> of the representation, i.e. a list of the number of symmetries used in the irrep. By default all symmetries of the group are used in the representation.</li> </ol> <p>A typical specification of several Representations is shown here:</p> <pre><code>    Symmetries = [\n      [0, 1, 2, 3],\n      [1, 2, 3, 0],\n      [2, 3, 0, 1],\n      [3, 0, 1, 2]\n    ]\n\n    # real irrep, momentum 0\n    [k_0]\n    characters=[1.0, 1.0, 1.0, 1.0]\n\n    # complex irrep, momentum pi/2\n    [k_pi2]\n    characters=[\n      [1.0, 0.0], \n      [0.0, 1.0], \n      [-1.0, 0.0],\n      [0.0, -1.0]\n    ]\n\n    # real irrep, momentum pi\n    [k_pi]\n    characters=[1.0, -1.0, 1.0, -1.0]\n\n    # real irrep on subgroup\n    [k_pi2_half]\n    characters=[1.0, -1.0]\n    allowed_symmetries=[0, 2]\n</code></pre> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/io/read_representation/#usage-example","title":"Usage Example","text":"<p>The example reads the representation defined in the <code>irreps.toml</code> file, whose contents are shown up in the section Data format.</p> C++Julia <pre><code>std::string file = XDIAG_DIRECTORY \"/misc/data/irreps.toml\";\nauto fl = FileToml(file);\n\nauto k_0 = read_representation(fl, \"k_0\");\nXDIAG_SHOW(k_0);\nXDIAG_SHOW(isreal(k_0));\n\nauto k_pi2 = read_representation(fl, \"k_pi2\");\nXDIAG_SHOW(k_pi2);\nXDIAG_SHOW(isreal(k_pi2));\n\nauto k_pi = read_representation(fl, \"k_pi\");\nXDIAG_SHOW(k_pi);\nXDIAG_SHOW(isreal(k_pi));\n\nauto k_pi2_half = read_representation(fl, \"k_pi2_half\");\nXDIAG_SHOW(k_pi2_half);\nXDIAG_SHOW(isreal(k_pi2_half));\n</code></pre> <pre><code>file = \"irreps.toml\"\nfl = FileToml(file)\n\nk_0 = read_representation(fl, \"k_0\")\n@show k_0\n@show isreal(k_0)\n\nk_pi2 = read_representation(fl, \"k_pi2\")\n@show k_pi2\n@show isreal(k_pi2)\n\nk_pi = read_representation(fl, \"k_pi\")\n@show k_pi\n@show isreal(k_pi)\n\nk_pi2_half = read_representation(fl, \"k_pi2_half\")\n@show k_pi2_half\n@show isreal(k_pi2_half)\n</code></pre>"},{"location":"documentation/operators/hc/","title":"hc","text":"<p>Returns the hermitian conjugate \\(\\mathcal{O}^\\dagger\\) of an operator \\(\\mathcal{O}\\) represented by an Op or OpSum object. Please note the details when conjugating complex couplings, outlined in OpSum # Complex couplings.</p> <p>Sources hc.hpp hc.cpp hc.jl</p>"},{"location":"documentation/operators/hc/#definition","title":"Definition","text":"C++Julia <pre><code>Op hc(Op const &amp;op)\nOpSum hc(OpSum const &amp;ops)\n</code></pre> <pre><code>hc(op::OpSum)::Op\nhc(ops::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/hc/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto cdagup = Op(\"Cdagup\", 0);\nauto sdots = Op(\"SdotS\", {0, 1});\nauto hop = (1.0 + 1.0i) * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(cdagup == hc(cdagup));\nXDIAG_SHOW(sdots == hc(sdots));\nXDIAG_SHOW(hop == hc(hop));\n</code></pre> <pre><code>cdagup = Op(\"Cdagup\", 1)\nsdots = Op(\"SdotS\", [1, 2])\nhop = (1.0 + 1.0im) * Op(\"Hop\", [1, 2])\n@show cdagup == hc(cdagup)\n@show sdots == hc(sdots)\n@show hop == hc(hop)\n</code></pre>"},{"location":"documentation/operators/op/","title":"Op","text":"<p>Object describing a single linear operator acting on a Hilbert space.</p> <p>Sources op.hpp op.cpp op.jl</p> <p>Every operator is defined by up to three paramaters:</p> <ol> <li> <p>The type of the operator. This is a string argument which determines what kind of operator is represented. A detailed overview of the available types can be found at Operator types</p> </li> <li> <p>The sites of the operator. This defines which physical sites (or orbitals) the operator acts upon. While most operator types require sites, there are also operator types (e.g. <code>HubbardU</code>) which do not need to define sites.</p> </li> <li> <p>For special interactions, it can be necessary to additionally specify a numerical matrix, which can either be real or complex. An example is the operator type <code>Matrix</code> defining generic spin interactions.</p> </li> </ol>"},{"location":"documentation/operators/op/#constructors","title":"Constructors","text":"C++Julia <pre><code>Op(std::string type);\nOp(std::string type, int64_t site);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites);\nOp(std::string type, int64_t site, arma::mat const &amp;matrix);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites, arma::mat const &amp;matrix);\nOp(std::string type, int64_t site, arma::cx_mat const &amp;matrix);\nOp(std::string type, std::vector&lt;int64_t&gt; const &amp;sites, arma::cx_mat const &amp;matrix);\n</code></pre> <pre><code>Op(type::String)\nOp(type::String, site::Int64)\nOp(type::String, sites::Vector{Int64})\nOp(type::String, site::Int64, matrix::Matrix{Float64})\nOp(type::String, sites::Vector{Int64}, matrix::Matrix{Float64})\nOp(type::String, site::Int64, matrix::Matrix{ComplexF64})\nOp(type::String, sites::Vector{Int64}, matrix::Matrix{ComplexF64})\n</code></pre> Parameter Description type a string which denotes what kind of operator is represented sites defines on which site(s) of the lattice the operator acts on. optional matrix defines a matrix which may be needed to describe an operator. optional <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of an Op, we start counting at 1 in Julia and 0 in C++.</p>"},{"location":"documentation/operators/op/#methods","title":"Methods","text":""},{"location":"documentation/operators/op/#isreal","title":"isreal","text":"<p>Returns whether an Op is a real operator.</p> C++Julia <pre><code>bool isreal(Op const &amp;op);\n</code></pre> <pre><code>isreal(op::Op)::Bool\n</code></pre>"},{"location":"documentation/operators/op/#isapprox","title":"isapprox","text":"<p>Returns whether two Ops are approximately equal.</p> C++Julia <pre><code>bool isapprox(Op const &amp;op1, OpSum const &amp;op2, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(op1::Op, op2::Op, rtol::Float64=1e-12, atol::Float64=1e-12)::Bool\n</code></pre>"},{"location":"documentation/operators/op/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Op to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Op const &amp;op);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Op const &amp;op);\n</code></pre> <pre><code>to_string(op::Op)::String\n</code></pre>"},{"location":"documentation/operators/op/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto op = \"T\" * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(op);\n\nop = 1.23 * Op(\"Hop\", {0, 1});\nXDIAG_SHOW(op);\n\narma::cx_mat m(arma::mat(\"0 0; 0 0\"), arma::mat(\"0 -1; 1 0\"));\nop = Op(\"Matrix\", 0, m);\nXDIAG_SHOW(op);\nXDIAG_SHOW(isreal(op));\n</code></pre> <pre><code>op = \"T\" * Op(\"Hop\", [1, 2])\n@show op\n\nop = 1.23 * Op(\"Hop\",  [1, 2])\n@show op\n\nop = Op(\"Matrix\", 1, [0 -1.0im; 1.0im 0])\n@show op\n@show isreal(op)\n</code></pre>"},{"location":"documentation/operators/operator_types/","title":"Operator types","text":""},{"location":"documentation/operators/operator_types/#list-of-operator-types","title":"List of operator types","text":"<p>Generic operators in XDiag are represented as OpSum objects made up of a coupling, which can be a real/complex number or a string, and Op objects. Every Op is defined by a <code>type</code>. Here we list all the available types implemented in XDiag, their required number of sites, and the blocks for which they are available.</p> Type Description No. of sites Blocks <code>Hop</code> A hopping term for \\(\\uparrow\\) and \\(\\downarrow\\) spins of the form $$ \\textcolor{red}{-}\\sum_{\\sigma=\\uparrow\\downarrow} (tc^\\dagger_{i\\sigma}c_{j\\sigma} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed, ElectronDistributed <code>Hopup</code> A hopping term for \\(\\uparrow\\) spins of the form $$ \\textcolor{red}{-}(tc^\\dagger_{i\\uparrow}c_{j\\uparrow} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed, ElectronDistributed <code>Hopdn</code> A hopping term for \\(\\downarrow\\) spins of the form $$ \\textcolor{red}{-}(tc^\\dagger_{i\\downarrow}c_{j\\downarrow} + \\textrm{h.c.})$$ 2 tJ, Electron, tJDistributed, ElectronDistributed <code>HubbardU</code> A uniform Hubbard interaction across the full lattice of the form $$ \\sum_i n_{i\\uparrow}n_{i\\downarrow}$$ 0 Electron, ElectronDistributed <code>Cdagup</code> A fermionic creation operator for an \\(\\uparrow\\) spin \\(c^\\dagger_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Cdagdn</code> A fermionic creation operator for an \\(\\downarrow\\) spin \\(c^\\dagger_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Cup</code> A fermionic annihilation operator for an \\(\\uparrow\\) spin \\(c_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Cdn</code> A fermionic annihilation operator for an \\(\\downarrow\\) spin \\(c_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Nup</code> A number operator for an \\(\\uparrow\\) spin \\(n_{i\\uparrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Ndn</code> A number operator for an \\(\\downarrow\\) spin \\(n_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Ntot</code> A number operator \\(n_i = n_{i\\uparrow} + n_{i\\downarrow}\\) 1 tJ, Electron, tJDistributed, ElectronDistributed <code>Nupdn</code> double occupancy \\(d_i = n_{i\\uparrow} n_{i\\downarrow}\\) 1 Electron, ElectronDistributed <code>NupdnNupdn</code> double occupancy correlation \\(d_id_j\\) 2 Electron, ElectronDistributed <code>NtotNtot</code> A density-density interaction \\(n_i n_j\\) 2 tJ, Electron, tJDistributed, ElectronDistributed <code>SdotS</code> A Heisenberg interaction of the form $$ \\mathbf{S}_i \\cdot \\mathbf{S}_j = S^x_iS^x_j + S^y_iS^y_j + S^z_iS^z_j$$ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed, ElectronDistributed <code>SzSz</code> An Ising interaction of the form $ S^z_i S^z_j $ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed, ElectronDistributed <code>Exchange</code> A spin exchange interaction of the form $$ \\frac{1}{2}(JS^+_i S^-_j + J^*S^-_iS^+_j)$$ 2 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed, ElectronDistributed <code>Sz</code> A local magnetic moment in the \\(z\\)-direction $ S^z_i$ 1 Spinhalf, tJ, Electron, SpinhalfDistributed, tJDistributed, ElectronDistributed <code>S+</code> A local spin raising operator \\(S^+_i\\) 1 Spinhalf, SpinhalfDistributed <code>S-</code> A local spin lowering operator \\(S^-_i\\) 1 Spinhalf, SpinhalfDistributed <code>ScalarChirality</code> A scalar chirality interaction of the form $$ \\mathbf{S}_i \\cdot ( \\mathbf{S}_j \\times  \\mathbf{S}_k)$$ 3 Spinhalf <code>tJSzSz</code> An Ising interaction as encountered in the \\(t-J\\) model of the form $$  S^z_i S^z_j - \\frac{n_i n_j}{4}$$ 2 tJ, tJDistributed <code>tJSdotS</code> An Heisenberg  interaction as encountered in the \\(t-J\\) model of the form $$  \\mathbf{S}_i \\cdot \\mathbf{S}_j - \\frac{n_i n_j}{4}$$ 2 tJ, tJDistributed <code>Matrix</code> A generic spin interaction no an arbitrary number of sites defined via a coupling matrix arbitrary Spinhalf <code>NupNdn</code> A generic density-density interaction \\(n_{i\\uparrow}n_{j\\downarrow}\\) 2 Electron <code>NdnNup</code> A generic density-density interaction \\(n_{i\\downarrow}n_{j\\uparrow}\\) 2 Electron <code>NupNup</code> A generic density-density interaction for same-spin electrons \\(n_{i\\uparrow}n_{i\\uparrow}\\) 2 Electron <code>NdnNdn</code> A generic density-density interaction for same-spin electrons \\(n_{i\\downarrow}n_{i\\downarrow}\\) 2 Electron"},{"location":"documentation/operators/operator_types/#matrix-type","title":"Matrix type","text":"<p>The <code>Matrix</code> interaction type is a special type with whom one can define generic interactions for the Spinhalf block. In addition to the <code>type</code> and <code>sites</code> argument, also a numerical matrix is provided when constructing the Op object. The matrix describes the operator acting on the \\(2^n\\) dimensional space spanned by the \\(n\\) sites of the operator. For example, we can represent a \\(S^x\\) spin operator as,</p> C++ <pre><code>auto sx = arma::mat({{0, 1},{1, 0}});\nauto op = Op(\"Matrix\", 0, sx);\n</code></pre> <p>More generically, we can use this mechanism to construct arbitary spin interactions, e.g.   </p> C++ <pre><code>auto sx = arma::mat({{0, 1},{1, 0}});\nauto sz = arma::mat({{0.5, 1},{0, -0.5}});\n\narma::mat sxsz = arma::kron(sx, sz);\narma::mat sxszsxsz = arma::kron(sxsz, sxsz);\n\nauto op_sxsz = Op(\"Matrix\", {0, 1}, sxsz);\nauto op_sxszsxsz = Op(\"Matrix\", {0, 1, 2, 3}, sxsz);\n</code></pre> <p>Here we have been using the Kronecker product function <code>kron</code>.</p>"},{"location":"documentation/operators/opsum/","title":"OpSum","text":"<p>Object representing a generic many-body operator by a sum of operators of the form </p> \\[ \\mathcal{O} = \\sum_i c_i \\mathcal{O}_i. \\] <p>Sources opsum.hpp opsum.cpp opsum.jl</p> <p>An OpSum is consists of a sum of pairs given by</p> <ol> <li> <p>A coupling constant \\(c_i\\) which is given by a either a string name or a real/complex number.</p> </li> <li> <p>An operator \\(\\mathcal{O}_i\\) defined by an Op object.</p> </li> </ol> <p>Generically, an OpSum can thus have coupling constants defined by either strings or numerical real/complex numbers. We call an OpSum plain if its couplings are only numerical numbers, and not strings. String couplings can be defined by using the access <code>operator[]</code>. If all string coupling constants are defined, the OpSum can be converted to a plain OpSum using the <code>plain</code> method shown below.</p> <p>Thus, OpSums can be defined independently of the numerical values of the coupling constants, e.g. in an input file. Upon execution of the code, these constants can then be set. Most operations in XDiag require the OpSum to be convertible to a plain OpSum.</p> <p>OpSums can be added and subtracted, as well as multiplied with and divided by a scalar value, i.e. a real or complex number. Hence, OpSums carry the mathematical structure of a vector space.</p>"},{"location":"documentation/operators/opsum/#constructors","title":"Constructors","text":"<p>The following constructors create an OpSum with a single pair of coupling and operator. Additional terms can be added using the <code>+</code> and <code>+=</code> operators explained further below. If no coupling is given, a numerical coefficient of <code>1.0</code> is assumed.</p> C++Julia <pre><code>OpSum(Op const &amp;op);\nOpSum(double coupling, Op const &amp;op);\nOpSum(complex coupling, Op const &amp;op);\nOpSum(std::string coupling, Op const &amp;op);\n</code></pre> <pre><code>OpSum(op::Op)\nOpSum(coupling::Float64, op::Op)\nOpSum(coupling::ComplexF64, op::Op)\nOpSum(coupling::String, op::Op)\n</code></pre> Parameter Description Default coupling A coupling which is either a string or a real/complex number 1.0 op An Op which describes the type of operator <p>Alternatively, an OpSum can also be constructed via the <code>* operator</code>, for example:</p> C++Julia <pre><code>auto ops = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n    ops += \"J\" * Op(\"SzSz\", {i, (i + 1) % N});\n}\n</code></pre> <pre><code>ops = OpSum();\nfor i in 1:n\n    ops += \"J\" * Op(\"SzSz\", [i, mod1(i+1, N)]);\n</code></pre>"},{"location":"documentation/operators/opsum/#complex-couplings","title":"Complex couplings","text":"<p>XDiag allows all couplings to be complex. Depending on the operator type  a complex coupling can have two meanings:</p> <ol> <li> <p>A complex prefactor \\(c\\) which upon hermitian conjugation with hc gets     conjugated to \\(c^\\star\\). This is the case for the following interaction types:  <code>HubbardU</code>, <code>Cdagup</code>, <code>Cdagdn</code>, <code>Cup</code>, <code>Cdn</code>, <code>Nup</code>, <code>Ndn</code>, <code>Ntot</code>, <code>NtotNtot</code>,     <code>SdotS</code>, <code>SzSz</code>, <code>Sz</code>, <code>S+</code>, <code>S-</code>, <code>ScalarChirality</code>, <code>tJSzSz</code>, <code>tJSdotS</code>,     <code>Matrix</code>    Thus, a complex coupling can turn a Hermitian operator to a non-Hermitian operator.</p> </li> <li> <p>The coupling is part of the definition of the operator. For, example a hopping     operator of the form     $$ ( t c^\\dagger_{i\\sigma}c_{j\\sigma} + \\textrm{h.c.})  = ( t c^\\dagger_{i\\sigma}c_{j\\sigma} + t^\\star c^\\dagger_{j\\sigma}c_{i\\sigma}) $$    A complex coupling \\(t\\) gives the hopping a phase, but the overall operator remains    Hermitian and, thus, invariant under hc. This holds for the types     <code>Hop</code>, <code>Hopup</code>, <code>Hopdn</code>, <code>Exchange</code>. In the latter case, complex spin exchange     <code>Exchange</code> is defined as,    $$ \\frac{1}{2}( J S^+_i S^-_j + J^\\star S^-_iS^+_j)$$</p> </li> </ol>"},{"location":"documentation/operators/opsum/#methods","title":"Methods","text":""},{"location":"documentation/operators/opsum/#plain","title":"plain","text":"<p>Converts an OpSum with possible string couplings to an OpSum with purely numerical real/complex couplings.</p> C++Julia <pre><code>OpSum plain(OpSum const &amp;ops) const;\n</code></pre> <pre><code>plain(ops::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-creation","title":"operator* (Creation)","text":"<p>Creates an OpSum with a single pair of coupling constant and an Op object.</p> C++Julia <pre><code>OpSum operator*(double coupling, Op const &amp;op);\nOpSum operator*(complex coupling, Op const &amp;op);\nOpSum operator*(std::string coupling, Op const &amp;op);\n</code></pre> <pre><code>Base.:*(coupling::Float64, op::Op)::OpSum\nBase.:*(coupling::ComplexF64, op::Op)::OpSum\nBase.:*(coupling::String, op::Op)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator","title":"operator+ / operator +=","text":"<p>Adds two OpSum objects \\(\\mathcal{A} = \\sum_i a_i \\mathcal{A}_i\\) and \\(\\mathcal{B} = \\sum_i b_i \\mathcal{B}_i\\) to for the sum of the two operators,     $$ \\mathcal{A} + \\mathcal{B} = \\sum_i a_i \\mathcal{A}_i + \\sum_i b_i \\mathcal{B}_i$$</p> C++Julia <pre><code>OpSum &amp;operator+=(OpSum const &amp;ops);\nOpSum operator+(OpSum const &amp;ops) const;\n</code></pre> <pre><code>Base.:+(ops1::OpSum, ops2::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator-","title":"operator- / operator -=","text":"<p>Subtracts to OpSum objects.</p> C++Julia <pre><code>OpSum &amp;operator-=(OpSum const &amp;ops);\nOpSum operator-(OpSum const &amp;ops) const;\n</code></pre> <pre><code>Base.:-(ops::OpSum, ops2::OpSum)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator-operator-scalar-muliplicationdivision","title":"operator* , operator/ (scalar muliplication/division)","text":"<p>Multiplies an OpSum \\(\\mathcal{A} = \\sum_i a_i \\mathcal{A}_i\\) with a scalar \\(b\\) to form</p> \\[\\mathcal{B} = b \\sum_i a_i \\mathcal{A}_i\\] C++Julia <pre><code>OpSum &amp;operator*=(double scalar);\nOpSum &amp;operator*=(complex scalar);\nOpSum &amp;operator/=(double scalar);\nOpSum &amp;operator/=(complex scalar);\n\nOpSum operator*(double scalar, OpSum const &amp;op);\nOpSum operator*(complex scalar, OpSum const &amp;op);\nOpSum operator*(OpSum const &amp;op, double scalar);\nOpSum operator*(OpSum const &amp;op, complex scalar);\nOpSum operator/(OpSum const &amp;op, double scalar);\nOpSum operator/(OpSum const &amp;op, complex scalar);\n</code></pre> <pre><code>Base.:*(coupling::Float64, ops::OpSum)::OpSum\nBase.:*(coupling::ComplexF64, ops::OpSum)::OpSum\nBase.:*(ops::OpSum, coupling::Float64)::OpSum\nBase.:*(ops::OpSum, coupling::ComplexF64)::OpSum\nBase.:/(ops::OpSum, coupling::Float64)::OpSum\nBase.:/(ops::OpSum, coupling::ComplexF64)::OpSum\n</code></pre>"},{"location":"documentation/operators/opsum/#operator","title":"operator[]","text":"<p>Sets a coupling constant defined as a string to a numerical value.</p> C++Julia <pre><code>Scalar &amp;operator[](std::string name);\n</code></pre> <pre><code>Base.setindex!(ops::OpSum, cpl::Float64, name::String)\nBase.setindex!(ops::OpSum, cpl::ComplexF64, name::String)\n</code></pre>"},{"location":"documentation/operators/opsum/#constants","title":"constants","text":"<p>Returns a vector of strings with the coupling constants defined, i.e. the strings that define some of the coupling constants.</p> C++Julia <pre><code>std::vector&lt;std::string&gt; constants(OpSum const &amp;ops) const;\n</code></pre> <pre><code>constants(ops::OpSum)::Vector{String}\n</code></pre>"},{"location":"documentation/operators/opsum/#isreal","title":"isreal","text":"<p>Returns whether an OpSum is a real operator.</p> C++Julia <pre><code>bool isreal(OpSum const &amp;ops);\n</code></pre> <pre><code>isreal(ops::OpSum)::Bool\n</code></pre>"},{"location":"documentation/operators/opsum/#isapprox","title":"isapprox","text":"<p>Returns whether two OpSums are approximately equal.</p> C++Julia <pre><code>bool isapprox(OpSum const &amp;ops1, OpSum const &amp;ops2, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(ops1::OpSum, ops2::OpSum, rtol::Float64=1e-12, atol::Float64=1e-12)::Bool\n</code></pre>"},{"location":"documentation/operators/opsum/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the OpSum to a readable string representation.</p> C++Julia <pre><code>std::string to_string(OpSum const &amp;ops);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, OpSum const &amp;ops);\n</code></pre> <pre><code>to_string(ops::OpSum)::String\n</code></pre>"},{"location":"documentation/operators/opsum/#usage-example","title":"Usage Example","text":"C++ <pre><code>// Define the 1D transverse-field Ising chain\nint N = 12;\ndouble J = 1.0;\ndouble h = 0.5;\nauto Sx = arma::mat(\"0 1; 1 0\");\n\n// Option 1: coupling constants as numbers\nauto ops1 = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops1 += J * Op(\"SzSz\", {i, (i+1)%N});\n  ops1 += h * Op(\"Matrix\", i, Sx);\n}\n\n// Option 2: coupling constants as strings\nauto ops2 = OpSum();\nfor (int i = 0; i&lt;N; ++i) {\n  ops2 += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n  ops2 += \"h\" * Op(\"Matrix\", i, Sx);\n}\nops2[\"J\"] = J;\nops2[\"h\"] = h;\n\nXDIAG_SHOW(isapprox(ops1, ops2));\nXDIAG_SHOW(isapprox(ops1 + ops2, 2.0 * ops1));\n</code></pre>"},{"location":"documentation/operators/symmetrize/","title":"symmetrize","text":"<p>Symmetrizes an operator with respect to a PermutationGroup or a Representation.</p> <p>Sources symmetrize.hpp symmetrize.cpp symmetrize.jl</p> <p>Symmetrization in this context means the following. In general, we are given an OpSum of the form,</p> \\[ O = \\sum_{A\\subseteq \\mathcal{L}} O_A,\\] <p>where \\(O_A\\) denotes a local operator acting on sites \\(A=\\{a_1, \\ldots, a_{l_A}\\}\\) and \\(L\\) denotes the lattice. A PermutationGroup \\(\\mathcal{G}\\) is defined through its permutations \\(\\pi_1, \\ldots, \\pi_M\\). The symmetrized operator returned by this function is then </p> \\[ O^\\mathcal{G} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}}  O_{\\pi(A)},\\] <p>where \\(\\pi(A) = \\{\\pi(a_1), \\ldots,\\pi(a_{l_A})\\}\\) denotes the permutated set of sites of the local operator \\(O_A\\). If a Representation called \\(\\rho\\) is given in addition, the following operator is constructed,</p> \\[ O^\\mathcal{G, \\rho} = \\frac{1}{M}\\sum_{A\\subseteq \\mathcal{L}} \\sum_{\\pi \\in \\mathcal{G}} \\chi_\\rho(\\pi) O_{\\pi(A)},\\] <p>where \\(\\chi_\\rho(\\pi)\\) denotes the characters of the representation \\(\\rho\\). This routine is useful to evaluate observables in symmetrized blocks.</p>"},{"location":"documentation/operators/symmetrize/#definition","title":"Definition","text":"C++Julia <pre><code>OpSum symmetrize(Op const &amp;op, PermutationGroup const &amp;group);\nOpSum symmetrize(Op const &amp;op, Representation const &amp;irrep);\nOpSum symmetrize(OpSum const &amp;ops, PermutationGroup const &amp;group);\nOpSum symmetrize(OpSum const &amp;ops, Representation const &amp;irrep);\n</code></pre> <pre><code>symmetrize(op::Op, group::PermutationGroup)::OpSum\nsymmetrize(op::Op, irrep::Representation)::OpSum\nsymmetrize(ops::OpSum, group::PermutationGroup)::OpSum\nsymmetrize(ops::OpSum, irrep::Representation)::OpSum\n</code></pre>"},{"location":"documentation/operators/symmetrize/#parameters","title":"Parameters","text":"Name Description ops / op OpSum or Op defining the operator to be symmetrized group PermutationGroup defining the permutation symmetries irrep Irreducible Representation  of the symmetry group"},{"location":"documentation/operators/symmetrize/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>int N = 4;\nint nup = 2;\nauto block = Spinhalf(N, nup);\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto rep = Representation(group);\nauto block_sym = Spinhalf(N, rep);\n\nauto ops = OpSum();\nfor (int i=0; i&lt;N; ++i) {\n  ops += Op(\"SdotS\", {i, (i+1)%N});\n}\nauto [e0, psi] = eig0(ops, block);\nauto [e0s, psi_sym] = eig0(ops, block_sym);\n\nauto corr = Op(\"SdotS\", {0, 1});\nauto nn_corr = inner(corr, psi);\nauto corr_sym = symmetrize(corr, group);\nauto nn_corr_sym = innerC(corr_sym, psi_sym);\nXDIAG_SHOW(nn_corr);\nXDIAG_SHOW(nn_corr_sym);\n</code></pre> <pre><code>let\n    N = 4\n    nup = 2\n    block = Spinhalf(N, nup)\n    p1 = Permutation([1, 2, 3, 4])\n    p2 = Permutation([2, 3, 4, 1])\n    p3 = Permutation([3, 4, 1, 2])\n    p4 = Permutation([4, 1, 2, 3])\n    group = PermutationGroup([p1, p2, p3, p4])\n    rep = Representation(group)\n    block_sym = Spinhalf(N, rep)\n\n    ops = OpSum()\n    for i in 1:N\n        ops += Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n\n    e0, psi = eig0(ops, block);\n    e0, psi_sym = eig0(ops, block_sym);\n\n    corr = Op(\"SdotS\", [1, 2])\n    nn_corr = inner(corr, psi)\n    corr_sym = symmetrize(corr, group)\n    nn_corr_sym = inner(corr_sym, psi_sym)\n    @show nn_corr, nn_corr_sym\nend\n</code></pre>"},{"location":"documentation/states/create_state/","title":"Creating specific States","text":"<p>Sources create_state.hpp, create_state.cpp</p>"},{"location":"documentation/states/create_state/#product_state","title":"product_state","text":"<p>Creates a filled product state.</p> C++Julia <pre><code>State product_state(Block const &amp;block, std::vector&lt;std::string&gt; const &amp;local_state, bool real = true);\n</code></pre> <pre><code>product_state(block::Block, local_states::Vector{String}; real::Bool=true)\n</code></pre>"},{"location":"documentation/states/create_state/#parameters","title":"Parameters","text":"Name Description block block on which the state is defined local_states local configurations of the product state real flag whether real state is created"},{"location":"documentation/states/create_state/#random_state","title":"random_state","text":"<p>Create a filled random state with normal \\(\\mathcal{N}(0, 1)\\) distributed coefficients.</p> C++Julia <pre><code>State random_state(Block const &amp;block, bool real = true, int64_t seed = 42, bool normalized = true);\n</code></pre> <pre><code>random_state(block::Block; real::Bool=true, seed::Int64=42, normalized::Bool=true\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_1","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created seed random seed determining the precise random numbers normalized flag whether the state is normalized"},{"location":"documentation/states/create_state/#zero_state","title":"zero_state","text":"<p>Create a filled state with all zero entries.</p> C++Julia <pre><code>State zero_state(Block const &amp;block, bool real = true, int64_t ncols = 1);\n</code></pre> <pre><code>zero_state(block::Block; real::Bool=true, ncols::Int64=1)\n</code></pre>"},{"location":"documentation/states/create_state/#parameters_2","title":"Parameters","text":"Name Description block block on which the state is defined real flag whether real state is created ncols number of columns in the state"},{"location":"documentation/states/create_state/#zero","title":"zero","text":"<p>Set all coefficients of a given state to zero.</p> C++Julia <pre><code>void zero(State &amp;state);\n</code></pre> <pre><code>zero(state::State)\n</code></pre>"},{"location":"documentation/states/create_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = product_state(block, {\"Up\", \"Dn\"});\nXDIAG_SHOW(state.vector());\n\nzero(state);\nXDIAG_SHOW(state.vector());\n\nstate = random_state(block, false, 1234, true);\nXDIAG_SHOW(state.vectorC());\n\nstate = zero_state(block, true, 2);\nXDIAG_SHOW(state.vector());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = product_state(block, [\"Up\", \"Dn\"])\ndisplay(vector(state))\n\nzero(state)\ndisplay(vector(state))\n\nstate = random_state(block, real=false, seed=1234, normalized=true)\ndisplay(vector(state))\n\nstate = zero_state(block, real=true, ncols=2)\ndisplay(matrix(state))\n</code></pre>"},{"location":"documentation/states/fill/","title":"fill","text":"<p>Fills a State with a given model state, e.g. a ProductState or a RandomState.</p> <p>Sources fill.hpp fill.cpp fill.jl</p>"},{"location":"documentation/states/fill/#definition","title":"Definition","text":"C++Julia <pre><code>void fill(State &amp;state, ProductState const &amp;pstate, int64_t ncol = 0);\nvoid fill(State &amp;state, RandomState const &amp;rstate, int64_t ncol = 0);\n</code></pre> <pre><code>fill(state::State, pstate::ProductState, ncol::Int64 = 1)\nfill(state::State, rstate::RandomState, ncol::Int64 = 1)\n</code></pre> Name Description state State object to be filled pstate ProductState object rstate RandomState object ncol integer deciding which column of the State is filled (default: 1/0 (Julia/C++))"},{"location":"documentation/states/fill/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = State(block);  \nauto pstate = ProductState({\"Up\", \"Dn\"});\nfill(state, pstate);\nXDIAG_SHOW(state.vector());\n\nauto rstate = RandomState(1234);\nfill(state, rstate);\nXDIAG_SHOW(state.vector());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = State(block)\npstate = ProductState([\"Up\", \"Dn\"])\nfill(state, pstate)\ndisplay(vector(state))\n\nrstate = RandomState(1234)\nfill(state, rstate)\ndisplay(vector(state))\n</code></pre>"},{"location":"documentation/states/product_state/","title":"ProductState","text":"<p>A product state of local configurations.</p> <p>Sources product_state.hpp product_state.cpp product_state.jl</p>"},{"location":"documentation/states/product_state/#constructors","title":"Constructors","text":"C++Julia <pre><code>ProductState(int64_t nsites);\nProductState(std::vector&lt;std::string&gt; const &amp;local_states);\n</code></pre> <pre><code>ProductState(nsites::Int64)\nProductState(local_states::Vector{String})\n</code></pre> Parameter Description nsites construct a product state on nsites local_states the local configurations of the product state"},{"location":"documentation/states/product_state/#iteration","title":"Iteration","text":"<p>A ProductState can be iterated over, where at each iteration the string of the local configuration is retured. Here is an example:</p> C++Julia <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n    Log(\"{}\", s);\n}\n</code></pre> <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n</code></pre>"},{"location":"documentation/states/product_state/#methods","title":"Methods","text":""},{"location":"documentation/states/product_state/#nsites","title":"nsites","text":"<p>Returns the number of sites of the product state</p> C++Julia <pre><code>int64_t nsites(ProductState const &amp;p);\n</code></pre> <pre><code>nsites(p::ProductState)\n</code></pre>"},{"location":"documentation/states/product_state/#size","title":"size","text":"<p>Returns the number of sites of the product state. Same as \"nsites\".</p> C++Julia <pre><code>int64_t size(ProductState const &amp;p);\n</code></pre> <pre><code>size(state::ProductState)\n</code></pre>"},{"location":"documentation/states/product_state/#setindex-operator","title":"setindex! / operator[]","text":"<p>Sets the local configuration at the given site index to the given string.</p> C++Julia <pre><code>std::string &amp;operator[](int64_t i);\n</code></pre> <pre><code>setindex!(state::ProductState, local_state::String, idx::Int64)\n</code></pre>"},{"location":"documentation/states/product_state/#getindex-operator","title":"getindex / operator[]","text":"<p>Returns the string of the local configuration at the given site index.</p> C++Julia <pre><code>std::string const &amp;operator[](int64_t i) const;\n</code></pre> <pre><code>getindex(state::ProductState, idx::Int64)\n</code></pre>"},{"location":"documentation/states/product_state/#push-push_back","title":"push! / push_back","text":"<p>Adds a local configuration add the end of the product state.</p> C++Julia <pre><code>void push_back(std::string l);\n</code></pre> <pre><code>push!(state::ProductState, local_state::String\n</code></pre>"},{"location":"documentation/states/product_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto pstate = ProductState({\"Up\", \"Dn\", \"Emp\", \"UpDn\"});\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n\npstate = ProductState();\npstate.push_back(\"Dn\");\npstate.push_back(\"Up\");\npstate.push_back(\"Dn\");\nXDIAG_SHOW(pstate.nsites());\nfor (auto s : pstate) {\n  Log(\"{}\", s);\n}\nXDIAG_SHOW(to_string(pstate));\n</code></pre> <pre><code>pstate = ProductState([\"Up\", \"Dn\", \"Emp\", \"UpDn\"])\nfor s in pstate\n    @show s\nend\n@show pstate\n\npstate = ProductState()\npush!(pstate, \"Dn\")\npush!(pstate, \"Up\")\npush!(pstate, \"Dn\")\n@show nsites(pstate)\nfor s in pstate\n    @show s\nend\n@show pstate\n</code></pre>"},{"location":"documentation/states/random_state/","title":"RandomState","text":"<p>A random state with \\(\\mathcal{N}(0, 1)\\) normal distributed coefficients.</p> <p>Sources random_state.hpp random_state.cpp random_state.jl</p>"},{"location":"documentation/states/random_state/#constructors","title":"Constructors","text":"C++Julia <pre><code>RandomState(int64_t seed = 42, bool normalized = true);\n</code></pre> <pre><code>RandomState(seed::Int64 = 42, normalized::Bool = true)\n</code></pre> Parameter Description seed random seed determining which random numbers are put normalized flag whether the State is normalized"},{"location":"documentation/states/random_state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto state = State(block, false);  // complex State\nauto rstate1 = RandomState(1234);\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n\nauto rstate2 = RandomState(4321);\nfill(state, rstate2);\nXDIAG_SHOW(state.vectorC());\n\nfill(state, rstate1);\nXDIAG_SHOW(state.vectorC());\n</code></pre> <pre><code>block = Spinhalf(2)\nstate = State(block, real=false)  # complex State\nrstate1 = RandomState(1234)\nfill(state, rstate1)\ndisplay(vector(state))\n\nrstate2 = RandomState(4321)\nfill(state, rstate2)\ndisplay(vector(state))\n\nfill(state, rstate1)\ndisplay(vector(state))\n</code></pre>"},{"location":"documentation/states/state/","title":"State","text":"<p>A generic state describing a quantum wave function \\(|\\psi \\rangle\\).</p> <p>Sources state.hpp state.cpp state.jl</p>"},{"location":"documentation/states/state/#constructors","title":"Constructors","text":"<p>A state can be constructed in three ways:</p> <ol> <li> <p>By only specifying the block. In this case the state is initialized with all coefficients zero.</p> C++Julia <pre><code>State(Block const &amp;block, bool real = true, int64_t n_cols = 1);\n</code></pre> <pre><code>State(block::Block; real::Bool = true, n_cols::Int64 = 1)\n</code></pre> </li> <li> <p>By handing a vector of coefficients.</p> C++Julia <pre><code>State(Block const &amp;block, arma::vec const &amp;vector);\nState(Block const &amp;block, arma::cx_vec const &amp;vector);\n</code></pre> <pre><code>State(block::Block, vec::Vector{Float64})\nState(block::Block, vec::Vector{ComplexF64})\n</code></pre> </li> <li> <p>By handing a matrix whose columns describe several states at once.</p> C++Julia <pre><code>State(Block const &amp;block, arma::mat const &amp;matrix);\nState(Block const &amp;block, arma::cx_mat const &amp;matrix);\n</code></pre> <pre><code>State(block::Block, mat::Matrix{Float64})\nState(block::Block, mat::Matrix{ComplexF64})\n</code></pre> </li> </ol> Parameter Description block The block of a Hilbertspace on which the state is defined real Flag whether or not the state has real coefficients n_cols Number of columns of the state (default 1) vector A vector containing the coefficients of the state. Must be same size as block. matrix A matrix containing the coefficients of the state. Number of rows must be same as block size ."},{"location":"documentation/states/state/#methods","title":"Methods","text":""},{"location":"documentation/states/state/#nsites","title":"nsites","text":"<p>Returns the number of sites of the block the state is defined on.</p> C++Julia <pre><code>int64_t nsites(State const &amp;s) const\n</code></pre> <pre><code>nsites(state::State)\n</code></pre>"},{"location":"documentation/states/state/#isapprox","title":"isapprox","text":"<p>Returns whether two states are approximately equal.</p> C++Julia <pre><code>bool isapprox(State const &amp;v, State const &amp;w, double rtol = 1e-12,\n              double atol = 1e-12);\n</code></pre> <pre><code>isapprox(v::State, w::State, rtol::Float64, atol::Float64)\n</code></pre>"},{"location":"documentation/states/state/#isreal","title":"isreal","text":"<p>Returns whether the state is real.</p> C++Julia <pre><code>int64_t isreal(State const &amp;s) const;\n</code></pre> <pre><code>isreal(state::State)\n</code></pre>"},{"location":"documentation/states/state/#real","title":"real","text":"<p>Returns the real part of the State.</p> C++Julia <pre><code>State real(State const &amp;s) const;\n</code></pre> <pre><code>real(state::State)\n</code></pre>"},{"location":"documentation/states/state/#imag","title":"imag","text":"<p>Returns the imaginary part of the State.</p> C++Julia <pre><code>State imag(State const &amp;s) const;\n</code></pre> <pre><code>imag(state::State)\n</code></pre>"},{"location":"documentation/states/state/#make_complex-make_complex","title":"make_complex! / make_complex","text":"<p>Turns a real State into a complex State. Does nothing if the state is already complex</p> C++Julia <pre><code>void make_complex(State &amp;s);\n</code></pre> <pre><code>make_complex!(state::State)\n</code></pre>"},{"location":"documentation/states/state/#dim","title":"dim","text":"<p>Returns the dimension of the block the state is defined on.</p> C++Julia <pre><code>int64_t dim(State const &amp;s) const;\n</code></pre> <pre><code>dim(block::Spinhalf)\n</code></pre>"},{"location":"documentation/states/state/#size","title":"size","text":"<p>Returns the <code>size</code> of the block (also equal to <code>nrows</code>) times the number of columns <code>ncols</code>. For distributed blocks the local size of a Block is not the same as the dimension <code>dim</code>, which is the overall dimension of the block across all processes.</p> C++Julia <pre><code>int64_t size(State const &amp;s);\n</code></pre> <pre><code>size(s::State)\n</code></pre>"},{"location":"documentation/states/state/#nrows","title":"nrows","text":"<p>Returns number of rows of the local storage.</p> C++Julia <pre><code>int64_t nrows(State const &amp;s);\n</code></pre> <pre><code>nrows(s::State)\n</code></pre>"},{"location":"documentation/states/state/#n_cols","title":"n_cols","text":"<p>Returns number of columns.</p> C++Julia <pre><code>int64_t ncols(State const &amp;s);\n</code></pre> <pre><code>ncols(s::State)\n</code></pre>"},{"location":"documentation/states/state/#col","title":"col","text":"<p>Returns a state created from the n-th column of the storage. Whether or not the storage is copied can be specified by setting the flag \"copy\".</p> C++Julia <pre><code>State col(State const &amp;s, int64_t n, bool copy = true);\n</code></pre> <pre><code>col(s::State, n::Int64 = 1; copy::Bool = true)\n</code></pre>"},{"location":"documentation/states/state/#vectorvectorc","title":"vector/vectorC","text":"<p>Returns a vector from the n-th column of the storage. In C++ use \"vector\"/\"vectorC\" to either get a real or complex vector.</p> C++Julia <pre><code>arma::vec vector(State const &amp;s, int64_t n = 0, bool copy = true);\narma::cx_vec vectorC(State const &amp;s, int64_t n = 0, bool copy = true);\n</code></pre> <pre><code>vector(state::State; n::Int64 = 1, copy::Bool=true)\n# no vectorC method in julia\n</code></pre>"},{"location":"documentation/states/state/#matrixmatrixc","title":"matrix/matrixC","text":"<p>Returns matrix representing the storage. In C++ use \"matrix\"/\"matrixC\" to either get a real or complex matrix.</p> C++Julia <pre><code>arma::vec matrix(State const &amp;s, bool copy = true);\narma::cx_vec matrixC(State const &amp;s, bool copy = true);\n</code></pre> <pre><code>matrix(state::State, copy::Bool=true)\n# no matrixC method in julia\n</code></pre>"},{"location":"documentation/states/state/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>auto block = Spinhalf(2);\nauto psi1 = State(block, arma::vec(\"1.0 2.0 3.0 4.0\"));\nXDIAG_SHOW(psi1);\nXDIAG_SHOW(vector(psi1));\nmake_complex(psi1);\nXDIAG_SHOW(vectorC(psi1));\n\nauto psi2 = State(block, false, 3);\nXDIAG_SHOW(psi2);\nXDIAG_SHOW(matrixC(psi2));\n\nauto psi3 = State(block, arma::cx_vec(arma::vec(\"1.0 2.0 3.0 4.0\"),\n                      arma::vec(\"4.0 3.0 2.0 1.0\")));\nXDIAG_SHOW(vectorC(psi3));\nXDIAG_SHOW(vector(real(psi3)));\nXDIAG_SHOW(vector(imag(psi3)));\n</code></pre> <pre><code>block = Spinhalf(2)\npsi1 = State(block, [1.0, 2.0, 3.0, 4.0])\n@show psi1\ndisplay(vector(psi1))\nmake_complex!(psi1)\ndisplay(vector(psi1))\n\npsi2 = State(block, real=false, n_cols=3)\n@show psi2\ndisplay(matrix(psi2))\n\npsi3 = State(block, [1.0+4.0im, 2.0+3.0im, 3.0+2.0im, 4.0+1.0im])\ndisplay(vector(psi3))\ndisplay(vector(real(psi3)))\ndisplay(vector(imag(psi3)))\n</code></pre>"},{"location":"documentation/symmetries/permutation/","title":"Permutation","text":"<p>Permutations of indices or lattice sites. Basic building block of a PermutationGroup. Permutations can be multiplied, inverted and raised to a power.</p> <p>Sources permutation.hpp permutation.cpp permutation.jl</p>"},{"location":"documentation/symmetries/permutation/#constructors","title":"Constructors","text":""},{"location":"documentation/symmetries/permutation/#from-an-array","title":"From an array","text":"<p>Creates an Permutation out of an array of integers, e.g. <code>{0, 2, 1, 3}</code>. If the input array is of size <code>N</code> then every number between <code>0</code> and <code>N-1</code> must occur exactly once, otherwise the Permutation is invalid.</p> <p>1-indexing in Julia / 0-indexing in C++</p> <p>To enumerate the sites of a Permutation, we start counting at 1 in Julia and 0 in C++.</p> C++Julia <pre><code>Permutation(std::initializer_list&lt;int64_t&gt; list);\nPermutation(std::vector&lt;int32_t&gt; const &amp;array);\nPermutation(std::vector&lt;int64_t&gt; const &amp;array);\n</code></pre> <pre><code>Permutation(array::Vector{Int64})\n</code></pre> Name Description array array of integers, e.g. list initializer list of the permutation ptr pointer to memory as an array size size of the array"},{"location":"documentation/symmetries/permutation/#for-identity","title":"For identity","text":"<p>Constructs an identity permutation of a given size, e.g. <code>{0, 1, 2, 3}</code>.</p> C++Julia <pre><code>Permutation(int64_t size);\n</code></pre> <pre><code>Permutation(size::Int64)\n</code></pre> Name Description size size of the identity permutation"},{"location":"documentation/symmetries/permutation/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/permutation/#inv","title":"inv","text":"<p>Computes the inverse permutation.</p> C++Julia <pre><code>Permutation inv(Permutation const &amp;p);\n</code></pre> <pre><code>inv(perm::Permutation)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#operator","title":"* operator","text":"<p>Concatenates two permutations by overloading the <code>*</code> operator.</p> C++Julia <pre><code>Permutation operator*(Permutation const &amp;p1, Permutation const &amp;p2);\n</code></pre> <pre><code>Base.:*(p1::Permutation, p2::Permutation)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#operator-pow","title":"^ operator, pow","text":"<p>Raises a permutation to an integer power.</p> C++Julia <pre><code>Permutation pow(Permutation const &amp;p, int64_t power);\n</code></pre> <pre><code>Base.:^(p::Permutation, power::Int64)::Permutation\n</code></pre>"},{"location":"documentation/symmetries/permutation/#size","title":"size","text":"<p>Returns the size of a Permutation.</p> C++Julia <pre><code>int64_t size(Permutation const &amp;p);\n</code></pre> <pre><code>size(p::Permutation)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Permutation to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Permutation const &amp;perm);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Permutation const &amp;perm);\n</code></pre> <pre><code>to_string(perm::Permutation)::String\n</code></pre>"},{"location":"documentation/symmetries/permutation/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>Permutation p1 = {0, 2, 1, 3};\nPermutation p2 = {2, 0, 1, 3};\n\nXDIAG_SHOW(inv(p1));\nXDIAG_SHOW(p1*p2);\n</code></pre> <pre><code>p1 = Permutation([1, 3, 2, 4])\np2 = Permutation([3, 1, 2, 4])\n\n@show inv(p1)\n@show p1 * p2\n@show p1 ^ 2\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/","title":"PermutationGroup","text":"<p>A group of permutations. Group axioms are verified during construction.</p> <p>Sources permutation_group.hpp permutation_group.cpp permutation_group.jl</p>"},{"location":"documentation/symmetries/permutation_group/#constructor","title":"Constructor","text":""},{"location":"documentation/symmetries/permutation_group/#from-permutations","title":"From Permutations","text":"<p>Creates an PermutationGroup out of a vector of Permutation objects.</p> C++Julia <pre><code>PermutationGroup(std::vector&lt;Permutation&gt; const &amp;permutations);\n</code></pre> <pre><code>PermutationGroup(permutations::Vector{Permutation})\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#from-matrix","title":"From matrix","text":"<p>Creates a PermutationGroup out of a matrix whose rows specify the individual permutations. If a raw pointer is handed, the matrix is assumed to be in column-major form.</p> C++Julia <pre><code>PermutationGroup(arma::Mat&lt;int64_t&gt; const &amp;matrix);\nPermutationGroup(int64_t *ptr, int64_t n_permutations, int64_t nsites);\n</code></pre> <pre><code>PermutationGroup(matrix::Matrix{Int64})\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/permutation_group/#nsites","title":"nsites","text":"<p>Returns the number of sites on which the permutations of the group acts.</p> C++Julia <pre><code>int64_t nsites(PermutationGroup const &amp;group);\n</code></pre> <pre><code>nsites(group::PermutationGroup)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#size","title":"size","text":"<p>Returns the size of the permutation group, i.e. the number permutations.</p> C++Julia <pre><code>int64_t size(PermutationGroup const &amp;group);\n</code></pre> <pre><code>size(group::PermutationGroup)::Int64\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the PermutationGroup to a readable string representation.</p> C++Julia <pre><code>std::string to_string(PermutationGroup const &amp;group);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, PermutationGroup const &amp;group);\n</code></pre> <pre><code>to_string(group::PermutationGroup)::String\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>// Define a cyclic group of order 3\nPermutation p1 = {0, 1, 2};\nPermutation p2 = {1, 2, 0};\nPermutation p3 = {2, 0, 1};\nauto C3 = PermutationGroup({p1, p2, p3});\n\nXDIAG_SHOW(C3.size());\nXDIAG_SHOW(C3.nsites());\n</code></pre> <pre><code># Define a cyclic group of order 3\np1 = Permutation([1, 2, 3])\np2 = Permutation([2, 3, 1])\np3 = Permutation([3, 1, 2])\nC3 = PermutationGroup([p1, p2, p3])\n\n@show size(C3)\n@show nsites(C3)\n</code></pre>"},{"location":"documentation/symmetries/representation/","title":"Representation","text":"<p>A (1D) irreducible representation of a finite group. Upon creation, the group homomorphism properties are verified.</p> <p>Sources representation.hpp representation.cpp representation.jl</p>"},{"location":"documentation/symmetries/representation/#constructors","title":"Constructors","text":""},{"location":"documentation/symmetries/representation/#trivial-representation","title":"Trivial representation","text":"<p>Creates the trivial representation (all characters equal to 1) of a PermutationGroup</p> C++Julia <pre><code>Representation(PermutationGroup const &amp;group);\n</code></pre> <pre><code>Representation(group::PermutationGroup)\n</code></pre>"},{"location":"documentation/symmetries/representation/#with-characters","title":"With characters","text":"<p>Creates a 1D representation of a PermutationGroup with given real or complex characters.</p> C++Julia <pre><code>template &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, std::vector&lt;T&gt; const &amp;characters);\ntemplate &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, arma::Col&lt;T&gt; const &amp;characters);\ntemplate &lt;typename T&gt;\nRepresentation(PermutationGroup const &amp;group, T *characters, int64_t n_characters);\n</code></pre> <pre><code>Representation(group::PermutationGroup, characters::Vector{Float64})\nRepresentation(group::PermutationGroup, characters::Vector{ComplexF64})\n</code></pre> Name Description group PermutationGroup of the Representation characters characters of the representation n_characters length of the array of characters <p>The template parameter <code>T</code> in C++ can either be <code>double</code> or <code>complex</code>.</p>"},{"location":"documentation/symmetries/representation/#methods","title":"Methods","text":""},{"location":"documentation/symmetries/representation/#size","title":"size","text":"<p>Returns the size of the Representation, i.e. the number of group elements represented.</p> C++Julia <pre><code>int64_t size(Representation const &amp;irrep);\n</code></pre> <pre><code>size(irrep::Representation)::Int64\n</code></pre>"},{"location":"documentation/symmetries/representation/#isreal","title":"isreal","text":"<p>Returns the whether or not the Representation is real, I.E. the characters are real numbers and do not have an imaginary part.</p> C++Julia <pre><code>bool isreal(Representation const &amp;irrep) const;\n</code></pre> <pre><code>isreal(irrep::Representation)::Bool\n</code></pre>"},{"location":"documentation/symmetries/representation/#operator","title":"* operator","text":"<p>Multiplies two Representations by overloading the <code>*</code> operator.</p> C++Julia <pre><code>Representation operator*(Representation const &amp;r1, Representation const &amp;r2);\n</code></pre> <pre><code>Base.:*(r1::Representation, r2::Representation)::Representation\n</code></pre>"},{"location":"documentation/symmetries/representation/#to_string-operator","title":"to_string (operator&lt;&lt;)","text":"<p>Converts the Representation to a readable string representation.</p> C++Julia <pre><code>std::string to_string(Representation const &amp;irrep);\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Representation const &amp;irrep);\n</code></pre> <pre><code>to_string(irrep::Representation)::String\n</code></pre>"},{"location":"documentation/symmetries/representation/#usage-example","title":"Usage Example","text":"C++Julia <pre><code>Permutation p = {1, 2, 3, 0};\nauto C4 = PermutationGroup({pow(p, 0), pow(p, 1), pow(p, 2), pow(p, 3)});\nRepresentation r1(C4, arma::vec{1.0, -1.0, 1.0, -1.0});\nRepresentation r2(C4, arma::cx_vec{1.0, 1.0i, -1.0, -1.0i});\nXDIAG_SHOW(r1 * r2);\n</code></pre> <pre><code>p = Permutation([2, 3, 4, 1])\nC4 = PermutationGroup([p^0, p^1, p^2, p^3])\nr1 = Representation(C4, [1.0, -1.0, 1.0, -1.0])\nr2 = Representation(C4, [1.0, 1.0im, -1.0, -1.0im])\n@show r1 * r2\n</code></pre>"},{"location":"documentation/utilities/logging/","title":"Logging","text":"<p>Sources logger.hpp, logger.cpp</p>"},{"location":"documentation/utilities/logging/#setting-the-verbosity","title":"Setting the verbosity","text":"<p>Algorithms implemented in XDiag do not output anything during their execution by default. However, it is typically useful to get some information on how the code is performing and even intermediary results at runtime. For this, the verbosity of the internal XDiag logging can be set using the function <code>set_verbosity</code>, which is defined as </p> C++Julia <pre><code>void set_verbosity(int64_t level);\n</code></pre> <pre><code>set_verbosity(level::Integer);\n</code></pre> <p>There are several levels of verbosity, defining how much information is shown.</p> level outputed information 0 no information 1 some information 2 detailed information <p>For example, when computing a ground state energy using the eigval0 function, we can set a higher verbosity level using</p> C++Julia <pre><code>set_verbosity(2);\ndouble e0 = eigval0(bonds, block);\n</code></pre> <pre><code>set_verbosity(2);\ne0 = eigval0(bonds, block);\n</code></pre> <p>This will print detailed information, which can look like this</p> <pre><code>Lanczos iteration 1\nMVM: 0.00289 secs\nalpha: -0.2756971549998545\nbeta: 1.7639347562074059\neigs: -0.2756971549998545\nLanczos iteration 2\nMVM: 0.00244 secs\nalpha: -0.7116140394927443\nbeta: 2.3044797637130743\neigs: -2.2710052270892791 1.2836940325966804\nLanczos iteration 3\nMVM: 0.00210 secs\nalpha: -1.2772539678430306\nbeta: 2.6627870395174456\neigs: -3.7522788386927637 -0.6474957945455240 2.1352094709026579\n</code></pre>"},{"location":"documentation/utilities/logging/#log-mechanism-c-only","title":"Log mechanism (C++ only)","text":"<p>Producing nicely formatted output is unfortunately a bit cumbersome in standard C++. For this, the <code>Log</code> mechanism in XDiag can help. To simply write out a line of information you can call,</p> <pre><code>Log(\"hello from the logger\");\n</code></pre> <p>By default, a new line is added. It is also possible to set verbosity by handing the level as the first argument,</p> <pre><code>Log(2, \"hello from the logger only if global verbosity is set to &gt;= 2\");\n</code></pre> <p>This message will only appear if the global verbosity level is set to a value \\(\\geq 2\\). Finally, XDiag also supports formatted output by using the fmtlib library. For example, numbers can be formated this way</p> <pre><code>Log(\"pi is around {:.4f} and the answer is {}\", 3.141592, 42);\n</code></pre>"},{"location":"documentation/utilities/timing/","title":"Timing","text":"<p>In standard C++ measuring time is a bit awkward. To quickly monitor the CPU time spent by XDiag by simple functions.</p>"},{"location":"documentation/utilities/timing/#simple-timing-using-tic-toc","title":"Simple timing using tic() / toc()","text":"<p>Similar as in Matlab one can use <code>tic()</code> and <code>toc()</code> to measure the time spent between two points in the code. </p> <pre><code>tic();\ndouble e0 = eigval0(bonds, block);\ntoc();\n</code></pre> <p><code>toc()</code> will output the time spent since the last time <code>tic()</code> has been called.</p>"},{"location":"documentation/utilities/timing/#detailed-timing","title":"Detailed timing","text":"<p>To get the present time, simply call </p> <pre><code>auto time = rightnow();\n</code></pre> <p>A timing (in second) between two time points can be written to output using</p> <pre><code>timing(begin, end);\n</code></pre> <p>This can even be accompanied by a message about what is being timed and a verbosity level (see Logging) can also be set. The full call signature is</p> <pre><code>timing(begin, end, message, level);\n</code></pre> Name Description Default begin starting time computed using <code>rightnow()</code> end end time computed using <code>rightnow()</code> message message string to be prepended to timing \"\" level verbosity level at which timing is printed 0"},{"location":"documentation/utilities/utils/","title":"Utility functions","text":""},{"location":"documentation/utilities/utils/#set_verbosity","title":"set_verbosity","text":"<p>Set how much logging is generated my XDiag to monitor the progress and behaviour of the code. There are three verbosity levels that can be set:</p> <ul> <li>0: no output at all</li> <li>1: some output </li> <li>2: detailed output </li> </ul> <p>This can be useful, e.g. to monitor the progress of an iterative algorithm</p> C++Julia <pre><code>void set_verbosity(int64_t level);\n</code></pre> <pre><code>set_verbosity(level::Int64)\n</code></pre>"},{"location":"documentation/utilities/utils/#say_hello","title":"say_hello","text":"<p>Prints a nice welcome message containing the version number and git commit used.</p> C++Julia <pre><code>void say_hello()\n</code></pre> <pre><code>say_hello()\n</code></pre>"},{"location":"documentation/utilities/utils/#print_version","title":"print_version","text":"<p>If <code>say_hello</code> is too much flower power for you, one can also just have a boring print-out of the version number using this function. </p> C++Julia <pre><code>void print_version()\n</code></pre> <pre><code>print_version()\n</code></pre>"},{"location":"documentation/utilities/xdiag_show/","title":"Debug printing","text":"<p>For quick debugging in C++, XDiag features a simple macro which outputs the name and content of a variable calles <code>XDIAG_SHOW(x)</code>. For example</p> <pre><code>Spinhalf block(16, 8);\nXDIAG_SHOW(block);\n</code></pre> <p>will write an output similar to</p> <pre><code>block:\n  nsites  : 16\n  nup     : 8\n  dimension: 12,870\n  ID       : 0xa9127434d66b9878\n</code></pre> <p>The <code>XDIAG_SHOW(x)</code> macro can be used on any XDiag object and several other standard C++ objects as well.</p>"},{"location":"examples/ahm_correlations/","title":"Charge order in the attractive Hubbard model","text":"<p>Author Hannes Karlsson</p> <p>It is well known that the attractive Hubbard model at half-filling display a ground state with a \\((\\pi,\\pi)\\) charge density wave, where doublons order in a checker board pattern. Here we show this by computing the density-density charge correlator \\(\\langle n_i n_j \\rangle\\) on a \\(4\\times 4\\) lattice. We do this by first computing the ground state using 'eig0', then constructing the operator \\(O_{ij}=\\hat{n}_i \\hat{n}_j\\) and taking the inner product.</p> <p></p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n  double U = -10.0;\n  int Lx = 2;\n  int Ly = 2;\n\n  // Construct Hamiltonian\n  auto ops = OpSum();\n  ops += \"U\" * Op(\"HubbardU\"); // apply Hubbard interaction to all sites\n\n  for (int x = 0; x &lt; Lx; x++) {\n    for (int y = 0; y &lt; Ly; y++) {\n      int s = x * Ly + y;\n      int sx = ((x + 1) % Lx) * Ly + y;\n      int sy = x * Ly + (y + 1) % Ly;\n\n      ops += \"t\" * Op(\"Hop\", {s, sx}); // hopping in x-direction\n      ops += \"t\" * Op(\"Hop\", {s, sy}); // hopping in y-direction\n    }\n  }\n  ops[\"t\"] = 1;\n  ops[\"U\"] = U;\n\n  // Create Hilbert space\n  int nup = Lx * Ly / 2;\n  int ndn = Lx * Ly / 2;\n  auto block = Electron(Lx * Ly, nup, ndn);\n\n  // Get ground state\n  auto [e0, psi0] = eig0(ops, block);\n\n  // build correlation matrix\n\n  arma::mat corr = arma::mat(Lx, Ly);\n  for (int x = 0; x &lt; Lx; x++) {\n    for (int y = 0; y &lt; Ly; y++) {\n      int s = x * Ly + y;\n      if (s == 1) {\n        continue;\n      }\n      auto op = Op(\"NtotNtot\", {1, s});\n      corr(s) = inner(op, psi0);\n    }\n  }\n\n  return 0;\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing CairoMakie\nusing HDF5\n\n\"\"\"Struct for lattice sites\"\"\"\nstruct LatticeBond\n    s1::Int64\n    x1::Float64\n    y1::Float64\n    s2::Int64\n    x2::Float64\n    y2::Float64\nend\n\n\"\"\"Returns list of all bonds on the square lattice\"\"\"\nfunction square_lattice(Lx::Int,Ly::Int;xperiodic=true,yperiodic=true)\n\n    bonds = Vector{LatticeBond}()\n\n    for x1 in 1:Lx, y1 in 1:Ly\n        s1 = (x1-1)*Ly+y1\n        for (x2,y2) in [( mod(x1,Lx)+1, y1 ),( x1, mod(y1,Ly)+1 )]\n            s2 = (x2-1)*Ly+y2\n            set = reduce(hcat,[[s1,x1,y1],[s2,x2,y2]])\n            set = set[:,sortperm(set[1,:])]     # sort according to s1 and s2\n            b = LatticeBond(set[:,1]...,set[:,2]...)\n            push!(bonds,b)\n        end\n    end\n    return bonds\nend\n\n\"\"\"Returns the Hamiltonian for the Hubbard model\"\"\"\nfunction ham(U::Float64,Lx::Int64,Ly::Int64)\n\n    lattice = square_lattice(Lx,Ly)\n    ops = OpSum()\n\n    for b in lattice # hopping term\n        ops += \"t\" * Op(\"Hop\", [b.s1,b.s2])     # both for spin up and down\n    end\n\n    ops += \"U\" * Op(\"HubbardU\")     # applies Hubbard interaction over the entire lattice\n\n    ops[\"t\"] = 1.0\n    ops[\"U\"] = U\n\n    return ops\n\nend\n\nfunction main(U::Float64,Lx::Int64,Ly::Int64)\n\n    say_hello()\n    N = Lx*Ly   # number of particles, half-filling\n\n    ops = ham(U,Lx,Ly) # create the Hamiltonian\n\n    # Hilbert space with nup = ndn\n    block = Electron(N, N \u00f7 2, N \u00f7 2)\n\n    set_verbosity(0)\n    e0, psi0 = eig0(ops,block)\n\n    corr = zeros(N)\n    for j in 2:N\n        op = Op(\"NtotNtot\",[1,j])\n        corr[j] = inner(op,psi0)\n    end\n\n    corr = reshape(corr,(Lx,Ly))\n\n    filename = \"data/ahm_correlations/U($U)_Lx($Lx)_Ly($Ly).h5\"\n\n    h5open(filename,\"w\") do f\n        write(f,\"correlator\",corr)\n    end\n\n    f = Figure()\n    ax = Axis(f[1,1],\n        xlabel=\"x\",\n        ylabel=\"y\"\n        )\n\n    heatmap!(ax,corr)\n\n    Colorbar(f[1, 2], limits = extrema([corr...]), colormap = :viridis,\n    flipaxis = false)\n\n    save(\"plots/ahm_correlations/U($U)_Lx($Lx)_Ly($Ly).png\",f)\n\nend\n\nU = -10.0\nLx, Ly = (4,4)\n\nmain(U,Lx,Ly)\n</code></pre>"},{"location":"examples/ahm_quench/","title":"Time evolution of quench","text":"<p>Author Hannes Karlsson</p> <p>In this example, we will first find the ground state for the free electron on a 2D lattice $$ H = -t \\sum_{\\langle ij,\\sigma \\rangle} c_{i\\sigma}^\\dagger c_{j\\sigma} $$ then quench it with a Hubbard interaction, i.e., we will time evolve it with the full Hubbard Hamiltonian $$ H = -t \\sum_{\\langle ij,\\sigma \\rangle} c_{i\\sigma}^\\dagger c_{j\\sigma} + U\\sum_i n_{i\\uparrow}n_{i\\downarrow}. $$.  As an observable, we will study the total double occupancy $$     \\hat{O} = \\sum_i \\langle n_{i\\uparrow}n_{i\\downarrow} \\rangle $$</p> <p></p> <p>We see that the double occupancy initially increases sharply, before going down again and entering an oscillatory behaviour.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() {\n  say_hello();\n  int Lx = 4;\n  int Ly = 4;\n\n  // construct Hamiltonian\n  auto ops = OpSum();\n  for (int x = 0; x &lt; Lx; x++) {\n    for (int y = 0; y &lt; Ly; y++) {\n      int s = x * Ly + y;\n      int sx = ((x + 1) % Lx) * Ly + y;\n      int sy = x * Ly + (y + 1) % Ly;\n\n      ops += \"t\" * Op(\"Hop\", {s, sx}); // hopping in x-direction\n      ops += \"t\" * Op(\"Hop\", {s, sy}); // hopping in y-direction\n    }\n  }\n  ops += \"U\" * Op(\"HubbardU\");\n\n  ops[\"t\"] = -1.0;\n  ops[\"U\"] = 0.0;\n\n  int nup = Lx * Ly / 2;\n  int ndn = Lx * Ly / 2;\n  auto block = Electron(Lx * Ly, nup, ndn);\n\n  auto [e0, psi] = eig0(ops, block);\n\n  ops[\"U\"] = -10.0;\n\n  auto obs = OpSum();\n  obs += Op(\"HubbardU\");\n\n  arma::vec times = arma::linspace(0, 100, 2);\n  arma::vec obs_vec = arma::vec(times.size());\n\n  for (int i = 0; i &lt; times.size(); i++) {\n    time_evolve_inplace(ops, psi, times[1] - times[0]);\n    obs_vec[i] = inner(obs, psi);\n  }\n\n  // save and plot\n\n  return 0;\n}\n</code></pre> <pre><code>using XDiag\nusing CairoMakie\n\n\"\"\"Struct for lattice sites\"\"\"\nstruct LatticeBond\n    s1::Int64\n    x1::Float64\n    y1::Float64\n    s2::Int64\n    x2::Float64\n    y2::Float64\nend\n\n\"\"\"Returns list of all bonds on the square lattice\"\"\"\nfunction square_lattice(Lx::Int,Ly::Int;xperiodic=true,yperiodic=true)\n\n    bonds = Vector{LatticeBond}()\n\n    for x1 in 1:Lx, y1 in 1:Ly\n        s1 = (x1-1)*Ly+y1\n        for (x2,y2) in [( mod(x1,Lx)+1, y1 ),( x1, mod(y1,Ly)+1 )]\n            s2 = (x2-1)*Ly+y2\n            set = reduce(hcat,[[s1,x1,y1],[s2,x2,y2]])\n            set = set[:,sortperm(set[1,:])]     # sort according to s1 and s2\n            b = LatticeBond(set[:,1]...,set[:,2]...)\n            push!(bonds,b)\n        end\n    end\n    return bonds\nend\n\n\"\"\"Returns the Hamiltonian for the Hubbard model\"\"\"\nfunction ham(U::Float64,Lx::Int64,Ly::Int64)\n\n    lattice = square_lattice(Lx,Ly)\n    ops = OpSum()\n\n    for b in lattice # hopping term\n        ops += \"t\" * Op(\"Hop\", [b.s1,b.s2])     # both for spin up and down\n    end\n\n    ops += \"U\" * Op(\"HubbardU\")     # applies Hubbard interaction over the entire lattice\n    for i in 1:Lx*Ly\n        ops += \"mu\" * Op(\"Ntot\",i)     # chemical potental\n    end\n\n    ops[\"t\"] = 1.0\n    ops[\"U\"] = U\n    #ops[\"mu\"] = -U/2\n    ops[\"mu\"] = 0.0\n\n    return ops\n\nend\n\nlet\n    U = 0.0\n    Lx,Ly = (4,3)\n    N = Lx*Ly\n        # ground state for U\n    ops = ham(U,Lx,Ly)\n    hspace = Electron(N, N \u00f7 2, N \u00f7 2)\n\n    e,psi = eig0(ops,hspace)\n\n    U = -10.0\n    ops = ham(U,Lx,Ly)\n    dt = 0.1\n    time = 10\n\n    times = range(dt,time,length=Int(time/dt))\n    obs_vec = Array{Float64}(undef,length(times))\n\n    obs = OpSum()\n    obs += Op(\"HubbardU\")\n\n    for i in 1:length(times)\n        time_evolve_inplace(ops,psi,float(dt))\n        # do measurements\n        obs_vec[i] = real(inner(obs,psi))\n    end\n\n    f = Figure()\n    ax = Axis(f[1,1],\n        xlabel=L\"time, $t$\",\n        ylabel=L\"$\\sum_i \\langle n_{i\\uparrow} n_{i\\downarrow} \\rangle $\"\n        )\n\n\n    lines!(ax,times,obs_vec)\n    save(\"../plots/quench/Lx($Lx)_Ly($Ly).png\",f)\nend\n</code></pre>"},{"location":"examples/cmake_distributed/","title":"CMakeLists.txt for the distributed XDiag library","text":""},{"location":"examples/cmake_normal/","title":"CMakeLists.txt for the normal XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(hello_world)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/where/xdiag/should/be/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre>"},{"location":"examples/entanglement_ground_state/","title":"Entanglement Entropy Ground-State XXZ","text":"<p>Author: Rafael Soares</p> <p>In this example, we compute the entanglement entropy[1] of the ground state of the spin \\(-\\frac{1}{2}\\) XXZ chain, described by the Hamiltonian: $$ \\mathcal{H} = J \\sum_{n=0}^{N-1} \\left(S^x_n\\cdot S^x_{n+1} + S^y_n\\cdot S^y_{n+1} + \\Delta S^z_n\\cdot S^z_{n+1}\\right).  $$</p> <p>The algorithm follows these steps:</p> <ol> <li> <p>Obtain the ground state \\(|\\psi_0\\rangle\\) using the Lanczos algorithm.</p> </li> <li> <p>Construct the reduced density matrix for the region with the first \\(\\ell\\) spins by tracing out the complementary degrees of freedom: $$ \\rho_{\\ell} = \\text{Tr}_{\\bar{\\ell}} \\left(|\\psi_0\\rangle\\langle\\psi_0| \\right). $$ </p> </li> <li> <p>Compute the entanglement entropy from the reduced density matrix: $$ S_\\ell = -\\text{Tr}\\left( \\rho_\\ell \\ln \\rho_\\ell  \\right), $$</p> </li> </ol> <p>which is done by diagonalizing \\(\\rho_\\ell\\).</p> <p></p> <p>As shown in the Figure above, the entanglement entropy of the XXZ chain ground state for two distinct values of \\(\\Delta\\). In the critical phase, when  \\(\\Delta \\in (-J,J)\\) [1], the entanglement entropy follows a logarithmic scaling with the subsystem size, as predicted by (1+1)-dimensional conformal field theory. Specifically, we extract the central charge, \\(c\\), by fitting the entanglement entropy to the expression derived for a finite system[2]: $$ S_{\\text{CFT}}\\left(\\ell,L \\right) = \\dfrac{c}{3} \\ln \\left( \\dfrac{L}{\\pi} \\sin\\left(\\frac{\\pi\\ell}{L}\\right)\\right) + b_0, $$ where \\(L\\) is the total size of the system and \\(b_0\\) is a constant. Away from this regime the system is in gapped phase, the system is in a gapped phase, where the entanglement entropy does not depend on the subsystem size for \\(1\\ll\\ell\\ll L\\),i.e, it follows the area-law behaviour.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nvoid push_to_ps(ProductState &amp;ps1, ProductState &amp;psA, ProductState &amp;psB);\nvoid Create_RDM(arma::cx_mat &amp;RDM, arma::vec &amp;vstate, Spinhalf &amp;Block,\n                Spinhalf &amp;BlockA, Spinhalf &amp;BlockB);\ndouble getVnE(arma::cx_mat &amp;RDM);\n\nint main() try {\n  int N = 16;         // chain length\n  double Delta = 1.0; // anisotropy\n\n  auto ops = OpSum();\n  auto block = Spinhalf(N); // Spin1/2 Block full\n\n  for (int i = 0; i &lt; N; i++) {\n    ops += Op(\"Exchange\", {i, (i + 1) % N});\n    ops += Delta * Op(\"SzSz\", {i, (i + 1) % N});\n  }\n\n  auto [e0, gs] = eig0(ops, block); // get GS with Lanczos\n\n  arma::vec vstate = vector(gs);\n\n  arma::mat vne = arma::mat(\n      N / 2, 2,\n      arma::fill::zeros); // Array to store EE as a function of subsystem size\n\n  for (int na = 0; na &lt; N / 2;\n       na++) // Compute the Entanglement entropy for different subsystems from\n             // l=1 to l=N/2, as the entanglement entropy satisfies: S(l) =\n             // S(N=l).\n  {\n    int nb = N - (na + 1);\n    auto blockA = Spinhalf((na + 1)); // Spin1/2 Block full\n    auto blockB = Spinhalf(nb);       // Spin1/2 Block full\n    arma::cx_mat RDM =\n        arma::cx_mat(dim(blockA), dim(blockA), arma::fill::zeros);\n    Create_RDM(RDM, vstate, block, blockA, blockB);\n    vne(na, 0) = (na + 1);\n    vne(na, 1) = getVnE(RDM);\n  }\n\n  // Construct the filename\n  std::string flstring = \"EE_XXX_model.Nsites.\" + std::to_string(N) + \".Delta\" +\n                         std::to_string((double)Delta) + \".outfile.h5\";\n\n  auto save_fl = FileH5(flstring, \"w!\");\n  save_fl[\"entanglement_entropy\"] = vne;\n  return 0;\n} catch (Error e) {\n  error_trace(e);\n}\n\nvoid push_to_ps(ProductState &amp;ps1, ProductState &amp;psA, ProductState &amp;psB) {\n  for (auto sub : psA) {\n    ps1.push_back(sub);\n  }\n  for (auto sub : psB) {\n    ps1.push_back(sub);\n  }\n}\n\nvoid Create_RDM(arma::cx_mat &amp;RDM, arma::vec &amp;vstate, Spinhalf &amp;Block,\n                Spinhalf &amp;BlockA, Spinhalf &amp;BlockB) {\n  int i = 0;\n  int j = 0;\n  for (auto p1 : BlockA) {\n    j = 0;\n    for (auto p2 : BlockA) {\n      for (auto p3 : BlockB) // loop over all configurations in subspace that we\n                             // are interested in tracing.\n      {\n        auto p1aux = ProductState();\n        auto p2aux = ProductState();\n        push_to_ps(p1aux, p1, p3);\n        push_to_ps(p2aux, p2, p3);\n        int id1 = index(Block, p1aux);\n        int id2 = index(Block, p2aux);\n        RDM(j, i) += vstate(id2) * std::conj(vstate(id1));\n      }\n      j++;\n    }\n    i++;\n  }\n}\n\ndouble getVnE(arma::cx_mat &amp;RDM) {\n  // Compute the Entanglement entropy\n  double vne = 0.0;\n  arma::vec pvals;\n  arma::cx_mat eigvec;\n  arma::eig_sym(pvals, eigvec, RDM); // FULL ED in the RDM\n\n  for (int p = 0; p &lt; pvals.n_elem; p++) {\n    if (pvals(p) &gt; 1e-14)\n      vne -= pvals(p) * log(pvals(p));\n  }\n  return vne;\n};\n</code></pre> <pre><code>using LinearAlgebra\nusing XDiag\nusing HDF5\nusing Printf\n\nfunction push_ProductState!(ps1, psA, psB)\n    for sub in psA\n        push!(ps1, String(sub))\n    end\n    for sub in psB\n        push!(ps1, String(sub))\n    end\nend\n\nfunction Create_RDM(RDM, vstate, Block, BlockA, BlockB) #Function to construct the RDM\n    for (i, p1) in enumerate(BlockA)\n        for (j, p2) in enumerate(BlockA)\n            for (k, p3) in enumerate(BlockB)\n                p1aux = ProductState()\n                p2aux = ProductState()\n                push_ProductState!(p1aux, p1, p3)\n                push_ProductState!(p2aux, p2, p3)\n                id1 = index(Block, p1aux)\n                id2 = index(Block, p2aux)\n                RDM[j, i] += vstate[id2] * conj(vstate[id1])\n            end\n        end\n    end\nend\n\nfunction getVnE(RDM) #Function to compute the entanglement entropy.\n    vne = 0\n    p = eigvals(Hermitian(RDM))#FULL ED in the RDM\n    for i in p\n        if i&gt;1e-14\n            vne -= i*log(i)\n        end\n    end\n    return vne\nend\n\nfunction main()\n    N = 16 # chain length\n    ops = OpSum()\n    block = Spinhalf(N) # Spin1/2 Block full\n    Delta = 1.0\n    for i in 1:N\n        ops += Op(\"Exchange\", [i, mod1(i + 1, N)])\n        ops += Delta*Op(\"SzSz\", [i, mod1(i + 1, N)])\n    end\n\n    e0, gs = eig0(ops, block)# get GS with Lanczos  \n    vstate = vector(gs)\n    vne = zeros(Float64,(length(1:div(N,2)),2))\n    for Na in 1:div(N,2)\n        Nb = N - Na\n        blockA = Spinhalf(Na) # Spin1/2 Block full\n        blockB = Spinhalf(Nb) # Spin1/2 Block full\n        RDM = zeros(ComplexF64, (dim(blockA), dim(blockA)))\n        Create_RDM(RDM, vstate, block, blockA, blockB)\n        vne[Na,1] = Na\n        vne[Na,2] = getVnE(RDM)\n    end\n    filename = @sprintf(\"EE_XXX_model.Nsites.%d.Delta.%d.outfile.h5\", N,Delta)\n    h5open(filename, \"w\") do file\n        write(file, \"vne\", vne)\n    end \nend\n\nmain()\n</code></pre>"},{"location":"examples/entanglement_ground_state/#references","title":"references","text":"<p>[1] Laflorencie, Nicolas, Quantum entanglement in condensed matter systems, Physics Reports 646, 1-59 (2016)</p> <p>[2] Calabrese, Pasquale and Cardy, John, Entanglement entropy and conformal field theory, Journal of Physics A: Mathematical and Theoretical  42,50 (2009) </p>"},{"location":"examples/gs_kitaev/","title":"Spectrum of Kitaev-Heisenberg model on a honeycomb lattice","text":"<p>We consider the Kitaev-Heisenberg model on a honeycomb lattice [1]. The Hamiltonian is given by</p> \\[ \\mathcal{H} = -K\\sum_{\\langle i,j\\rangle \\parallel \\tilde{\\gamma}} \\boldsymbol{S}_i^\\gamma \\cdot \\boldsymbol{S}_j^\\gamma+J\\sum_{\\langle i,j\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>where \\(\\boldsymbol{S}_i\\) are spin \\(1/2\\) operators, \\(\\langle \\dots \\rangle\\) denotes sum over nearest and next-nearest neighbor sites, and in the first (Kitaev) term, when the nearest neighbor bonds are (anti)parallel to \\(\\tilde{\\gamma}=(0,1),(\\sqrt{3},-1)/2,(-\\sqrt{3},-1)/2\\), \\(\\gamma=x,y,z\\), respectively. This model hosts N\u00e9el, stripy, zigzag, and ferromagnetic magnetic orders as well as Kitaev spin liquid phase depending on the parameter regimes [2]. </p> <p>Here, we will show how to obtain the low energy spectrum of this model using XDiag. Due to translation and \\(C_2\\) rotation symmetry (note that this Hamiltonian does not possess \\(SU(2)\\) or \\(S_z\\) symmetry), the Hilbert space splits into different irreducible representation (irrep) sectors. We choose a system with \\(24\\) sites (\\(12\\) unit cells, such that all three \\(M\\) points and \\(K\\) and \\(K'\\) points are accessible), and converge the lowest-lying eigenvalues in each of the irrep sector at each momentum point. We plot the spectrum \\(K/J\\) in the figure below.</p> <p></p> <p>One can see in the figure above that there is a phase transition around \\(K/J\\approx1.5\\). For \\(K/J&lt; 1.3\\) the ground state is at \\(\\Gamma\\) point, whereas for \\(K/J&gt; 1.7\\), the ground states are at the \\(M\\) points. The state for \\(K/J&lt; 1.3\\) is the N\u00e9el state, which is supported by the fact there are tower of states [3] above the ground state. For \\(K/J&gt;1.7\\) the ground state has stripy order, which is why the ground state is at the \\(M\\) point. Note that this model is exactly solvable at \\(K/J=2\\) [2], with ground state having stripy antiferromagnetic order [1]. However, remarkably, this stripy order, despite being antiferromagnetic, does not possess tower of states; or in other words, this state is fluctuation free. This is because at \\(K/J=2\\), the model can be mapped to a Heisenberg model with ferromagnetic nearest neighbor coupling by rotating the spin operators in a particular way [1].</p> <p>The C++ script used to obtain the eigen spectra is given below</p> C++ <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nint main(int argc, char **argv) {\n  using namespace xdiag;\n  using namespace arma;\n  using fmt::format;\n\n  say_hello();\n\n  // Parse input arguments\n  assert(argc == 8);\n  int n_sites = atoi(argv[1]);              // number of sites\n  std::string kname = std::string(argv[2]); // momentum k\n  double J = atof(argv[3]);\n  double KX = atof(argv[4]);\n  double KY = atof(argv[5]);\n  double KZ = atof(argv[6]);\n  int seed = atoi(argv[7]);\n\n  Log(\"Diagonalizing H in block k: {}\", kname);\n\n  auto lfile = FileToml(format(\"kitaev.{}.toml\", n_sites));\n  std::string ofilename = format(\n      \"outfile.honeycomb.{}.J.{:.2f}.KX.{:.2f}.KY.{:.2f}.KZ.{:.2f}.k.{}.seed.{}.h5\",\n      n_sites, J, KX, KY, KZ, kname, seed);\n  auto ofile = FileH5(ofilename, \"w!\");\n\n  auto ops_read = read_opsum(lfile, \"Interactions\");\n  cx_mat sx(mat({{0., 0.5}, {0.5, 0.}}), mat({{0., 0.}, {0., 0.}}));\n  cx_mat sy(mat({{0., 0.}, {0., 0.}}), mat({{0., -0.5}, {0.5, 0.}}));\n  cx_mat sz(mat({{0.5, 0.0}, {0.0, -0.5}}), mat({{0., 0.}, {0., 0.0}}));\n\n  cx_mat sxsx = kron(sx, sx);\n  cx_mat sysy = kron(sy, sy);\n  cx_mat szsz = kron(sz, sz);\n  cx_mat gsx = kron(sy, sz) + kron(sz, sy);\n  cx_mat gsy = kron(sx, sz) + kron(sz, sx);\n  cx_mat gsz = kron(sx, sy) + kron(sy, sx);\n\n  auto ops = OpSum();\n  for (auto [cpl, op] : ops_read) {\n    std::string type = op.type();\n    auto sites = op.sites();\n    if (type == \"KITAEVX\") {\n      ops += KX * Op(\"Matrix\", sites, sxsx);\n    } else if (type == \"KITAEVY\") {\n      ops += KY * Op(\"Matrix\", sites, sysy);\n    } else if (type == \"KITAEVZ\") {\n      ops += KZ * Op(\"Matrix\", sites, szsz);\n    } else if (type == \"SdotS\") {\n      ops += J * Op(\"Matrix\", sites, sxsx);\n      ops += J * Op(\"Matrix\", sites, sysy);\n      ops += J * Op(\"Matrix\", sites, szsz);\n    }\n  }\n  auto irrep = read_representation(lfile, kname);\n\n  Log(\"Creating block ...\");\n  tic();\n  auto block = Spinhalf(n_sites, irrep);\n  toc();\n  Log(\"Dimension: {}\", block.size());\n\n  Log(\"Running Lanczos ...\");\n  tic();\n  int n_eig_to_converge = 2;\n  int max_iterations = 30;\n  auto tmat = eigvals_lanczos(ops, block, n_eig_to_converge, 1e-12,\n                              max_iterations, 1e-7, seed);\n  toc();\n\n  ofile[\"Alphas\"] = tmat.alphas;\n  ofile[\"Betas\"] = tmat.betas;\n  ofile[\"Eigenvalues\"] = tmat.eigenvalues;\n  ofile[\"Dimension\"] = block.size();\n\n  return EXIT_SUCCESS;\n}\n</code></pre> <p>The interactions terms and the symmetry representation inputs are given in the following TOML file:</p> toml <pre><code># This modelfile was created with the following properties:\n# Basis coordinates: (0.0, 1.1547005383792517), (0.0, 0.0)\n# Lattice vectors: a1=(1.0, 1.7320508075688776), a2=(2.0, 0.0)\n# Simulation torus vectors: t1=(6.0, 3.4641016151377553), t2=(-6.0, 3.4641016151377553)\n# Simulation torus matrix: ((2, 2), (2, -4))\n# Symmetry center: (1.0, 0.5773502691896258)\n# Lattice Point Group: D6\n# Lattice Space Group (infinite Lattice): D6\n# K points (K wedge marked with *):\n# [2.0943951023931957 0.0] *\n# [1.5707963267948968 0.9068996821171087] *\n# [1.5707963267948968 -0.9068996821171087] *\n# [1.0471975511965979 1.8137993642342174] *\n# [1.0471975511965979 0.0] *\n# [0.5235987755982989 0.9068996821171087] *\n# [0.5235987755982989 -0.9068996821171087] *\n# [0.0 1.8137993642342174] *\n# [0.0 0.0] *\n# [-0.5235987755982989 0.9068996821171087]\n# [-0.5235987755982989 -0.9068996821171087]\n# [-1.0471975511965979 0.0]\n# High Symmetry Points: K_0.C1, M_0.C2, M_1.C2, K_1.C1, X_0.C1, X_1.C1, X_2.C1, M_2.C2, Gamma.C2,\n# Eccentricity: --\n\nCoordinates = [\n  [0.0, 0.0],\n  [-3.0, 1.7320508075688776],\n  [1.0, 1.7320508075688776],\n  [-2.0, 3.4641016151377553],\n  [2.0, 3.4641016151377553],\n  [-1.0, 5.196152422706633],\n  [0.0, 1.1547005383792517],\n  [-3.0, 2.886751345948129],\n  [1.0, 2.886751345948129],\n  [-2.0, 4.618802153517007],\n  [2.0, 4.618802153517007],\n  [-1.0, 6.350852961085884],\n  [-1.0, 1.7320508075688776],\n  [3.0, 1.7320508075688776],\n  [-4.0, 3.4641016151377553],\n  [0.0, 3.4641016151377553],\n  [4.0, 3.4641016151377553],\n  [1.0, 5.196152422706633],\n  [-1.0, 2.886751345948129],\n  [3.0, 2.886751345948129],\n  [-4.0, 4.618802153517007],\n  [0.0, 4.618802153517007],\n  [4.0, 4.618802153517007],\n  [1.0, 6.350852961085884]\n]\n\nInteractions = [\n  ['J', 'SdotS', 6, 0],\n  ['J', 'SdotS', 8, 2],\n  ['J', 'SdotS', 19, 13],\n  ['J', 'SdotS', 7, 1],\n  ['J', 'SdotS', 18, 12],\n  ['J', 'SdotS', 10, 4],\n  ['J', 'SdotS', 22, 16],\n  ['J', 'SdotS', 20, 14],\n  ['J', 'SdotS', 9, 3],\n  ['J', 'SdotS', 21, 15],\n  ['J', 'SdotS', 11, 5],\n  ['J', 'SdotS', 23, 17],\n  ['J', 'SdotS', 6, 2],\n  ['J', 'SdotS', 8, 4],\n  ['J', 'SdotS', 19, 16],\n  ['J', 'SdotS', 7, 3],\n  ['J', 'SdotS', 18, 15],\n  ['J', 'SdotS', 10, 1],\n  ['J', 'SdotS', 22, 12],\n  ['J', 'SdotS', 20, 13],\n  ['J', 'SdotS', 9, 5],\n  ['J', 'SdotS', 21, 17],\n  ['J', 'SdotS', 11, 0],\n  ['J', 'SdotS', 23, 14],\n  ['J', 'SdotS', 6, 12],\n  ['J', 'SdotS', 8, 15],\n  ['J', 'SdotS', 19, 4],\n  ['J', 'SdotS', 7, 14],\n  ['J', 'SdotS', 18, 3],\n  ['J', 'SdotS', 10, 17],\n  ['J', 'SdotS', 22, 1],\n  ['J', 'SdotS', 20, 2],\n  ['J', 'SdotS', 9, 13],\n  ['J', 'SdotS', 21, 5],\n  ['J', 'SdotS', 11, 16],\n  ['J', 'SdotS', 23, 0],\n  ['KX', 'KITAEVX', 6, 0],\n  ['KX', 'KITAEVX', 8, 2],\n  ['KX', 'KITAEVX', 19, 13],\n  ['KX', 'KITAEVX', 7, 1],\n  ['KX', 'KITAEVX', 18, 12],\n  ['KX', 'KITAEVX', 10, 4],\n  ['KX', 'KITAEVX', 22, 16],\n  ['KX', 'KITAEVX', 20, 14],\n  ['KX', 'KITAEVX', 9, 3],\n  ['KX', 'KITAEVX', 21, 15],\n  ['KX', 'KITAEVX', 11, 5],\n  ['KX', 'KITAEVX', 23, 17],\n  ['KY', 'KITAEVY', 0, 23],\n  ['KY', 'KITAEVY', 2, 20],\n  ['KY', 'KITAEVY', 13, 9],\n  ['KY', 'KITAEVY', 1, 22],\n  ['KY', 'KITAEVY', 12, 6],\n  ['KY', 'KITAEVY', 4, 19],\n  ['KY', 'KITAEVY', 16, 11],\n  ['KY', 'KITAEVY', 14, 7],\n  ['KY', 'KITAEVY', 3, 18],\n  ['KY', 'KITAEVY', 15, 8],\n  ['KY', 'KITAEVY', 5, 21],\n  ['KY', 'KITAEVY', 17, 10],\n  ['KZ', 'KITAEVZ', 0, 11],\n  ['KZ', 'KITAEVZ', 2, 6],\n  ['KZ', 'KITAEVZ', 13, 20],\n  ['KZ', 'KITAEVZ', 1, 10],\n  ['KZ', 'KITAEVZ', 12, 22],\n  ['KZ', 'KITAEVZ', 4, 8],\n  ['KZ', 'KITAEVZ', 16, 19],\n  ['KZ', 'KITAEVZ', 14, 23],\n  ['KZ', 'KITAEVZ', 3, 7],\n  ['KZ', 'KITAEVZ', 15, 18],\n  ['KZ', 'KITAEVZ', 5, 9],\n  ['KZ', 'KITAEVZ', 17, 21]\n]\n\nSymmetries = [\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n  [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 14, 15, 12, 13, 17, 16, 20, 21, 18, 19, 23, 22],\n  [2, 3, 4, 5, 1, 0, 8, 9, 10, 11, 7, 6, 15, 16, 13, 17, 12, 14, 21, 22, 19, 23, 18, 20],\n  [3, 2, 5, 4, 0, 1, 9, 8, 11, 10, 6, 7, 13, 17, 15, 16, 14, 12, 19, 23, 21, 22, 20, 18],\n  [4, 5, 1, 0, 3, 2, 10, 11, 7, 6, 9, 8, 17, 12, 16, 14, 15, 13, 23, 18, 22, 20, 21, 19],\n  [5, 4, 0, 1, 2, 3, 11, 10, 6, 7, 8, 9, 16, 14, 17, 12, 13, 15, 22, 20, 23, 18, 19, 21],\n  [8, 9, 6, 7, 11, 10, 2, 3, 0, 1, 5, 4, 20, 22, 18, 23, 19, 21, 14, 16, 12, 17, 13, 15],\n  [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 21, 20, 19, 18, 23, 22, 15, 14, 13, 12, 17, 16],\n  [9, 8, 7, 6, 10, 11, 3, 2, 1, 0, 4, 5, 18, 23, 20, 22, 21, 19, 12, 17, 14, 16, 15, 13],\n  [10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1, 19, 18, 21, 20, 22, 23, 13, 12, 15, 14, 16, 17],\n  [6, 7, 11, 10, 9, 8, 0, 1, 5, 4, 3, 2, 23, 19, 22, 21, 20, 18, 17, 13, 16, 15, 14, 12],\n  [7, 6, 10, 11, 8, 9, 1, 0, 4, 5, 2, 3, 22, 21, 23, 19, 18, 20, 16, 15, 17, 13, 12, 14],\n  [12, 14, 15, 13, 17, 16, 18, 20, 21, 19, 23, 22, 3, 4, 2, 5, 1, 0, 9, 10, 8, 11, 7, 6],\n  [13, 15, 16, 17, 12, 14, 19, 21, 22, 23, 18, 20, 4, 0, 5, 1, 2, 3, 10, 6, 11, 7, 8, 9],\n  [14, 12, 13, 15, 16, 17, 20, 18, 19, 21, 22, 23, 2, 5, 3, 4, 0, 1, 8, 11, 9, 10, 6, 7],\n  [15, 13, 17, 16, 14, 12, 21, 19, 23, 22, 20, 18, 5, 1, 4, 0, 3, 2, 11, 7, 10, 6, 9, 8],\n  [16, 17, 12, 14, 15, 13, 22, 23, 18, 20, 21, 19, 1, 2, 0, 3, 4, 5, 7, 8, 6, 9, 10, 11],\n  [17, 16, 14, 12, 13, 15, 23, 22, 20, 18, 19, 21, 0, 3, 1, 2, 5, 4, 6, 9, 7, 8, 11, 10],\n  [20, 18, 23, 22, 21, 19, 14, 12, 17, 16, 15, 13, 7, 11, 6, 10, 9, 8, 1, 5, 0, 4, 3, 2],\n  [18, 20, 22, 23, 19, 21, 12, 14, 16, 17, 13, 15, 6, 10, 7, 11, 8, 9, 0, 4, 1, 5, 2, 3],\n  [19, 21, 20, 18, 23, 22, 13, 15, 14, 12, 17, 16, 9, 6, 8, 7, 11, 10, 3, 0, 2, 1, 5, 4],\n  [21, 19, 18, 20, 22, 23, 15, 13, 12, 14, 16, 17, 8, 7, 9, 6, 10, 11, 2, 1, 3, 0, 4, 5],\n  [22, 23, 19, 21, 20, 18, 16, 17, 13, 15, 14, 12, 11, 8, 10, 9, 6, 7, 5, 2, 4, 3, 0, 1],\n  [23, 22, 21, 19, 18, 20, 17, 16, 15, 13, 12, 14, 10, 9, 11, 8, 7, 6, 4, 3, 5, 2, 1, 0]\n]\n\n# Irreducible representations\n[Gamma.C2.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C2.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[K0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000006],\n  [-0.5000000000000002, 0.8660254037844385],\n  [-0.4999999999999996, 0.8660254037844388],\n  [-0.4999999999999996, -0.8660254037844388],\n  [-0.5000000000000002, -0.8660254037844385],\n  [-0.5000000000000002, -0.8660254037844385],\n  [1.0000000000000000, 0.0000000000000006],\n  [-0.5000000000000008, -0.8660254037844383],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.5000000000000008, 0.8660254037844383],\n  [-0.5000000000000002, 0.8660254037844385]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17]\nmomentum = [2.0943951023931957, 0.0000000000000000]\n\n[K1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000004],\n  [-0.4999999999999996, -0.8660254037844388],\n  [-0.5000000000000004, -0.8660254037844384],\n  [-0.5000000000000008, 0.8660254037844383],\n  [-0.4999999999999992, 0.8660254037844392],\n  [-0.4999999999999998, 0.8660254037844387],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.4999999999999994, 0.8660254037844389],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.4999999999999998, -0.8660254037844387],\n  [-0.4999999999999998, -0.8660254037844387]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17]\nmomentum = [1.0471975511965979, 1.8137993642342174]\n\n[M0.C2.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000008],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000008],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000008],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000008],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [1.5707963267948968, 0.9068996821171087]\n\n[M0.C2.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000008],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000008],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000008],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000008],\n  [1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000001]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [1.5707963267948968, 0.9068996821171087]\n\n[M1.C2.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000008],\n  [-1.0000000000000000, -0.0000000000000004],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000008],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000008],\n  [-1.0000000000000000, -0.0000000000000004],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000008],\n  [-1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, 0.0000000000000002]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [1.5707963267948968, -0.9068996821171087]\n\n[M1.C2.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, 0.0000000000000008],\n  [1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, 0.0000000000000008],\n  [1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000008],\n  [-1.0000000000000000, -0.0000000000000004],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, -0.0000000000000008],\n  [-1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, -0.0000000000000004],\n  [-1.0000000000000000, -0.0000000000000002]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [1.5707963267948968, -0.9068996821171087]\n\n[M2.C2.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [0.0000000000000000, 1.8137993642342174]\n\n[M2.C2.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000004]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\nmomentum = [0.0000000000000000, 1.8137993642342174]\n\n[X0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000003],\n  [0.4999999999999999, 0.8660254037844387],\n  [-0.5000000000000002, -0.8660254037844385],\n  [-0.5000000000000002, 0.8660254037844385],\n  [0.4999999999999999, -0.8660254037844387],\n  [0.4999999999999999, -0.8660254037844387],\n  [-1.0000000000000000, -0.0000000000000003],\n  [-0.4999999999999996, 0.8660254037844388],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.4999999999999996, -0.8660254037844388],\n  [0.4999999999999999, 0.8660254037844387]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17]\nmomentum = [1.0471975511965979, 0.0000000000000000]\n\n[X1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.5000000000000002, 0.8660254037844385],\n  [-0.4999999999999998, 0.8660254037844387],\n  [-0.4999999999999996, -0.8660254037844388],\n  [-0.5000000000000004, -0.8660254037844384],\n  [0.5000000000000001, 0.8660254037844386],\n  [-1.0000000000000000, 0.0000000000000001],\n  [0.5000000000000003, 0.8660254037844385],\n  [-1.0000000000000000, 0.0000000000000001],\n  [0.5000000000000001, -0.8660254037844386],\n  [0.5000000000000001, -0.8660254037844386]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17]\nmomentum = [0.5235987755982989, 0.9068996821171087]\n\n[X2.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, -0.0000000000000001],\n  [0.5000000000000001, -0.8660254037844386],\n  [-0.4999999999999996, 0.8660254037844388],\n  [-0.4999999999999998, -0.8660254037844387],\n  [0.5000000000000001, 0.8660254037844386],\n  [-0.5000000000000002, -0.8660254037844385],\n  [1.0000000000000000, 0.0000000000000002],\n  [0.5000000000000001, 0.8660254037844386],\n  [-1.0000000000000000, -0.0000000000000001],\n  [0.5000000000000003, -0.8660254037844385],\n  [-0.5000000000000004, 0.8660254037844384]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17]\nmomentum = [0.5235987755982989, -0.9068996821171087]\n</code></pre> <p>To run the above C++ code with the toml file, one needs to execute the following command </p> <p><pre><code>./build/main n_sites kname J KX KY KZ seed\n</code></pre> where the n_sites, kname, J, KX, KY, KZ and seed are to be replaced by their values such as 24, Gamma.C2.A, 1.00, -1.00, -1.00, -1.00, 1, respectively. (Note that the code implements the possiblity of anisotropic Kitaev couplings with KX, KY and KZ taking different values. Furthermore, in the expression of the Hamiltonian above, we wrote the Kitaev term as ferromagnetic, but in the code it is implemented as antiferromagnetic, hence one needs to input negative values of KX, KY and KZ to obtain the results shown in the figure above.) The Julia code below was used to generate the plot above from the data obtaining running the above code.</p> <p>Plotting Script</p> Julia <pre><code>using LinearAlgebra\nusing Plots\nusing Combinatorics\n# using BenchmarkTools\nusing Kronecker\nusing LaTeXStrings\nusing Arpack\n# using KernelDensity\nusing Interpolations\nusing SparseArrays\n# using ArnoldiMethod\nusing KrylovKit\nusing JLD2\nusing HDF5\nusing Printf\nplot_font = \"Computer Modern\"\ndefault(\n    fontfamily=plot_font,\n    linewidth=2, \n    framestyle=:box, \n    # xtickfont=font(18),\n    label=nothing,\n    left_margin=8Plots.mm,\n    bottom_margin=2Plots.mm\n    # ytickfont=font(18),\n    # legendfont=font(18)\n)\ncolors = palette(:default)#palette(:thermal,length(14:div(n_sites,2))+1)\nmarkers = filter((m-&gt;begin\n                m in Plots.supported_markers()\n            end), Plots._shape_keys)\n\n\nn_sites=24\nn_seeds = 2\nks=[\"Gamma.C2.A\", \"Gamma.C2.B\", \"M0.C2.A\", \"M0.C2.B\", \"M1.C2.A\", \"M1.C2.B\", \"M2.C2.A\", \"M2.C2.B\", \"K0.C1.A\", \"K1.C1.A\", \"X0.C1.A\", \"X1.C1.A\", \"X2.C1.A\"]\nksl=[\"\u0393.C2.A\", \"\u0393.C2.B\", \"M0.C2.A\", \"M0.C2.B\", \"M1.C2.A\", \"M1.C2.B\", \"M2.C2.A\", \"M2.C2.B\", \"K0.C1.A\", \"K1.C1.A\", \"X0.C1.A\", \"X1.C1.A\", \"X2.C1.A\"]\nseeds = [i for i=2:n_seeds]\nKs = [i/10. for i=-40:0]\n\nJ=1.00\n\nfor seed in seeds\n    plot(xlabel=L\"K/J\",ylabel=L\"E/J\",ylims=(-0.02,2.0),xlims=(-0.02,5.0),xticks=(0.0:0.4:4,[@sprintf(\"%.2f\",i) for i=0.0:0.4:4]),dpi=400)\n    for K=Ks\n        mineig = 100.\n        for k in ks\n            f = h5open(@sprintf(\"outfiles/seed.%d/outfile.honeycomb.%d.J.%.2f.KX.%.2f.KY.%.2f.KZ.%.2f.k.%s.seed.%d.h5\",seed,n_sites,J,K,K,K,k,seed), \"r\")\n            eigs =read(f[\"Eigenvalues\"])\n            if mineig&gt;eigs[1]\n                mineig = eigs[1]\n            end\n        end\n        c=0\n        for k in ks\n            c=c+1\n            f = h5open(@sprintf(\"outfiles/seed.%d/outfile.honeycomb.%d.J.%.2f.KX.%.2f.KY.%.2f.KZ.%.2f.k.%s.seed.%d.h5\",seed,n_sites,J,K,K,K,k,seed), \"r\")#,J,K,K,K\n            eig = read(f[\"Eigenvalues\"]).-mineig\n            KK=abs(K)*[1 for i=1:length(eig)]\n            if K==Ks[1]\n                plot!(KK,eig,seriestype=:scatter,m=markers[c],mc=colors[c],label=ksl[c])\n            else\n                plot!(KK,eig,seriestype=:scatter,m=markers[c],mc=colors[c],primary=false)\n            end\n            close(f)\n        end\n    end\n    savefig(@sprintf(\"outfile.kitaev.%d.seed.%d-n.png\",n_sites,seed))\nend\n</code></pre>"},{"location":"examples/gs_kitaev/#references","title":"References","text":"<p>[1] Chaloupka, J., Jackeli, G., &amp; Khaliullin, G. (2010). Kitaev-Heisenberg Model on a Honeycomb Lattice: Possible Exotic Phases in Iridium Oxides \\(\\text{A}_2\\text{IrO}_3\\). Phys. Rev. Lett., 105(2), 027204.</p> <p>[2] Gotfryd, D., Rusna\u010dko, J., Wohlfeld, K., Jackeli, G., Chaloupka, J., &amp; Ole\u015b, A. M. (2017). Phase diagram and spin correlations of the Kitaev-Heisenberg model: Importance of quantum effects. Physical Review B, 95(2), 024426.</p> <p>[3] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p>"},{"location":"examples/hello_world/","title":"Hello world!","text":"JuliaC++ <pre><code>   using XDiag\n   say_hello()\n</code></pre> <pre><code>   #include &lt;xdiag/all.hpp&gt;\n\n   using namespace xdiag;\n\n   int main() try {\n     say_hello();\n   } catch (Error e) {\n     error_trace(e);\n   }\n</code></pre>"},{"location":"examples/hubbard_greens_f/","title":"Hubbard model Green's function","text":"<p>Author Martin Ulaga</p> <p>Uses the Lanczos algorithm[1] to calculate the Green's function of the Hubbard model. See also the documentation page for the spin structure factor. The Green's function is given by</p> \\[     G({\\bf k}, \\omega)=-i\\int dt e^{-i\\omega t}\\langle \\lbrace c_{\\bf k}(t),c^{\\dagger}_{\\bf k}\\rbrace\\rangle. \\] <p>To achieve a mesh of momentum space, we can use either use the generated momenta inside the Wigner-Seitz cell allowed by the finite cluster or twisted boundary conditions[2][3], where the lattice \\({\\bf k}\\)-point is shifted to \\({\\bf k + \\boldsymbol{\\theta}}\\) by introducing a flux via Peierls substitution in the Hamiltonian, \\(t_{ij} \\rightarrow t_{ij}\\exp(i{\\bf \\boldsymbol{\\theta}\\cdot r}_{ij})\\). For this example, we're calculating the spectral function along the cut \\(\\Gamma\\)-\\(M\\), i.e., the diagonal of the reciprocal lattice unit cell. There is no guarantee that the recovered spectral function is indicative of properties of the infinite system (but can be ``closer'' in the sense that any reasonable interpolation between the \\(k\\)-points of the finite cluster is an improvement).</p> <p></p>"},{"location":"examples/hubbard_greens_f/#example-code","title":"Example code","text":"JuliaC++ <pre><code>    using XDiag\n    using HDF5\n\n    function main()\n      say_hello()\n\n      # IO\n      latticeInput = \"../../misc/data/square.8.hubbard.ttprime.toml\"\n      lfile = FileToml(latticeInput)\n\n      filename = \"../../misc/data/examples_output/hubbard_greens_f.h5\"\n      outfile = h5open(filename, \"w\")\n\n      # Define the Hubbard model\n      N = 8\n      nup = 4\n      ndn = 4\n      ops = read_opsum(lfile, \"Interactions\")\n      # ops = OpSum()\n      # for i in 1:N\n      #   ops += \"Tx\" * Op(\"Hop\", [i, mod(i+1,N)])\n      # end\n      t = 1.0\n      tp = 0.0\n      ops[\"Ty\"] = t\n      ops[\"Tx\"] = t\n      ops[\"Tprime+\"] = tp\n      ops[\"Tprime-\"] = tp\n      ops += \"U\" * Op(\"HubbardU\")\n      ops[\"U\"] = 1.5\n      @show(ops)\n      opsTBC = ops\n\n      irrep = read_representation(lfile, \"Gamma.C1.A\")\n\n      # compute groundstate (known to be at k=0)\n      println(\"Computing ground state ...\")\n      block = Electron(N, nup, ndn, irrep)\n      e0, gs = eig0(ops, block)\n      make_complex!(gs)\n      println(\"done.\")\n      println(\"Ground state energy: $e0\")\n      outfile[\"e0\"] = e0\n\n      function tbc_mesh(kx, ky)\n        # compare to twisted boundary condition calculation,\n        # cf. Zemljic &amp; Prelovsek, PRB 75, 104514 (2007)\n        # Tohyama, PRB 70, 174517 (2004).\n        println(\"\\n considering TBC momentum [$kx,$ky]\")\n        @show opsTBC[\"Tx\"] = t * exp(1im * (kx+ky) / 4.)\n        @show opsTBC[\"Ty\"] = t * exp(1im * (kx-ky) / 4.)\n        opsTBC[\"Tprime+\"] =\n          tp * exp(1im * (kx + ky)) # r_ij = (1,1)\n        opsTBC[\"Tprime-\"] =\n          tp * exp(1im * (kx - ky)) # r_ij = (1,-1)\n\n        e0, gs_tbc = eig0(opsTBC, block)\n        @show e0\n        c_q_tbc = symmetrize(sqrt(N) * Op(\"Cup\", 1), irrep)\n        Av = apply(c_q_tbc, gs_tbc)\n        @show nrm = norm(Av)\n        Av /= nrm\n\n        res_tbc = eigvals_lanczos_inplace(opsTBC, Av)\n        @show res_tbc.eigenvalues[1]\n\n        # cdag_q_tbc = hc(c_q_tbc)\n        cdag_q_tbc = symmetrize(sqrt(N) * Op(\"Cdagup\", 1), irrep)\n\n        Av = apply(cdag_q_tbc, gs_tbc)\n        @show nrm2 = norm(Av)\n        Av /= nrm2\n\n        res_tbc2 = eigvals_lanczos_inplace(opsTBC, Av)\n        @show res_tbc2.eigenvalues[1]\n\n        return nrm, res_tbc, nrm2, res_tbc2\n      end\n\n      # loop through momenta\n      irreps = Dict{String,Vector{Float64}}(\n        \"Gamma.C1.A\" =&gt; [0.0, 0.0],\n        \"M.C1.A\" =&gt; [3.1415926535897931, 3.1415926535897931],\n        \"Sigma0.C1.A\" =&gt; [1.5707963267948966, 1.5707963267948966],\n        \"Sigma1.C1.A\" =&gt; [1.5707963267948966, -1.5707963267948966],\n        \"Sigma2.C1.A\" =&gt; [-1.5707963267948966, 1.5707963267948966],\n        \"Sigma3.C1.A\" =&gt; [-1.5707963267948966, -1.5707963267948966],\n        \"X0.C1.A\" =&gt; [3.1415926535897931, 0.0000000000000000],\n        \"X1.C1.A\" =&gt; [0.0000000000000000, 3.1415926535897931])\n      for (name, momentum) in irreps\n        println(\"\\n considering irrep $name, momentum $momentum\")\n        aq_irrep = read_representation(lfile, name)\n        c_q = symmetrize(sqrt(N) * Op(\"Cup\", 1), aq_irrep)\n        Av = apply(c_q, gs)\n        @show nrm = norm(Av)\n        Av /= nrm\n\n        res = eigvals_lanczos_inplace(ops, Av)\n        @show res.eigenvalues[1]\n        outfile[\"$name/irrep/norm\"] = nrm\n        outfile[\"$name/irrep/alphas\"] = res.alphas\n        outfile[\"$name/irrep/betas\"] = res.betas\n        @show outfile[\"$name/irrep/eigs\"] = res.eigenvalues\n\n        nrm, res, _, _ = tbc_mesh(momentum[1], momentum[2])\n        outfile[\"$name/tbc/norm\"] = nrm\n        outfile[\"$name/tbc/alphas\"] = res.alphas\n        outfile[\"$name/tbc/betas\"] = res.betas\n        @show outfile[\"$name/tbc/eigs\"] = res.eigenvalues\n\n      end\n\n      for (k, kx) in enumerate(0:pi/50:pi)\n        nrm, res_tbc, nrm2, res_tbc2 = tbc_mesh(kx, kx)\n\n        ik = \"$(k-1)\" # mimics c++ output\n        outfile[\"$ik/$ik/cdagc/norm\"] = nrm\n        outfile[\"$ik/$ik/cdagc/alphas\"] = res_tbc.alphas\n        outfile[\"$ik/$ik/cdagc/betas\"] = res_tbc.betas\n        outfile[\"$ik/$ik/cdagc/eigs\"] = res_tbc.eigenvalues\n        outfile[\"$ik/$ik/ccdag/norm\"] = nrm2\n        outfile[\"$ik/$ik/ccdag/alphas\"] = res_tbc2.alphas\n        outfile[\"$ik/$ik/ccdag/betas\"] = res_tbc2.betas\n        outfile[\"$ik/$ik/ccdag/eigs\"] = res_tbc2.eigenvalues\n        outfile[\"$ik/$ik/kx\"] = kx\n        outfile[\"$ik/$ik/ky\"] = kx\n      end\n    end\n\n    main()\n</code></pre> <pre><code>    #include &lt;xdiag/all.hpp&gt;\n\n    using namespace xdiag;\n    using namespace arma;\n    using fmt::format;\n    using namespace std::complex_literals;\n\n    int main() try {\n      say_hello();\n\n      // IO\n      std::string latticeInput =\n          XDIAG_DIRECTORY \"/misc/data/square.8.hubbard.ttprime.toml\";\n          // XDIAG_DIRECTORY \"/misc/data/square.16.tJ.toml\";\n      auto lfile = FileToml(latticeInput);\n\n      std::string filename =\n          XDIAG_DIRECTORY \"/misc/data/examples_output/hubbard_greens_f.h5\";\n      auto outfile = FileH5(filename, \"w!\");\n\n      // Define the Hubabrd model\n      int N = 8;\n      int nup = 4;\n      int ndn = 4;\n      auto ops = read_opsum(lfile, \"Interactions\");\n      auto t = 1.;\n      auto tp = 0.;\n      ops[\"Ty\"] = t;\n      ops[\"Tx\"] = t;\n      ops[\"Tprime+\"] = tp;\n      ops[\"Tprime-\"] = tp;\n      ops += \"U\" * Op(\"HubbardU\");\n      ops[\"U\"] = 1.5;\n      auto opsTBC = ops;\n\n      auto irrep = read_representation(lfile, \"Gamma.C1.A\");\n\n      // compute groundstate (known to be at k=0)\n      Log(\"Computing ground state ...\");\n      auto block = Electron(N, nup, ndn, irrep);\n      auto [e0, gs] = eig0(ops, block, 1e-14, 100);\n      gs.make_complex();\n      Log(\"Ground state energy: {:.12f}\", e0);\n      outfile[\"e0\"] = e0;\n\n      auto tbc_mesh =\n          [&amp;opsTBC, &amp;t, &amp;tp, &amp;block, &amp;N,\n           &amp;irrep](double const &amp;kx,\n                   double const &amp;ky) -&gt; std::tuple&lt;double, EigvalsLanczosResult, double, EigvalsLanczosResult&gt; {\n        // lambda to perform TBC calc.\n        // compare to twisted boundary condition calculation,\n        // cf. Zemljic &amp; Prelovsek, PRB 75, 104514 (2007);\n        // Tohyama, PRB 70, 174517 (2004).\n        Log(\"TBC calculation, momentum [{}, {}]\", kx, ky);\n        opsTBC[\"Tx\"] = t * exp(1i * (kx+ky) / 4.);\n        opsTBC[\"Ty\"] = t * exp(1i * (kx-ky) / 4.);\n        opsTBC[\"Tprime+\"] = tp * exp(1i * (kx + ky)); // r_ij = (1,1)\n        opsTBC[\"Tprime-\"] = tp * exp(1i * (kx - ky)); // r_ij = (1,-1)\n        // XDIAG_SHOW(opsTBC);\n        auto [e0_tbc, gs_tbc] = eig0(opsTBC, block, 1e-14, 100);\n        XDIAG_SHOW(e0_tbc);\n        auto c_q_tbc = symmetrize(sqrt((double)N) * Op(\"Cup\", 0), irrep);\n        auto Av = apply(c_q_tbc, gs_tbc);\n        auto nrm = norm(Av);\n        XDIAG_SHOW(nrm);\n        Av /= nrm;\n\n        auto res_tbc = eigvals_lanczos_inplace(opsTBC, Av, 1, 0., 10);\n        XDIAG_SHOW(res_tbc.eigenvalues);\n        Log(\"n iterations {}\", res_tbc.niterations);\n\n        auto cdag_q_tbc = symmetrize(sqrt((double)N) * Op(\"Cdagup\", 0), irrep);\n        Av = apply(cdag_q_tbc, gs_tbc);\n        auto nrm2 = norm(Av);\n        XDIAG_SHOW(nrm2);\n        Av /= nrm2;\n\n        auto res_tbc2 = eigvals_lanczos_inplace(opsTBC, Av, 1, 0., 10);\n        XDIAG_SHOW(res_tbc2.eigenvalues);\n        Log(\"n iterations {}\", res_tbc.niterations);\n        return {nrm, res_tbc, nrm2, res_tbc2};\n      };\n\n      // loop through momenta of the cluster reciprocal lattice\n      std::vector&lt;std::pair&lt;std::string, arma::vec&gt;&gt; irreps = {\n          {\"Gamma.C1.A\", {0., 0.}},\n          {\"M.C1.A\", {3.1415926535897931, 3.1415926535897931}},\n          {\"Sigma0.C1.A\", {1.5707963267948966, 1.5707963267948966}},\n          {\"Sigma1.C1.A\", {1.5707963267948966, -1.5707963267948966}},\n          {\"Sigma2.C1.A\", {-1.5707963267948966, 1.5707963267948966}},\n          {\"Sigma3.C1.A\", {-1.5707963267948966, -1.5707963267948966}},\n          {\"X0.C1.A\", {3.1415926535897931, 0.0000000000000000}},\n          {\"X1.C1.A\", {0.0000000000000000, 3.1415926535897931}}};\n      for (const auto &amp;[name, momentum] : irreps) {\n        Log(\"considering irrep {}, momentum [{}, {}]\", name, momentum(0),\n            momentum(1));\n        auto aq_irrep = read_representation(lfile, name);\n        auto c_q = symmetrize(sqrt((double)N) * Op(\"Cup\", 0),\n                              aq_irrep); // normalize to 1/sqrt(N)\n        auto c_dag_q = symmetrize(sqrt((double)N) * Op(\"Cdagup\", 0),\n                              aq_irrep); // normalize to 1/sqrt(N)\n        Log(\"cdagc\");\n        auto Av = apply(c_q, gs);\n        auto nrm = norm(Av);\n        Av /= nrm;\n        XDIAG_SHOW(nrm);\n\n        auto res = eigvals_lanczos_inplace(ops, Av, 1, 0., 10);\n        XDIAG_SHOW(res.eigenvalues);\n        outfile[format(\"{}/irrep/norm\", name)] = nrm;\n        outfile[format(\"{}/irrep/alphas\", name)] = res.alphas;\n        outfile[format(\"{}/irrep/betas\", name)] = res.betas;\n        outfile[format(\"{}irrep/eigs\", name)] = res.eigenvalues;\n\n        Log(\"ccdag\");\n        Av = apply(c_dag_q, gs);\n        nrm = norm(Av);\n        Av /= nrm;\n        XDIAG_SHOW(nrm);\n\n        res = eigvals_lanczos_inplace(ops, Av, 1, 0., 10);\n        XDIAG_SHOW(res.eigenvalues);\n\n        // compare to tbc calc\n        auto [nrm_tbc, res_tbc, nrm_tbc2, res_tbc2] = tbc_mesh(momentum(0), momentum(1));\n        // XDIAG_SHOW(nrm_tbc);\n        // XDIAG_SHOW(res_tbc.eigenvalues(0));\n\n      }\n\n      // TBC mesh, 10x10 grid\n      int nkx = 51;\n      int nky = nkx;\n      auto momentum = [&amp;nkx, &amp;nky](int const &amp;ikx,\n                                   int const &amp;iky) -&gt; std::pair&lt;double, double&gt; {\n        return {(double)ikx * 3.1415926535897931 / (double)(nkx - 1),\n                (double)iky * 3.1415926535897931 / (double)(nky - 1)};\n      };\n      for (int ikx = 0; ikx &lt; nkx; ++ikx) {\n        auto iky = ikx;\n        // for (int iky = 0; iky &lt; nky; ++iky) {\n        auto [kx, ky] = momentum(ikx, ikx);\n        auto [nrm, res, nrm2, res2] = tbc_mesh(kx, ky);\n        XDIAG_SHOW(nrm);\n        XDIAG_SHOW(res.eigenvalues(0));\n\n        outfile[format(\"{}/{}/cdagc/norm\", ikx, iky)] = nrm;\n        outfile[format(\"{}/{}/cdagc/alphas\", ikx, iky)] = res.alphas;\n        outfile[format(\"{}/{}/cdagc/betas\", ikx, iky)] = res.betas;\n        outfile[format(\"{}/{}/cdagc/eigs\", ikx, iky)] = res.eigenvalues;\n        outfile[format(\"{}/{}/ccdag/norm\", ikx, iky)] = nrm2;\n        outfile[format(\"{}/{}/ccdag/alphas\", ikx, iky)] = res2.alphas;\n        outfile[format(\"{}/{}/ccdag/betas\", ikx, iky)] = res2.betas;\n        outfile[format(\"{}/{}/ccdag/eigs\", ikx, iky)] = res2.eigenvalues;\n        outfile[format(\"{}/{}/kx\", ikx, iky)] = kx;\n        outfile[format(\"{}/{}/ky\", ikx, iky)] = ky;\n        // }\n      }\n\n    } catch (Error e) {\n      error_trace(e);\n    }\n</code></pre>"},{"location":"examples/hubbard_greens_f/#references","title":"References","text":"<p>[1]  Prelov\u0161ek, P., &amp; Bon\u010da, J. (2013). Ground state and finite temperature Lanczos methods. Strongly Correlated Systems: Numerical Methods, 1-30.</p> <p>[2] Tohyama, T. (2004). Asymmetry of the electronic states in hole-and electron-doped cuprates: Exact diagonalization study of the \\(t-t\u2032-t \u2033-J\\) model. Phys. Rev. B, 70(17), 174517</p> <p>[3] Poilblanc, D. (1991). Twisted boundary conditions in cluster calculations of the optical conductivity in two-dimensional lattice models. Physical Review B, 44(17), 9562.</p>"},{"location":"examples/mbl/","title":"Level statistics in many-body localized systems","text":"<p>Author Hannes Karlsson</p> <p>The Hamiltonian for the Ising model with an applied magnetic field in \\(z\\)-direction $$     H = -J\\sum_i \\sigma^z_i \\sigma^z_{i+1} - h\\sum_i \\sigma_i^z $$ commutes with all operators \\(\\sigma_i^z\\), which constitutes an extensive set of conserved quantitues, and so the system is integrable. If one however adds a magnetic field in the \\(x\\)-direction $$     H = -J\\sum_i \\sigma^z_i \\sigma^z_{i+1} - \\sum_i (h\\sigma_i^z + \\gamma\\sigma_i^x), $$ the model becomes ergodic. It is thus expected to follow the predictions of random matrix theory and the eigenstate thermalization hypothesis. Consider now the same Hamiltonian but with random interaction and field strengths. $$     H = \\sum_i J_i \\sigma^z_i \\sigma^z_{i+1} - \\sum_i (h_i\\sigma_i^z + \\gamma_i\\sigma_i^x), $$ where, for the sake of concreteness, we take \\(J_i\\in [0.8,1.2]\\), \\(h_i\\in [-W,W]\\), \\(\\gamma_i=1\\), and \\(W\\) is the disorder strength. This model is known to display many-body localisation for large enough \\(W\\), i.e, it hosts an extensive set of emergent (local) conserved quantities, often called l-bits. To study this, we compute the inverse participation ration, IPR\\(=\\sum_i |\\psi_i|^4\\), most often used to study Anderson localisation, for some of the low lying eigenstates. In a perfectly localised state, one would expect IPR\\(=1\\), while for a perfecly delocalised state, IPR\\(=1/N\\) with \\(N\\) being the number of basis states. IPR is however not a perfect measure of localisation for an interacting system, so we will also consider the level spacing ratio, \\(r=min(\\delta_n,\\delta_{n+1})/max(\\delta_n,\\delta_{n+1})\\), where \\(\\delta_n=E_{n+1}-E_n\\). For an ergodic phase, we would observe a Gaussian (or Wigner-Dyson) distribution of the eigenvalues, with \\(\\langle r \\rangle \\approx 0.530\\), while in the MBL phase (or regime), we would observe a Poisson distribution, with \\(\\langle r \\rangle \\approx 0.386\\).</p> <p></p> <p>As we can see in the figure above, with \\(L=10\\) spins, the IPR is growing with the disorder \\(W\\), for all the observed eigenstates. We also see that the level spacing ratio goes from close to the value of a Poisson distribution for \\(W=0\\), then goes up to the value of the Gaussian distribution, where it reaches it maximal ergodicity, before going down again to a Gaussian distribution when the l-bits are formed.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\ndouble level_spacing_ratio(arma::vec eigs) {\n  arma::vec diff = arma::vec(eigs.size() - 1);\n  for (int i = 0; i &lt; eigs.size() - 1; i++) {\n    diff[i] = eigs[i + 1] - eigs[i];\n  }\n  arma::vec r = arma::vec(diff.size() - 1);\n  for (int i = 0; i &lt; diff.size() - 1; i++) {\n    r[i] = std::min(diff[i], diff[i + 1]) / std::max(diff[i], diff[i + 1]);\n  }\n  return arma::sum(r) / r.size();\n}\n\ndouble ipr_func(arma::vec state) {\n  return arma::sum(arma::pow(arma::abs(state), 4));\n}\n\nint main() {\n  int L = 10;\n  int nres = 2;\n  int neigs = 4;\n  arma::vec Ws = arma::linspace(0, 5, 100);\n  arma::mat rs = arma::mat(nres, Ws.size());\n  arma::cube iprs = arma::cube(nres, neigs, Ws.size());\n\n  for (int i = 0; i &lt; nres; i++) {\n    arma::vec J = arma::randu(L - 1, arma::distr_param(0.8, 1.2));\n    for (int j = 0; j &lt; Ws.size(); j++) {\n      arma::vec h = arma::randu(L, arma::distr_param(-Ws(j), Ws(j)));\n      // construct Hamiltonian and Hilbert space\n      auto block = Spinhalf(L);\n      auto ops = OpSum();\n      for (int l = 0; l &lt; L - 1; l++) {\n        ops += J(l) * Op(\"SzSz\", {l, l + 1});\n      }\n      for (int l = 0; l &lt; L; l++) {\n        ops += h(l) * Op(\"Sz\", l);\n        ops += 0.5 * Op(\"S+\", l);\n        ops += 0.5 * Op(\"S-\", l);\n      }\n\n      arma::mat H = matrix(ops, block);\n      arma::mat eigvecs;\n      arma::vec eigvals;\n      arma::eig_sym(eigvals, eigvecs, H);\n\n      rs(i, j) = level_spacing_ratio(eigvals);\n\n      for (int k = 0; k &lt; neigs; k++) {\n        arma::vec eigvec = eigvecs.col(k);\n        iprs(i, j, k) = ipr_func(eigvec);\n      }\n    }\n  }\n\n  arma::vec r = arma::sum(rs, 0);\n  arma::mat ipr = arma::sum(iprs, 0);\n\n  // save and plot\n\n  return 0;\n}\n</code></pre> <pre><code>using XDiag\nusing CairoMakie\nusing LinearAlgebra\nusing Statistics\n\nfunction diagonalise(L,W,J,h)\n\n    # construct Hilbert space\n    hspace = Spinhalf(L)\n\n    # construct Hamiltonian\n    ops = OpSum()\n\n    for i in 1:L-1\n        ops += J[i] * Op(\"SzSz\",[i,i+1])\n    end\n\n    for i in 1:L\n        ops += h[i] * Op(\"Sz\",i)\n        ops += 0.5 * Op(\"S+\",i)\n        ops += 0.5 * Op(\"S-\",i)\n    end\n\n    # Lanczos\n    # res = eigs_lanczos(ops,hspace)\n    H = matrix(ops, hspace)\n    eig = eigen(Hermitian(H))\n\n    return eig.values, eig.vectors\n\nend\n\nfunction level_spacing_ratio(eigs)\n\n    diff = []\n    for i in 1:length(eigs)-1\n        push!(diff,eigs[i+1] - eigs[i])\n    end\n\n    r = []\n    for i in 1:length(diff)-1\n        push!(r,min(diff[i],diff[i+1])/max(diff[i],diff[i+1]))\n    end\n\n    return mean(r)\n\nend\n\nfunction ipr_func(state)\n\n    ipr = 0\n    for i in 1:length(state)\n        ipr += abs(state[i])^4\n    end\n\n    return ipr\n\nend\n\nfunction main()\n    # set model parameters\n    L = 10\n    Ws = range(0,step=0.05,length=100)\n    nres = 20\n    rs = Array{Float64}(undef,nres,length(Ws))\n    f = Figure()\n\n    neigs = 4   # number of low lying eigenstates to check IPR for\n    iprs = zeros(nres,neigs,length(Ws))\n\n    for ii in 1:nres\n        J = (rand(Float64,L-1) .* 0.4) .+ 0.8   # J between 0.8 and 1.2\n\n        for (jj,W) in enumerate(Ws)\n            println(\"Now computing W=$W\")\n            h = (rand(Float64,L) .* 2*W) .- W   # h between -W and W\n\n            evals, evecs = diagonalise(L,W,J,h)\n            rs[ii,jj] = level_spacing_ratio(evals)\n\n            for k in 1:neigs\n                evec = evecs[:,k]\n                iprs[ii,k,jj] = ipr_func(evec)\n            end\n\n        end\n\n    end\n\n    r = dropdims(mean(rs,dims=1),dims=1)\n    ipr = dropdims(mean(iprs,dims=1),dims=1)\n\n    ax1 = Axis(f[1,1],\n        xlabel=L\"$W$\",\n        ylabel=\"IPR\",\n        )\n\n    for k in 1:neigs\n        scatter!(ax1,Ws,ipr[k,:])\n    end\n\n    ax2 = Axis(f[1,2],\n        xlabel=L\"$W$\",\n        ylabel=L\"$\\langle r \\rangle$\",\n        )\n\n    scatter!(ax2,Ws,r)\n\n    hlines!(ax2,0.386,label=\"Poisson\",color=:red)\n    hlines!(ax2,0.530,label=\"Gaussian\",color=:green)\n\n    axislegend(ax2)\n\n    save(\"../plots/mbl/L($L).png\",f)\n\nend\n\nmain()\n</code></pre>"},{"location":"examples/slow_quench_Ising/","title":"Bubble Nucleation in the 1D Quantum Ising Chain","text":"<p>Author Aritra Sinha</p> <p>We study a one-dimensional quantum Ising chain in the presence of both transverse (\\(h_x\\)) and longitudinal (\\(h_z\\)) fields. This system exhibits a first-order quantum phase transition (FOQPT) between two symmetry-broken ferromagnetic phases with opposite longitudinal magnetization.</p> <p>When the longitudinal field is slowly ramped from negative to positive values across the FOQPT, the system undergoes quantized bubble nucleation events [1]: sharp nonadiabatic transitions in the dynamics where local domains (or \u201cbubbles\u201d) of the new vacuum appear within the metastable phase. Each such nucleation corresponds to an \\(n\\)-spin bubble becoming degenerate with the initial state, and the tunneling between them is mediated via an \\(n\\)-th order process in \\(h_x\\). These events can be accurately described using Landau-Zener theory near each resonance point.</p>"},{"location":"examples/slow_quench_Ising/#the-model","title":"The Model","text":"<p>We consider the Hamiltonian:</p> \\[ \\mathcal{H} =   - \\sum_{n=1}^{N-1} \\sigma^z_n \\sigma^z_{n+1}   - h_x \\sum_{n=1}^{N} \\sigma^x_n   - h_z(t) \\sum_{n=1}^{N} \\sigma^z_n, \\] <p>where: - \\(\\sigma^x\\), \\(\\sigma^z\\) are Pauli matrices, - \\(h_x\\) introduces quantum fluctuations, - \\(h_z(t) = h_z^{\\text{in}} + t/\\tau_Q\\) is the time-dependent longitudinal field.</p> <p>The FOQPT separates the \\(\\langle \\sigma^z \\rangle &lt; 0\\) and \\(\\langle \\sigma^z \\rangle &gt; 0\\) ferromagnetic phases. The dynamics is initiated in the ground state at \\(h_z = h_z^{\\text{in}} &lt; 0\\), and the field is ramped linearly to \\(h_z^{\\text{fin}} &gt; 0\\).</p>"},{"location":"examples/slow_quench_Ising/#simulation-overview","title":"Simulation Overview","text":"<p>The Julia code in <code>main.jl</code> performs the following steps:</p> <ol> <li>Initialize a chain of length \\(N = 8\\) with a transverse field \\(h_x = 0.2\\).</li> <li>Prepare the initial state by computing the ground state at \\(h_z = -3\\) using exact diagonalization (<code>eig0</code>).</li> <li>Evolve the system in real time with time steps \\(\\Delta t = 0.05\\), using <code>time_evolve</code>, while slowly increasing \\(h_z(t)\\) across the FOQPT.</li> <li>Measure the longitudinal magnetization \\(m_z(t) = \\langle \\sigma^z \\rangle\\) at each step.</li> <li>Plot the results of the magnetization dynamics for multiple quench rates \\(\\tau_Q \\in \\{64, 256, 1024\\}\\).</li> </ol> <p>The plot below demonstrates distinct jumps in magnetization at characteristic values of \\(h_z\\), consistent with quantized bubble nucleation and higher-order tunneling events.</p> <p></p>"},{"location":"examples/slow_quench_Ising/#code","title":"Code","text":"Julia <pre><code>using XDiag\nusing LinearAlgebra\nusing Printf\nusing GLMakie\nusing LaTeXStrings\n\n# Build a LaTeX legend label for \u03c4_Q (used in plotting)\nfunction latex_label(tauQ::Union{Float64, Int})\n    return LaTeXString(\"\\\\tau_Q = \" * string(tauQ))\nend\n\n# Construct the Ising Hamiltonian with transverse and longitudinal fields\nfunction make_hamiltonian(N::Int, hx::Float64, hz::Float64)\n    op_sum = OpSum()\n\n    # Nearest-neighbor Ising term: -\u03c3\u1dbb\u1d62 \u03c3\u1dbb\u1d62\u208a\u2081\n    for i in 1:(N-1)\n        key_zz = \"zz_$i\"\n        op_sum += key_zz * Op(\"SzSz\", [i, i+1])\n        op_sum[key_zz] = -4.0  # compensate for Sz = \u00b11/2\n    end\n\n    # Transverse field: -hx * \u03c3\u02e3\u1d62 = -hx (S\u207a + S\u207b)\n    for i in 1:N\n        op_sum += \"sp_$i\" * Op(\"S+\", [i])\n        op_sum[\"sp_$i\"] = -hx\n        op_sum += \"sm_$i\" * Op(\"S-\", [i])\n        op_sum[\"sm_$i\"] = -hx\n    end\n\n    # Longitudinal field: -hz * \u03c3\u1dbb\u1d62\n    for i in 1:N\n        op_sum += \"hz_$i\" * Op(\"Sz\", [i])\n        op_sum[\"hz_$i\"] = -2 * hz\n    end\n\n    return op_sum\nend\n\n# Measure longitudinal magnetization m_z\nfunction measure(psi::State, N::Int)\n    mz = 0.0\n    for i in 1:N\n        mz += 2.0 * real(inner(Op(\"Sz\", [i]), psi))  # convert Sz = \u00b11/2 to \u00b11\n    end\n    return mz / N\nend\n\n# Compute ground state for given parameters\nfunction ground_state(N::Int, hx::Float64, hz::Float64)\n    block = Spinhalf(N)\n    H = make_hamiltonian(N, hx, hz)\n    return eig0(H, block)\nend\n\nfunction main()\n    # System and ramp parameters\n    N = 8\n    hx = 0.2\n    hz_in, hz_fin = -3.0, 3.0\n    dt = 0.05\n    tauQ_list = [64, 256, 1024]  # different ramp speeds\n\n    results = Dict{Float64, Tuple{Vector{Float64}, Vector{Float64}}}()\n\n    # Simulate slow longitudinal field ramps for various \u03c4_Q\n    for \u03c4Q in tauQ_list\n        @printf(\"\\n=== Running quench for tauQ=%.1f ===\\n\", \u03c4Q)\n        total_time = (hz_fin - hz_in) * \u03c4Q\n        nsteps = Int(ceil(total_time / dt))\n        dt_eff = total_time / nsteps\n\n        e0, psi0 = ground_state(N, hx, hz_in)\n\n        hz_vals = zeros(nsteps+1)\n        mz_vals = zeros(nsteps+1)\n        hz_vals[1] = hz_in\n        mz_vals[1] = measure(psi0, N)\n\n        psi_t = psi0\n        for step in 1:nsteps\n            t_cur = step * dt_eff\n            frac = t_cur / total_time\n            hz_now = hz_in + (hz_fin - hz_in) * frac\n\n            H = make_hamiltonian(N, hx, hz_now)\n            psi_t = time_evolve(H, psi_t, dt_eff)\n\n            hz_vals[step+1] = hz_now\n            mz_vals[step+1] = measure(psi_t, N)\n\n            if step % 500 == 0\n                @printf(\"step=%5d/%5d =&gt; t=%.2f, h_z=%.2f, m_z=%.3f\\n\",\n                        step, nsteps, t_cur, hz_now, mz_vals[step+1])\n            end\n        end\n        results[\u03c4Q] = (hz_vals, mz_vals)\n    end\n\n    # Plotting m_z vs h_z(t) for each ramp rate\n    fig = Figure(size=(800, 600))\n    ax = Axis(fig[1, 1];\n        title=\"Bubble Nucleation through Slow Quench\",\n        xlabel=L\"$h_z(t)$\", ylabel=L\"$m_z$\",\n        xticks = ([-3.0, -2, -1,  0.0, 1, 2, 3.0],\n                  [L\"-3\", L\"-2\", L\"-1\", L\"0\", L\"1\", L\"2\", L\"3\"]),\n\n        yticks = ([-1.0, -0.5, 0.0, 0.5],\n                  [L\"-1\", L\"-0.5\", L\"0\", L\"0.5\"]),\n        xticksize=20, yticksize=20,\n        xticklabelsize=36, yticklabelsize=36,\n        xlabelsize=36, ylabelsize=36,\n        titlesize=29\n    )\n\n    colors = (:blue, :red, :green)\n    for (i, \u03c4Q) in enumerate(tauQ_list)\n        hzvals, mzvals = results[\u03c4Q]\n        lines!(ax, hzvals[1:5:end], mzvals[1:5:end];\n            color=colors[i], linewidth=3,\n            label=latex_label(\u03c4Q)\n        )\n    end\n\n    axislegend(ax, position=:lt, labelsize=40)\n    save(\"magnetization_slow_quench.png\", fig)\n    println(\"\\n Plot saved to 'magnetization_slow_quench.png'\")\nend\n\nmain()\n</code></pre>"},{"location":"examples/slow_quench_Ising/#references","title":"references","text":"<p>[1]  Aritra Sinha, Titas Chanda, and Jacek Dziarmaga Nonadiabatic dynamics across a first-order quantum phase transition: Quantized bubble nucleation, Phys. Rev. B 103, L220302 (2021).</p>"},{"location":"examples/specific_heat_randomtj/","title":"Specific Heat Random t-J Model","text":"<p>Author: Rafael Soares</p> <p>We use full exact diagonalisation (ED) to calculate the specific heat in the t-J model with \\(N\\) sites, incorporating all-to-all random interactions and hoppings, $$ \\mathcal{H} = \\frac{1}{\\sqrt{N}}\\sum_{i\\neq j=0}^{N-1} t_{i j} P c^\\dagger_{i\\alpha} c_{j\\alpha} + \\frac{1}{\\sqrt{N}} \\sum_{i&lt; j=0}^{N-1} J_{ij} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j, $$ where \\(P\\) is the projection on non-doubly occupied sites, \\(\\boldsymbol{S}_i=\\frac{1}{2}c^\\dagger_{i\\alpha} \\boldsymbol{\\sigma}_{\\alpha \\beta}c_{j\\beta}\\) is the spin operator on site \\(i\\). Both the hoppings \\(t_{ij}=t^\\ast_{ji}\\) and the exchange interation \\(J_{ij}\\) are independent random numbers with zero mean and variance \\(\\bar{t}^2\\) and \\(\\bar{J}^2\\), respectively. This type of system exhibits a transition from a spin glass to a disordered Fermi liquid with increasing doping [1]. Notably, at the critical value of the doping, \\(p_c \\sim1/3\\), the model displays features reminiscent of the criticality observed in SYK models.</p> <p>The following algorithm constructs the t-J Hamiltonian and computes the specific heat using full ED for each realization of the random couplings. The specific heat is then obtained by performing disorder averaging in the post-processing step. In the figure above, we illustrate the case where \\(\\bar{t}^2 = \\bar{J}^2\\), \\(N=8\\), and the number of fermions with spin-up and spin-down is \\(2\\).</p> <p></p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nconst int Nsites = 8;     // total number of sites\nconst int Nup = 2;        // total number of spin-up fermions\nconst int Ndn = 2;        // total number of spin-down fermions\nconst int Nsamples = 200; // number of disorder averages\nconst double thopp = 1.0; // Variances hopping elements\nconst double Jhopp = 1.0; // Variances exchange elements\n\n// Create random devices to generate random couplings\nstd::random_device rd;\nstd::vector&lt;unsigned int&gt; seeds = {rd(), rd(), rd(), rd(), rd()};\nstd::seed_seq seq(seeds.begin(), seeds.end());\nstd::mt19937 gen(seq);\n\nvoid get_H(xdiag::OpSum &amp;H);\n\nint main() try {\n\n  // define Hamiltonian\n  auto block = tJ(Nsites, Nup, Ndn); // tj model sites\n\n  // Temperature range to compute the specific heat\n  arma::vec Temp = arma::linspace&lt;arma::vec&gt;(0.01, 0.5, 64);\n\n  // array to store specific heat\n  arma::mat C = arma::mat(Temp.n_elem, Nsamples, arma::fill::zeros);\n\n  // Obtain different disorder realizations\n  arma::vec eigs;\n  arma::cx_mat vecs;\n\n  // Generate bond interactions. Save all possible elements in a vector of\n  // strings to modifie latter\n  auto H = OpSum();\n  for (int i = 0; i &lt; Nsites; i++) {\n    for (int j = (i + 1); j &lt; Nsites; j++) {\n      std::string Sij = \"S_\" + std::to_string(i) + \"_\" + std::to_string(j);\n      std::string tij = \"t_\" + std::to_string(i) + \"_\" + std::to_string(j);\n      H += Sij * Op(\"SdotS\", {i, j});\n      H += tij * Op(\"Hop\", {i, j});\n    }\n  }\n\n  for (int i = 0; i &lt; Nsamples; i++) {\n\n    get_H(H); // generate new random couplings for the tj Hamiltonian\n\n    arma::cx_mat Hmat = matrixC(H, block); // convert to matrix\n    arma::eig_sym(eigs, vecs, Hmat);       // perform exact diagonalization\n    for (int j = 0; j &lt; Temp.n_elem; j++) {\n      arma::vec exp_eval = arma::exp(-eigs / Temp(j));\n      double Z = arma::sum(exp_eval); // Partition function;\n      double energy = arma::sum(eigs % exp_eval) / Z;\n      C(j, i) =\n          (1.0 / pow(Temp(j), 2)) * (arma::sum(eigs % (eigs % exp_eval)) / Z -\n                                     pow(energy, 2)); // Specific Heat\n    }\n  }\n\n  std::string filename =\n      \"randomtj.Nsites.\" + std::to_string((int)Nsites) + \".outfile.h5\";\n\n  auto save_fl = FileH5(filename, \"w!\");\n  save_fl[\"Temperature\"] = Temp;\n  save_fl[\"Specific_Heat\"] = C;\n\n  return 0;\n} catch (Error e) {\n  error_trace(e);\n}\n\nvoid get_H(xdiag::OpSum &amp;H) {\n  // Normal random generators\n  std::normal_distribution&lt;double&gt; Jdist(0.0, pow(Jhopp, 2));\n  std::normal_distribution&lt;double&gt; tdist(0.0, pow(thopp, 2) / sqrt(2.0));\n\n  // update random couplings\n  for (int i = 0; i &lt; Nsites; i++) {\n    for (int j = (i + 1); j &lt; Nsites; j++) {\n      std::string Sij = \"S_\" + std::to_string(i) + \"_\" + std::to_string(j);\n      std::string tij = \"t_\" + std::to_string(i) + \"_\" + std::to_string(j);\n      H[Sij] = Jdist(gen) / sqrt(Nsites);\n      H[tij] = std::complex&lt;double&gt;(tdist(gen), tdist(gen)) / sqrt(Nsites);\n    }\n  }\n}\n</code></pre> <pre><code>using XDiag\nusing Random, Distributions\nusing LinearAlgebra\nusing Printf\nusing HDF5\n\n\nfunction get_H!(H::OpSum, Nsites::Int, thopp::Float64, Jhopp::Float64)\n    #Variance of the hopping and interaction parameter:\n    thopp = 1.0\n    Jhopp = 1.0\n    Jdist = Normal(0.0, Jhopp^2) # Normal distribution\n    tdist = Normal(0.0, thopp^2 / sqrt(2.0)) # thopp\n\n    for i in 1:Nsites\n        for j in (i+1):Nsites\n            H[\"J_{$i}_{$j}\"] = rand(Jdist) / sqrt(Nsites)\n            H[\"t_{$i}_{$j}\"] = (rand(tdist) + 1im * rand(tdist)) / sqrt(Nsites)\n        end\n    end\nend\n\n\nfunction main()\n    Random.seed!(123) # seed this\n\n    Nsamples = 200\n    # define Hamiltonian\n    Nsites = 8 # total number of sites\n    nup = 2 # total number of spin-up fermions\n    ndn = 2 # total number of spin-down fermions\n    block = tJ(Nsites, nup, ndn) # tj model sites\n\n    Temp = LinRange(0.01, 0.5, 64) # temperature array\n    C = zeros(Float64, (length(Temp), Nsamples)) # array to store specific heat\n\n    #build Hamiltonian\n    H = OpSum()\n    for i in 1:Nsites\n        for j in (i+1):Nsites\n            H += \"J_{$i}_{$j}\" * Op(\"SdotS\", [i, j])\n            H += \"t_{$i}_{$j}\" * Op(\"Hop\", [i, j])\n        end\n    end\n\n    for i in 1:Nsamples\n        get_H!(H, Nsites, 1.0, 1.0) #generate random Hamiltonian\n        Hmat = matrix(H, block)\n        evals = eigvals(Hermitian(Hmat))\n\n        for (j, t) in enumerate(Temp)\n            exp_eval = exp.(-evals ./ t)\n            Z = sum(exp_eval)  # Partition function\n            energy = sum(evals .* exp_eval) / Z\n            C[j, i] = (1.0 / t^2) * (sum(evals .* evals .* exp_eval) / Z - energy^2)\n        end\n    end\n\n    filename = @sprintf(\"randomtj.Nsites.%d.outfile.h5\", Nsites)\n\n    h5open(filename, \"w\") do file\n        write(file, \"Temperature\", collect(Temp))\n        write(file, \"Specific_Heat\", C)\n    end\nend\n\nmain()\n</code></pre>"},{"location":"examples/specific_heat_randomtj/#references","title":"references","text":"<p>[1] H. Shackleton, A. Wietek, A. Georges, S. Sachdev, Quantum Phase Transition at Nonzero Doping in a Random t-J Model. Phys. Rev. Lett. 126, 136602 (2021)</p>"},{"location":"examples/specific_heat_tJ_triangular/","title":"Specific Heat of the Triangular Lattice t-J Model","text":"<p>Author Aritra Sinha</p> <p>We perform exact diagonalization (ED) to calculate the specific heat \\(C\\) of the triangular lattice t-J model, defined by the Hamiltonian:</p> \\[ \\mathcal{H} = -t \\sum_{\\langle i,j \\rangle, \\sigma} P\\left(c^\\dagger_{i\\sigma}c_{j\\sigma} + \\text{h.c.}\\right) + J\\sum_{\\langle i,j \\rangle}\\left(\\boldsymbol{S}_i\\cdot \\boldsymbol{S}_j - \\frac{1}{4}n_i n_j\\right), \\] <p>where \\(P\\) is the projection operator onto the space of non-doubly occupied sites, \\(c^\\dagger_{i\\sigma}\\) creates an electron at site \\(i\\) with spin \\(\\sigma\\), and the spin operators are defined as \\(\\boldsymbol{S}_i=\\frac{1}{2} c^\\dagger_{i\\alpha}\\boldsymbol{\\sigma}_{\\alpha\\beta}c_{i\\beta}\\). The sums \\(\\langle i,j \\rangle\\) run over nearest-neighbor bonds on a triangular lattice. This model has been studied extensively due to its relevance for correlated electron systems and frustrated magnetism, particularly in the context of triangular lattice compounds and high-temperature superconductors [1].</p>"},{"location":"examples/specific_heat_tJ_triangular/#lattice-geometry","title":"Lattice Geometry","text":"<p>In this example, we consider an 11-site triangular lattice (arranged in a 4-4-3 geometry) with one hole in the system. The number of electrons is thus \\(N_{\\text{sites}} - 1\\) (with equal numbers of spin-up and spin-down electrons). </p>"},{"location":"examples/specific_heat_tJ_triangular/#simulation-overview","title":"Simulation Overview","text":"<ul> <li>Model Parameters: </li> <li>Hopping parameter: \\(t = 1.0\\) </li> <li>Spin interaction parameter: \\(J = 0.4\\) </li> <li>System Parameters: </li> <li>Total lattice sites: \\(N_{\\text{sites}} = 11\\) </li> <li>Electrons: 10 (5 spin\u2011up, 5 spin\u2011down)  </li> <li>Specific Heat Calculation:   For a given temperature \\(T\\), we compute the Boltzmann weights   $$   w_i = \\exp\\left(-\\frac{E_i}{T}\\right),   $$   where the eigenvalues \\(\\{E_i\\}\\) are obtained from exact diagonalization of the t\u2011J Hamiltonian. The partition function is   $$   Z = \\sum_i w_i,   $$   and the average energy is given by   $$   \\langle E \\rangle = \\frac{1}{Z}\\sum_i E_i\\,w_i.   $$   The specific heat is then calculated using the relation   $$   C(T) = \\frac{1}{T^2}\\left(\\frac{1}{Z}\\sum_i E_i^2\\,w_i - \\langle E \\rangle^2\\right).   $$</li> </ul> <p>The figure below shows the specific heat as a function of \\(T/J\\):</p> <p></p>"},{"location":"examples/specific_heat_tJ_triangular/#code","title":"Code","text":"Julia <pre><code>using XDiag                # Package for exact diagonalization\nusing LinearAlgebra        # Standard library for linear algebra operations\nusing GLMakie              # Package for interactive plotting\nusing LaTeXStrings         # Package for LaTeX formatted strings in plots\n\nfunction main()\n    # Model parameters\n    Nsites = 11                         # Total number of lattice sites\n    electrons = Nsites - 1              # Number of electrons (one hole in the system)\n    nup = electrons \u00f7 2                 # Number of spin-up electrons\n    ndn = electrons - nup               # Number of spin-down electrons\n    println(\"Triangular t-J Model: Nsites=$Nsites, nup=$nup, ndn=$ndn (holes=$(Nsites-electrons))\")\n\n    # Define nearest-neighbor bonds for the 11-site triangular lattice (3-4-4 geometry)\n    bonds = [\n        (1, 2), (2, 3),\n        (1, 4), (1, 5), (2, 5), (2, 6), (3, 6), (3, 7),\n        (4, 5), (5, 6), (6, 7),\n        (4, 8), (5, 8), (5, 9), (6, 9), (6, 10), (7, 10), (7, 11),\n        (8, 9), (9, 10), (10, 11)\n    ]\n\n    # Build the Hamiltonian using the t-J model parameters\n    t = 1.0   # Hopping parameter\n    J = 0.4   # Interaction parameter\n    H = OpSum()\n    for (i, j) in bonds\n        H += J * Op(\"tJSdotS\", [i, j]) + t * Op(\"Hop\", [i, j])\n    end\n\n    # Define the block structure for the Hamiltonian with+out any symmetry\n    block = tJ(Nsites, nup, ndn)\n    Hmat = matrix(H, block)\n\n    # Perform ED\n    evals = eigvals(Hermitian(Hmat))\n\n    # Define temperature range \n    Temp = LinRange(0.01, 1.0, 64)\n    C = zeros(Float64, length(Temp)) \n\n    # Calculate specific heat at each temperature\n    for (idx, T) in enumerate(Temp)\n        w = exp.(-evals ./ T)         # Boltzmann factors\n        Z = sum(w)                    # Partition function\n        E = sum(evals .* w) / Z       # Average energy\n        C[idx] = (sum(evals.^2 .* w) / Z - E^2) / T^2  # Specific heat\n    end\n\n    # Create the figure\n    fig = Figure(size = (800, 600))\n\n    ax = Axis(fig[1, 1],\n        xlabel = L\"T/J\",\n        ylabel = L\"\\text{Specific Heat}\",\n        title = L\"\\text{Triangular t-J Model (11-site)}\",\n        xticklabelsize = 22,\n        yticklabelsize = 22,\n        xlabelsize = 22,\n        ylabelsize = 22,\n        titlegap = 14,\n        titlesize = 22\n    )\n\n    # Plot \n    scatterlines!(ax, Temp ./ J, C, markersize = 10, color = :blue)\n\n    # Save the figure\n    save(\"specific_heat_tJ_triangular.png\", fig)\n\nend\n\nmain()  \n</code></pre>"},{"location":"examples/specific_heat_tJ_triangular/#references","title":"References","text":"<p>[1] J. O. Haerter, M. R. Peterson, and B. S. Shastry, Finite temperature properties of the triangular lattice t-J model, PRB 74, 245118 (2006).</p>"},{"location":"examples/spinhalf_chain_TOS/","title":"Lattice Momentum Tower of States for the Heisenberg Chain","text":"<p>Author Paul Ebert</p> <p>This example demonstrates how to set up a tower of states analysis with respect to translation symmetries using the example of a spin-\\(1/2\\) chain $$     \\mathcal{H} = J \\sum_{\\langle i, j \\rangle} \\bm{S}_i \\cdot \\bm{S}_j, $$ with periodic boundary conditions and \\(J&gt;0\\) for aniferromagnetic interactions.</p> <p>The code below demonstrates how the lowest energy levels for each value of the lattice momentum can be computed using the Lanczos algorithm. The Julia version also contains a simple plotting method, leading to the following tower of states with respect to the lattice momentum.</p> <p></p> <p>As can be seen in the resulting figure, the tower of states nicely captures the dispersion relation of spinon excitations (e.g. flipping one spin relative to the ground state creates two spinons both carrying spin-\\(1/2\\)).</p> <p>This examples also demonstrates that the ground state is not necessarily found in the trivial representation of the translation symmetry, as the ground state resides at lattice momentum \\(k=\\pi\\) in the figure. In fact, the ground state alternates between \\(k=0\\) and \\(k=\\pi\\) for \\(N\\in 2(2\\mathbb{N}+1)\\) and \\(N \\in 4 \\mathbb{N}\\), respectively.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nstd::complex&lt;double&gt; C_N_character(int N, int k, int p) {\n  return std::exp(((2 * k * p) * M_PI / (double)N) *\n                  std::complex&lt;double&gt;(0, 1.));\n};\n\nint main() try {\n\n  // specify system parameters\n  int N = 18;\n  double J = 1.0;\n\n  // fix number of up spins\n  int Nup = N / 2;\n\n  // build Hamiltonian\n  auto H = OpSum();\n  for (int i = 0; i &lt; N; i++) {\n    H += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n  }\n  H[\"J\"] = J;\n\n  // set up translation symmetry\n  // step 1: define shift by one site\n  std::vector&lt;int64_t&gt; T_perm(N, 0);\n  for (int i = 0; i &lt; N - 1; i++) {\n    T_perm[i] = i + 1;\n  };\n  auto T = Permutation(T_perm);\n\n  // step 2: define cyclic group\n  std::vector&lt;Permutation&gt; perms(N);\n  for (int i = 0; i &lt; N; i++) {\n    perms[i] = pow(T, i);\n  };\n  auto C_N = PermutationGroup(perms);\n\n  // step 3: define irreps from character tables, labelled by momentum (2pi/N\n  // \u00d7) k\n  std::vector&lt;Representation&gt; irreps(N);\n  std::vector&lt;std::complex&lt;double&gt;&gt; characters(N, 0.0);\n  for (int k = 0; k &lt; N; k++) {\n    for (int p = 0; p &lt; N; p++) {\n      characters[p] = C_N_character(N, k, p);\n    };\n    irreps[k] = Representation(C_N, characters);\n  };\n\n  // sort states in Sz_tot = 0 sector by translation irrep\n  int lvl_per_block = 5;\n  std::vector&lt;double&gt; TOS_x_vals(N * lvl_per_block);\n  std::vector&lt;double&gt; TOS_y_vals(N * lvl_per_block);\n  for (int k = 0; k &lt; N; k++) {\n    auto sym_block = Spinhalf(N, Nup, irreps[k]);\n    // set neigvals = ... for reasonable convergence of lowest eigenvalues\n    int neigvals = 3;\n    auto lanczos_result = eigvals_lanczos(H, sym_block, neigvals);\n    for (int i = 0; i &lt; lvl_per_block; i++) {\n      TOS_x_vals[k * lvl_per_block + i] = (2 * M_PI * k) / N;\n      TOS_y_vals[k * lvl_per_block + i] = lanczos_result.eigenvalues[i];\n    }\n  };\n\n  // use the vectors TOS_x_vals and TOS_y_vals to create e.g. the TOS plot ...\n  // ... for a simple plotting method check the Julia version of this example\n\n  return 0;\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing Plots \n\nfunction main()\n\n    # specify system parameters\n    N = 18\n    J = 1.0\n\n    # fix number of up spins\n    Nup = N\u00f72\n\n    # build Hamiltonian\n    H = OpSum()\n    for i in 1:N\n        H += \"J\" * Op(\"SdotS\", [i,mod1(i+1, N)])\n    end\n    H[\"J\"] = J\n\n    # set up translation symmetry\n    T = Permutation(circshift(1:N, -1))\n    C_N = PermutationGroup([T^k for k in 0:(N-1)])\n    character_table = [ [C_N_character(N, k, p) for p in 0:(N-1)] for k in 0:(N-1)]\n    irreps = [ Representation(C_N, character_table[k]) for k in 1:N ]   \n\n    # sort states in Sz_tot = 0 sector by translation irrep\n    lvl_per_block = 5\n    TOS_x_vals = Vector{Float64}(undef, N*lvl_per_block)\n    TOS_y_vals  = Vector{Float64}(undef, N*lvl_per_block)\n    for k in eachindex(irreps)\n        sym_block = Spinhalf(N, Nup, irreps[k])\n        # set neigvals = ... for reasonable convergence of lowest eigenvalues\n        lanczos_result = eigvals_lanczos(H, sym_block, neigvals=3) \n        for i in 1:lvl_per_block\n            TOS_x_vals[(k-1)*lvl_per_block + i] = 2*pi*(k-1)/N\n            TOS_y_vals[(k-1)*lvl_per_block + i] = lanczos_result.eigenvalues[i]\n        end\n    end\n\n    # create TOS plot\n    scatter(\n        TOS_x_vals,\n        TOS_y_vals,\n        title=\"Tower of States, AFM Heisenberg Chain, N=$N\\n\",\n        xlabel=\"lattice momentum k\",\n        ylabel=\"lowest eigenstates\",\n        legend=false,\n        xticks = ([0:\u03c0/2:2*\u03c0;], [\"0\", \"\\\\pi/2\", \"\\\\pi\", \"3\\\\pi/2\", \"2\\\\pi\"]),\n        right_margin=5Plots.mm,\n        dpi=300)\nend\n\n\nfunction C_N_character(N::Int, k::Int, p::Int)\n    return exp( im * 2 * pi * p * k * 1.0 / N )\nend\n\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_domain_wall_dynamics/","title":"Domain Wall Dynamics in a Spin-\\(1/2\\) Chain","text":"<p>Author Paul Ebert</p> <p>This example demonstrates the time-evolution of quantum states in <code>XDiag</code> for the dynamics of a domain wall in the ferromagnetic spin-\\(1/2\\) XXZ chain</p> \\[     \\mathcal{H} = \\sum_{i=1}^{N-1} \\Big(- J \\bm{S}^z_i \\cdot \\bm{S}^z_{i+1} + \\frac{\\Delta}{2}\\big( \\bm{S}^+_i \\cdot \\bm{S}^-_{i+1} + \\bm{S}^-_i \\cdot \\bm{S}^+_{i+1} \\big) \\Big), \\] <p>where \\(0 &lt; J\\). Note that here we use open instead of periodic boundary conditions, allowing to have a single domain wall in the system.</p> <p>We choose as initial state the following eigenstate of the associated Ising chain (i.e. the model with only \\(S^zS^z\\) interactions) $$ \\ket{\\psi_0} = \\ket{\\uparrow\\ldots\\uparrow\\downarrow\\ldots\\downarrow}, $$  having a domain wall in the middle of the chain. We expect the exchange terms in the XXZ Hamiltonian above to dissolve the domain wall over time as \\(\\ket{\\psi_0}\\) is not an eigenstate of the XXZ chain. This process may also be viewed as suddenly turning on exchange interactions in an Ising chain.</p> <p>The code below demonstrates how the the initial domain wall slowly dissolves. The following figure was created using the Julia version of the code, which includes a plotting command:</p> <p></p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\n\nint main() \ntry {\n\n    // define open ferromagnetic XXZ chain\n    int N = 16;\n    double J = 0.1;\n    double Delta = 0.5;\n\n    auto H = OpSum();\n    for (int i=0; i&lt;(N-1); i++){\n        H += \"J\" * Op(\"SzSz\", {i, i+1});\n        H += \"Delta\" * Op(\"Exchange\", {i, i+1});\n    }\n\n    H[\"J\"] = J;\n    H[\"Delta\"] = Delta;\n\n    // define initial state with domain wall\n    auto block = Spinhalf(N);\n    std::vector&lt;std::string&gt; psi0_vec (N);\n    for (int i=0; i&lt;N/2; i++) {psi0_vec[i] = \"Up\";}\n    for (int i=N/2; i&lt;N; i++) {psi0_vec[i] = \"Dn\";}\n    auto psi = product_state(block, psi0_vec);\n\n    // time evolve psi0 and measure Sz expectation value\n    double dt = 0.5;\n    int Nt = 30;\n    std::vector&lt;std::vector&lt;double&gt; &gt; Sz_expectation(Nt, std::vector&lt;double&gt;(N));\n    for (int t_step=0; t_step&lt;Nt; t_step++){\n        time_evolve_inplace(H, psi, dt);\n        for (int i=0; i&lt;N; i++){\n            Sz_expectation[t_step][i] = innerC(Op(\"Sz\", {i}), psi).real(); // result must be real\n        }\n    }\n\n    // do something here with Sz_expectation (see Julia version for plotting routine)\n\n    return 0;\n} catch(Error e){\n    error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing Plots \n\nfunction main()\n\n    # define open ferromagnetic XXZ chain\n    N = 16\n    J = 0.1\n    Delta = 0.5\n\n    H = OpSum()\n    for i in 1:(N-1)\n        H += \"J\" * Op(\"SzSz\", [i, i+1])\n        H += \"Delta\" * Op(\"Exchange\", [i, i+1])\n    end\n\n    H[\"J\"] = J\n    H[\"Delta\"] = Delta\n\n    # define initial state with domain wall\n    block = Spinhalf(N)\n    psi0_vec = vcat(repeat([\"Up\"], N\u00f72), repeat([\"Dn\"], N\u00f72))\n    psi = product_state(block, psi0_vec)\n\n    # time evolve and measure Sz expectation value\n    dt = 0.5\n    Nt = 30\n    Sz_expectation = Matrix{Float64}(undef, Nt, N)\n    for t_step in 1:Nt\n        time_evolve_inplace(H, psi, dt)\n        for i in 1:N\n            Sz_expectation[t_step, i] = real(inner(Op(\"Sz\", [i]), psi))\n        end\n    end\n\n    # plot Sz expectation value\n    @show heatmap(\n        Sz_expectation,\n        c = :thermal,\n        xlabel=\"chain coordinate\",\n        ylabel=\"time step\",\n        title = \"Sz expectation value over time\")\n\nend\n\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_e0/","title":"Ground state energy","text":"<p>Author: Alexander Wietek</p> <p>We compute the ground state energy of a spin S = 1/2 Heisenberg chain,</p> \\[     \\mathcal{H} = \\sum_{\\langle i, j \\rangle} \\bm{S}_i \\cdot \\bm{S}_j  \\] <p>without using translational symmetries. This minimal example shows how to set up a model and run a simple Lanczos algorithm.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n  int N = 16;\n  int nup = N / 2;\n  Spinhalf block(N, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  OpSum ops;\n  for (int i = 0; i &lt; N; ++i) {\n    ops += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n  }\n  ops[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(ops, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\n\nlet\n    say_hello()\n    N = 16\n    nup = N \u00f7 2\n    block = Spinhalf(N, nup)\n\n    # Define the nearest-neighbor Heisenberg model\n    ops = OpSum()\n    for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    ops[\"J\"] = 1.0\n\n    set_verbosity(2)            # set verbosity for monitoring progress\n    e0 = eigval0(ops, block)    # compute ground state energy\n\n    println(\"Ground state energy: $e0\")\nend\n</code></pre>"},{"location":"examples/spinhalf_chain_gs_corr_symmetries/","title":"\\(S=\\frac12\\) chain: Symmetries and Ground State Correlators","text":"<p>Author: Paul Ebert</p> <p>This example demonstrates how ground state expectation values can be computed for the spin-\\(\\frac{1}{2}\\) XXX antiferromagnetic chain</p> \\[     \\mathcal{H} = \\sum_{\\langle i, j \\rangle} \\bm{S}_i \\cdot \\bm{S}_j = \\sum_{\\langle i, j \\rangle} (S^x_i S^x_j + S^y_i S^y_j + S^z_i S^z_j) \\] <p>with periodic boundary conditions. The Hamiltonian is invariant under translations and decomposes into \\(N\\) irreducible representations (irreps) labelled by lattice momentum \\(2\\pi/N \\times k\\) where \\(k=0, 1, \\ldots, N-1\\). The Lanczos algorithm is run on all momentum sub-blocks, effectively exchanging a longer runtime for less memory consumption. An important caveat when working with representations is that the operators inside expectation values must be symmetrized with respect to the symmetry group.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nstd::complex&lt;double&gt; C_N_character(int N, int k, int p) {\n  return std::exp(((2 * k * p) * M_PI / (double)N) *\n                  std::complex&lt;double&gt;(0, 1.));\n}\n\nint main() try {\n  // periodic N-site Heisenberg antiferromagnet\n  int N = 14;\n  auto H = OpSum();\n  for (int i = 0; i &lt; N; i++) {\n    H += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n  }\n  H[\"J\"] = 1.0;\n\n  // define shift by one site\n  std::vector&lt;int64_t&gt; T_perm(N, 0);\n  for (int i = 0; i &lt; N - 1; i++) {\n    T_perm[i] = i + 1;\n  }\n  auto T = Permutation(T_perm);\n\n  // define cyclic group\n  std::vector&lt;Permutation&gt; perms(N);\n  for (int i = 0; i &lt; N; i++) {\n    perms[i] = pow(T, i);\n  }\n  auto C_N = PermutationGroup(perms);\n\n  // define irreps from character tables, labelled by momentum (2pi/N \u00d7) k\n  std::vector&lt;Representation&gt; irreps(N);\n  std::vector&lt;std::complex&lt;double&gt;&gt; characters(N, 0.0);\n  for (int k = 0; k &lt; N; k++) {\n    for (int p = 0; p &lt; N; p++) {\n      characters[p] = C_N_character(N, k, p);\n    };\n    irreps[k] = Representation(C_N, characters);\n  }\n\n  // check all translation symmetry blocks\n  double e0 = 0.0;\n  State psi0;\n  for (int k = 0; k &lt; N; k++) {\n    auto block = Spinhalf(N, irreps[k]);\n    auto [e0k, psik] = eig0(H, block);\n    if (e0k &lt; e0) {\n      e0 = e0k;\n      psi0 = psik;\n    }\n  }\n\n  // we measure the correlation (which needs to besymmetrized)\n  auto corr_op = Op(\"SdotS\", {0, N / 2 - 1});\n  auto corr = inner(symmetrize(corr_op, C_N), psi0);\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n  Log(\"Ground state correlator: {:.12f}\", corr);\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\n\nfunction main()\n\n    # periodic N-site Heisenberg antiferromagnet\n    N = 14\n    H = OpSum()\n    for i in 1:N\n        H += \"J\" * Op(\"SdotS\", [i, mod1(i+1, N)])\n    end\n    H[\"J\"] = 1.0 \n\n    # define spin correlator at \"half-chain\" distance\n    corr_op = OpSum()\n    corr_op += Op(\"SdotS\", [1, N \u00f7 2])\n\n    # define shift by one site\n    T = Permutation(circshift(1:N, -1))\n\n    # define cyclic group\n    C_N = PermutationGroup([T^k for k in 0:(N-1)])\n\n    # define irreps from character tables, labelled by momentum (2pi/N \u00d7) k\n    character_table = [ [C_N_character(N, k, p) for p in 0:(N-1)] for k in 0:(N-1)]\n    irreps = [ Representation(C_N, character_table[k]) for k in 1:N ]   \n\n    # check all translation symmetry blocks\n    e0 = Inf\n    psi0 = nothing\n    for k in eachindex(irreps)\n        block = Spinhalf(N, irreps[k]) \n        e0k, psik = eig0(H, block)\n        if  e0k &lt; e0\n            e0 = e0k\n            psi0 = psik\n        end\n    end\n\n    # now the operator must be symmetrized!\n    corr = inner(symmetrize(corr_op, C_N), psi0)\n\n    println(\"Ground state energy: $e0\")\n    println(\"Ground state correlator: $corr\")\n    println(\"State vector length = \", size(psi0))\n\nend\n\nfunction C_N_character(N::Int, k::Int, p::Int)\n    exp(im * 2 * pi * k * p / N)\nend\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_level_statistics/","title":"Level Statistics in Spin-\\(1/2\\) Chains","text":"<p>Author Paul Ebert</p> <p>This example demonstrates the differing level statistics of integrable and non-integrable models using the example of spin-\\(1/2\\) chains.</p> <p>The term level statistic refers to the probability distribution \\(P(s)\\) where the variable \\(s\\) is the difference between adjacent energy levels \\(0 \\leq E_{i+1}-E_i\\). That is, for a given quantum system \\(P(s)\\) describes the likelihood that the next excited state above a randomly chosen energy level \\(E\\) has energy \\(E + s\\). To ensure comparability across different systems, one typically normalizes the level spacings by its mean value \\(\\tilde{s} = s/ \\bar{s}\\) and considers \\(P(\\tilde{s})\\). Since this is the standard procedure, we will assume that \\(P(s)\\) is the distribution of the normalized energy differences below instead of writing \\(P(\\tilde{s})\\).</p> <p>It is well established that for integrable systems (i.e. those with conserved quantities) the level statistic is a Poissonian $$     P_{\\mathrm{Poiss}}(s) = \\exp(-s) $$ whereas the so-called Wigner-Dyson distribution emerges for non-integrable systems $$     P_{\\mathrm{WD}}(s) = \\frac{\\pi s}{2} \\exp(- \\pi s^2/4). $$ Intuitively speaking, this is because having a system with symmetries and associated conserved quantities leads to degeneracies that contribute to seeing \\(s=0\\) very often such that \\(P_{\\mathrm{Pois}}(0) &gt; 0\\). On the contrary, the energy levels of non-integrable systems are approximately randomly distributed (especially in the bulk of the spectrum), giving a distribution satisfying \\(P_{\\mathrm{WD}}(0) = 0\\).</p> <p>To showcase this, we inspect two spin-\\(1/2\\) Hamiltonians on a chain, one being the integrable XXZ model</p> \\[ \\mathcal{H}_{\\mathrm{i}} = \\sum_{\\langle i, j \\rangle} \\Big(J \\bm{S}^z_i \\cdot \\bm{S}^z_j + \\frac{\\Delta}{2}\\big( \\bm{S}^+_i \\cdot \\bm{S}^-_j + \\bm{S}^-_i \\cdot \\bm{S}^+_j \\big) \\Big), \\] <p>while the second merely adds a next-nearest-neighbor interaction</p> \\[     \\mathcal{H}_{\\mathrm{ni}} = H_{\\mathrm{i}} + \\sum_{&lt;&lt; i, j &gt;&gt;} J_2 \\bm{S}^z_i \\cdot \\bm{S}^z_j \\] <p>and becomes \"non-integrable\". We must put \"non-integrable\" in quotes here, since strictly speaking both models are integrable. However, the \\(\\mathcal{H}_{\\mathrm{ni}}\\) system becomes non-integrable once the trivial spin-flip, mirror, and translation symmetries (we employ periodic boundary conditions) are removed. This is done by considering specific sectors of the total Hilbert space which is easily done in <code>XDiag</code>.</p> <p>The code below demonstrates how the level statistics of these systems can be computed inside the sectors where all trivial symmetries are removed. The Julia version also contains a simple plotting method, leading to the following distribution of level statistics:</p> <p></p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\n\nstd::complex&lt;double&gt; C_N_character(int N, int k, int p){\n    return std::exp( ( (2 * k * p) * M_PI / (double)N ) * std::complex&lt;double&gt;(0,1.) );\n};\n\nstd::vector&lt;double&gt; compute_level_statistics(int N, OpSum H){\n\n    // fix magnetization (Sztot = 0 still has spin-flip symmetry!)\n    int Nup = N/2 + 1;\n\n    // fix lattice momentum (k = 0, N/2 still have parity symmetry!)\n    int k = 1;\n\n    std::vector&lt;int64_t&gt; T_perm (N, 0);\n    for (int i=0; i&lt;N-1; i++){\n        T_perm[i] = i + 1;\n    };\n    auto T = Permutation(T_perm);\n\n    std::vector&lt;Permutation&gt; perms (N);\n    for (int i=0; i&lt;N; i++){\n        perms[i] = pow(T, i);\n    };\n    auto C_N = PermutationGroup(perms);\n\n    std::vector&lt; std::complex &lt;double&gt; &gt; irrep_k_characters (N, 0.0);\n    for (int p=0; p&lt;N; p++){\n        irrep_k_characters[p] = C_N_character(N, k, p);\n    };\n    auto irrep_k = Representation(C_N, irrep_k_characters);\n\n    // block of Hamiltonian without remaining symmetries\n    auto block = Spinhalf(N, Nup, irrep_k);\n\n    // find its eigenspectrum\n    arma::cx_mat Hmat = matrixC(H, block);     \n    arma::vec eigenvalues = eig_sym(Hmat);\n\n    // compute level statistics (taking only the inner most half of spectrum)\n    int N_levels = eigenvalues.n_elem;\n    int s_start = (int)(0.25 * N_levels);\n    int s_stop = (int)(0.75 * N_levels);\n    int s_num = s_stop - s_start;\n    std::vector&lt;double&gt; s_arr (s_num);\n    double s_arr_sum = 0.0;\n    for (int i=0; i&lt;s_num; i++){\n        s_arr[i] = eigenvalues[s_start+i+1] - eigenvalues[s_start+i];\n        s_arr_sum += s_arr[i];\n    }\n    s_arr_sum = s_arr_sum / s_num;\n\n    // normalize\n    for (int i=0; i&lt;s_num; i++){\n        s_arr[i] = s_arr[i] /  s_arr_sum;\n    }\n\n    return s_arr;\n}\n\n\nint main() try {\n\n    int N = 18; // length of spin chain\n\n    // definition of integrable model\n    auto H_i = OpSum();\n    for (int i=0; i&lt;N; i++){\n        H_i += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n        H_i += \"Delta\" * Op(\"Exchange\", {i, (i+1)%N});\n    }\n\n    // definition of non-integrable model\n    auto H_ni = OpSum();\n    for (int i=0; i&lt;N; i++){\n        H_ni += \"J\" * Op(\"SzSz\", {i, (i+1)%N});\n        H_ni += \"Delta\" * Op(\"Exchange\", {i, (i+1)%N});\n        H_ni += \"J2\" * Op(\"SzSz\", {i, (i+2)%N});\n    }\n\n    // assign coupling values\n    double J, Delta, J2;\n    J = 1.0;\n    Delta = J2 = 0.5;\n\n    H_i[\"J\"] = H_ni[\"J\"] = J;\n    H_i[\"Delta\"] = H_ni[\"Delta\"] = Delta;\n    H_ni[\"J2\"] = J2;\n\n    // compute level statistics (remember to eliminate trivial symmetries!)\n    std::vector&lt;double&gt; H_i_statistics = compute_level_statistics(N, H_i); \n    std::vector&lt;double&gt; H_ni_statistics = compute_level_statistics(N, H_ni); \n\n    // do something with H_i_statistics and H_ni_statistics here (Julia version has a plotting routine)\n    return 0;\n\n} catch(Error e) {\n    error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing LinearAlgebra # exact diagonalization\nusing Plots # optional: plot histograms\n\n\nfunction main()\n\n    N = 18\n\n    # definition of integrable model\n    H_i = OpSum()\n    for i in 1:N\n        H_i += \"J\" * Op(\"SzSz\", [i,mod1(i+1, N)])\n        H_i += \"Delta\" * Op(\"Exchange\", [i, mod1(i+1, N)])\n    end\n\n    # definition of non-integrable model\n    H_ni = OpSum()\n    for i in 1:N\n        H_ni += \"J\" * Op(\"SzSz\", [i, mod1(i+1, N)])\n        H_ni += \"Delta\" * Op(\"Exchange\", [i, mod1(i+1, N)])\n        H_ni += \"J2\" * Op(\"SzSz\", [i, mod1(i+2, N)])\n    end\n\n    # assign coupling values\n    J = 1.0\n    Delta = J2 = 0.5\n\n    H_i[\"J\"] = H_ni[\"J\"] = J\n    H_i[\"Delta\"] = H_ni[\"Delta\"] = Delta\n    H_ni[\"J2\"] = J2\n\n    # compute level statistics (remember to eliminate trivial symmetries!)\n    H_i_statistics = compute_level_statistics(N, H_i)\n    H_ni_statistics = compute_level_statistics(N, H_ni)\n\n    # optional plot of histograms (only in Julia version!)\n    plot_histograms(H_i_statistics, H_ni_statistics)\nend\n\n\nfunction compute_level_statistics(N::Int, H::OpSum) :: Vector{Float64}\n\n    # fix magnetization (Sz_tot = 0 still has spin-flip symmetry!)\n    Nup = N\u00f72 + 1\n\n    # fix lattice momentum (k = 0, N/2 still have parity symmetry!)\n    k = 1\n    T = Permutation(circshift(1:N, -1))\n    C_N = PermutationGroup([T^p for p in 0:(N-1)])\n    irrep_k_characters = [C_N_character(N, k, p) for p in 0:(N-1)]\n    irrep_k = Representation(C_N, irrep_k_characters)\n\n    # block of Hamiltonian without remaining symmetries\n    block = Spinhalf(N, Nup, irrep_k) \n\n    # find its eigenspectrum\n    Hmat = matrix(H, block)\n    eigenvalues = eigvals(Hermitian(Hmat))\n\n    # compute level statistics (taking only inner most half of spectrum)\n    N_levels = size(block)\n    s_start = trunc(Int, 0.25*N_levels)\n    s_stop = trunc(Int, 0.75*N_levels)\n    s_num = s_stop - s_start\n    s_arr = Vector{Float64}(undef, s_num)\n    s_arr_sum = 0.0\n    for i in 1:s_num\n        s_arr[i] = eigenvalues[s_start+i+1] - eigenvalues[s_start+i]  \n        s_arr_sum += s_arr[i]\n    end\n\n    # normalize\n    return s_arr / (s_arr_sum / s_num)\nend \n\n\nfunction C_N_character(N::Int, k::Int, p::Int)\n    return exp( im * 2 * pi * p * k * 1.0 / N )\nend\n\n\nfunction plot_histograms(integ_stat::Vector{Float64}, noninteg_stat::Vector{Float64})\n    # plot histograms\n    smax = 3\n    Nbins = 20\n    bins = LinRange(0, smax, Nbins)\n    histogram(\n        [integ_stat noninteg_stat],\n        bins=bins,\n        normalize=:pdf,\n        fillalpha=0.3,\n        label=[\"integrable\" \"non-integrable\"],\n        xlabel=\"s\",\n        ylabel=\"P(s)\"\n    )\n\n    # plot Wigner Dyson distribution\n    x_vals = LinRange(0, smax, 200)\n    WD_y_vals = WD_func.(x_vals)\n    plot!(x_vals, WD_y_vals, color=:red, linewidth=3, label=\"Wigner-Dyson\")\n\n    # plot Poisson distribution\n    Pois_y_vals = Poisson_func.(x_vals)\n    plot!(x_vals, Pois_y_vals, color=:black, linewidth=3, label=\"Poisson\")\nend\n\n\nfunction WD_func(s::Float64) :: Float64\n    return (pi*s/2) * exp(-pi*s^2/4)\nend\n\n\nfunction Poisson_func(s::Float64) :: Float64\n    return exp(-s)\nend\n\n\n\n\nmain()\n</code></pre>"},{"location":"examples/spinhalf_chain_structure_factor/","title":"Dynamical spin structure factor","text":"<p>Author Martin Ulaga</p> <p>Uses the Lanczos algorithm [1] to calculate the dynamical spin spectral function of the spin-1/2 Heisenberg chain. The structure factor is defined as</p> <p>$$     S^{zz}({\\bf k},\\omega) = \\int dt e^{-i\\omega t}\\langle S^z_{\\bf k}(t)S^z_{\\bf -k}\\rangle, $$ where \\(S^z_{\\bf k}=\\frac{1}{\\sqrt{N}}\\sum_i e^{-i\\bf{k\\cdot r}_i}S^z_i\\) and \\(S^z_i\\) is a spin operator on site \\(i\\). The calculation is done using the Lehmann representation</p> <p>$$     S^{zz}({\\bf k},\\omega)=\\frac{1}{N}\\sum_{m=1}^M |\\langle\\Psi_0|S^z_{\\bf k}|\\psi_m\\rangle|^2\\delta(\\omega-\\epsilon_m+E_0), $$ where \\(|\\Psi_0\\rangle\\) is the ground state which needs to be computed. The algorithm proceeds in 3 steps:</p> <ol> <li> <p>Compute the ground state \\(|\\Psi_0\\rangle\\) (is the appropriate symmetry sector, e.g., usually \\({\\bf k}=0\\)).</p> </li> <li> <p>Find the operator \\(S^z_{\\bf k}\\), e.g. symmetrize with respect to the appropriate irrep, and calculate \\(|\\tilde{\\Psi}_0\\rangle=S^z_{\\bf k}|\\Psi_0\\rangle\\).</p> </li> <li> <p>Rerun the Lanczos algorigthm using the normalized state \\(|\\Psi_1\\rangle=|\\tilde{\\Psi}_0\\rangle/\\sqrt{\\langle\\tilde{\\Psi}_0|\\tilde{\\Psi}_0\\rangle}\\).</p> </li> </ol> <p></p>"},{"location":"examples/spinhalf_chain_structure_factor/#main-example-code","title":"Main example code","text":"JuliaC++ <pre><code>    using Pkg;\n    Pkg.instantiate();\n    using XDiag\n    using HDF5\n\n    function main()\n      say_hello()\n      filename = \"../../misc/data/examples_output/spinhalf_chain_structure_factor.h5\"\n      outfile = h5open(filename, \"w\")\n\n      # define model\n      N = 16\n      nup = div(N, 2)\n      ops = OpSum()\n      for i in 1:N\n        ops += \"J\" * Op(\"SdotS\", [i, mod1(i + 1, N)])\n      end\n      ops[\"J\"] = 1.0\n      @show ops\n\n      # Create the permutation group\n      @show perm = Permutation([mod1(s + 1, N) for s in 1:N])\n      @show group = PermutationGroup([perm^s for s in 0:N-1])\n\n      # Create the irreps at momenta k\n      irreps = Representation[]\n      for k in 0:N-1\n        phase = exp(2im * pi * k / N)\n        characters = [phase^s for s in 0:N-1]\n        irrep = Representation(group, characters)\n        # @show irrep\n        push!(irreps, irrep)\n      end\n\n      # compute groundstate (known to be at k=0)\n      println(\"Computing ground state ...\")\n      block = Spinhalf(N, nup, irreps[1])\n      e0, gs = eig0(ops, block)\n      make_complex!(gs)\n      println(\"done.\")\n      println(\"Ground state energy: $e0\")\n      outfile[\"e0\"] = e0\n\n      # loop through momenta\n      for k in 1:N\n        println(\"coumputing structure factor at q=$k\")\n        S_q = symmetrize(Op(\"Sz\", 1), irreps[k])\n        Av = apply(S_q, gs)\n        nrm = norm(Av)\n        Av /= nrm\n\n        res = eigvals_lanczos_inplace(ops, Av)\n        outfile[\"$k/norm\"] = nrm\n        outfile[\"$k/alphas\"] = res.alphas\n        outfile[\"$k/betas\"] = res.betas\n        outfile[\"$k/eigs\"] = res.eigenvalues\n      end\n    end\n\n    main()\n</code></pre> <pre><code>    #include &lt;xdiag/all.hpp&gt;\n\n    using namespace xdiag;\n    using namespace std::complex_literals;\n    using fmt::format;\n\n    constexpr double XDIAG_PI = 3.14159265358979323846;\n\n    int main() try {\n      say_hello();\n\n      // IO\n      std::string filename = XDIAG_DIRECTORY\n          \"/misc/data/examples_output/spinhalf_chain_structure_factor.h5\";\n      auto outfile = FileH5(filename, \"w!\");\n\n      // Define the nearest-neighbor Heisenberg model\n      int N = 16;\n      int nup = N / 2;\n      OpSum ops;\n      for (int i = 0; i &lt; N; ++i) {\n        ops += \"J\" * Op(\"SdotS\", {i, (i + 1) % N});\n      }\n      ops[\"J\"] = 1.0;\n\n      // Create the permutation group\n      std::vector&lt;int&gt; translation;\n      for (int s = 0; s &lt; N; ++s) {\n        translation.push_back((s + 1) % N);\n      }\n      Permutation perm(translation);\n      std::vector&lt;Permutation&gt; perms;\n      for (int s = 0; s &lt; N; ++s) {\n        perms.push_back(pow(perm, s));\n      }\n      auto group = PermutationGroup(perms);\n\n      // Create the irreps at momenta k\n      std::vector&lt;Representation&gt; irreps;\n      for (int k = 0; k &lt; N; ++k) {\n        complex phase = exp(2i * XDIAG_PI * (double)k / (double)N);\n        std::vector&lt;complex&gt; characters;\n        for (int s = 0; s &lt; N; ++s) {\n          characters.push_back(pow(phase, s));\n        }\n        auto irrep = Representation(group, characters);\n        irreps.push_back(irrep);\n      }\n\n      // compute groundstate (known to be at k=0)\n      Log(\"Computing ground state ...\");\n      auto block = Spinhalf(N, nup, irreps[0]);\n      auto [e0, gs] = eig0(ops, block);\n      gs.make_complex();\n      Log(\"done.\");\n      Log(\"Ground state energy: {:.12f}\", e0);\n      outfile[\"e0\"] = e0;\n\n      // loop through momenta\n      for (int k = 0; k &lt; N; ++k) {\n        Log(\"S^zz(k,w) at momentum {}\", k);\n        auto S_q = symmetrize(Op(\"Sz\", 0), irreps[k]);\n        auto Av = apply(S_q, gs);\n        auto nrm = norm(Av);\n        Av /= nrm;\n        XDIAG_SHOW(nrm);\n\n        auto res = eigvals_lanczos_inplace(ops, Av);\n        outfile[format(\"{}/norm\", k)] = nrm;\n        outfile[format(\"{}/alphas\", k)] = res.alphas;\n        outfile[format(\"{}/betas\", k)] = res.betas;\n        outfile[format(\"{}/eigs\", k)] = res.eigenvalues;\n      }\n\n    } catch (Error e) {\n      error_trace(e);\n    }\n</code></pre>"},{"location":"examples/spinhalf_chain_structure_factor/#visualization-script","title":"Visualization script","text":"<p>Postprocessing is here split into two parts:</p> <ol> <li> <p>Compute the poles/weights of the spectral function. The \\(m\\)-th pole appears at frequency \\(\\omega = \\epsilon_m -E_0\\) with the associated weights given by the norm of \\(|\\tilde{\\Psi}_0\\rangle\\) and the projection \\(w_m=\\langle \\tilde{\\Psi}_1|\\psi_m\\rangle\\). The latter is obtained from the first eigenvector of the tridiagonal matrix.</p> </li> <li> <p>Spread out the poles and weights using a Gaussian kernel of width \\(\\eta\\) onto some frequency interval, artificially broadening the \\(\\delta\\)-functions.</p> </li> </ol> Julia <pre><code>   using XDiag\n   using LinearAlgebra\n   using HDF5\n   using Plots\n\n   function plot_sf(outfile::String, omegas::Vector{Float64}, eta::Float64 = 0.15)\n       alls = Matrix{Float64}(undef, 16, length(omegas))\n       for k in 0:15\n           p, w = poles_weights(outfile, k)\n           s = spectrum(p, w, omegas, eta)\n           alls[k+1, :] = s\n       end\n       return heatmap(collect(range(0, 15, step=1)), omegas, alls',\n           xlabel=\"\\$k\\$\", ylabel=\"\\$\\\\omega\\$\",\n           interpolation=:false)\n   end\n\n   function poles_weights(outfile::String, k::Int64)\n       e0 = h5read(outfile, \"/e0\")\n       nrm, alphas, betas, eigs = h5read.((outfile,), [\"/$k/norm\", \"/$k/alphas\", \"/$k/betas\", \"/$k/eigs\"])\n       tmat = SymTridiagonal(alphas, betas)\n       es, evecs = eigen(tmat)\n       # es == eigs\n\n       poles = es .- e0\n       weights = evecs[1, :] .^ 2 .* nrm^2\n       return poles, weights\n   end\n\n   function spectrum(poles::Vector{Float64}, weights::Vector{Float64},\n       omegas::Vector{Float64}, eta::Float64=0.1; cutoff::Float64=0.0, filter::Float64=1e-6)\n       fpoles = [poles[i] for i in 1:length(weights) if abs(weights[i]) &gt; filter]\n       fweights = [weights[i] for i in 1:length(weights) if abs(weights[i]) &gt; filter]\n       diffs = omegas .- fpoles'\n       gaussians = exp.(-(diffs ./ (2.0 * eta)) .^ 2.0) ./ (eta * sqrt(2.0 * pi))\n       if abs(cutoff) &gt; 1e-12\n           idxs = findall(abs.(fpoles) .&gt; cutoff)\n           s = zeros(length(omegas))\n           for idx in idxs\n               s += gaussians[:, idx] * fweights[idx]\n           end\n           return s\n       else\n           return gaussians * fweights\n       end\n   end\n\n   let\n       source = \"../../misc/data/examples_output/spinhalf_chain_structure_factor.h5\"\n       omegas = collect(range(0.0, 3.0, length=1000))\n       eta = 10 * (omegas[2] - omegas[1])\n       fig = plot_sf(source, omegas, eta)\n       savefig(fig, \"spekt.pdf\")\n   end\n</code></pre>"},{"location":"examples/spinhalf_chain_structure_factor/#references","title":"references","text":"<p>[1]  Prelov\u0161ek, P., &amp; Bon\u010da, J. (2013). Ground state and finite temperature Lanczos methods. Strongly Correlated Systems: Numerical Methods, 1-30.</p>"},{"location":"examples/square_J1_J2-WilsonRatio/","title":"Square lattice \\(J_1-J_2\\) model Wilson ratio","text":"<p>Author Siddhartha Sarkar</p> <p>The \\(J_1-J_2\\) model on a square lattice consists of Heisenberg couplings between nearest neighbors and next nearest neighbors with coupling constants \\(J_1\\) and \\(J_2\\), respectively. The Hamiltonian has the form</p> \\[ \\mathcal{H} = J_1 \\sum_{\\langle i,j \\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j + J_2 \\sum_{\\langle\\langle i,j \\rangle\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>The spectrum of this model for a \\(C_4\\) symmetric \\(N=32\\) site system is shown below</p> <p></p> <p>For small values of \\(J_2/J_1 \\lessapprox 0.5\\), the ground state of this model has N\u00e9el order, whereas for large values of \\(J_2/J_1 \\gtrapprox 0.8\\), the ground state has stripe order [2].</p> <p>The following code was used to obtain the spectrum</p> C++ <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nint main(int argc, char **argv) {\n  using namespace xdiag;\n  using namespace arma;\n  using fmt::format;\n\n  say_hello();\n\n  // Parse input arguments\n  assert(argc == 7);\n  int n_sites = atoi(argv[1]);              // number of sites\n  int n_up = atoi(argv[2]);                 // number of upspins\n  std::string kname = std::string(argv[3]); // momentum k\n  double J1 = atof(argv[4]);\n  double J2 = atof(argv[5]);\n  int seed = atoi(argv[6]);\n\n  Log(\"Diagonalizing H in block nup: {}, k: {}\", n_up, kname);\n  Log(\"square.{}.J1J2.fsl.pbc.toml\", n_sites);\n\n\n  auto lfile = FileToml(format(\"square.{}.J1J2.fsl.pbc.toml\", n_sites));\n  std::string ofilename = format(\n      \"outfile.square.{}.J1J2.{:.2f}.nup.{}.k.{}.seed.{}.h5\",\n      n_sites, J1, n_up, kname, seed);\n  auto ofile = FileH5(ofilename, \"w!\");\n\n  xdiag::OpSum ops = read_opsum(lfile, \"Interactions\");\n  ops[\"J1\"] = J1;\n  ops[\"J2\"] = J2;\n  auto irrep = read_representation(lfile, kname);\n\n  Log(\"Creating block ...\");\n  tic();\n  auto block = Spinhalf(n_sites, n_up, irrep);\n  toc();\n  Log(\"Dimension: {}\", block.size());\n\n  Log(\"Running Lanczos ...\");\n  tic();\n  int n_eig_to_converge = 2;\n  int max_iterations = 40;\n  auto tmat = eigvals_lanczos(ops, block, n_eig_to_converge, 1e-12,\n                              max_iterations, 1e-7, seed);\n  toc();\n\n  ofile[\"Alphas\"] = tmat.alphas;\n  ofile[\"Betas\"] = tmat.betas;\n  ofile[\"Eigenvalues\"] = tmat.eigenvalues;\n  ofile[\"Dimension\"] = block.size();\n\n  return EXIT_SUCCESS;\n}\n</code></pre> <p>The interactions terms and the symmetry representation inputs are given in the following TOML file:</p> toml <pre><code># This modelfile was created with the following properties:\n# Basis coordinates: (0.0, 0.0)\n# Lattice vectors: a1=(1.0, 0.0), a2=(0.0, 1.0)\n# Simulation torus vectors: t1=(4, 4), t2=(4, -4)\n# Simulation torus matrix: ((4, 4), (4, -4))\n# Symmetry center: (0.0, 0.0)\n# Lattice Point Group: D4\n# Lattice Space Group (infinite Lattice): D4\n# K points (K wedge marked with *):\n# [3.141592653589793 3.141592653589793] *\n# [3.141592653589793 1.5707963267948966] *\n# [3.141592653589793 0.0] *\n# [3.141592653589793 -1.5707963267948966] *\n# [2.356194490192345 2.356194490192345] *\n# [2.356194490192345 0.7853981633974483] *\n# [2.356194490192345 -0.7853981633974483] *\n# [2.356194490192345 -2.356194490192345]\n# [1.5707963267948966 3.141592653589793]\n# [1.5707963267948966 1.5707963267948966] *\n# [1.5707963267948966 0.0] *\n# [1.5707963267948966 -1.5707963267948966]\n# [0.7853981633974483 2.356194490192345]\n# [0.7853981633974483 0.7853981633974483] *\n# [0.7853981633974483 -0.7853981633974483]\n# [0.7853981633974483 -2.356194490192345]\n# [0.0 3.141592653589793]\n# [0.0 1.5707963267948966]\n# [0.0 0.0] *\n# [0.0 -1.5707963267948966]\n# [-0.7853981633974483 2.356194490192345]\n# [-0.7853981633974483 0.7853981633974483]\n# [-0.7853981633974483 -0.7853981633974483]\n# [-0.7853981633974483 -2.356194490192345]\n# [-1.5707963267948966 3.141592653589793]\n# [-1.5707963267948966 1.5707963267948966]\n# [-1.5707963267948966 0.0]\n# [-1.5707963267948966 -1.5707963267948966]\n# [-2.356194490192345 2.356194490192345]\n# [-2.356194490192345 0.7853981633974483]\n# [-2.356194490192345 -0.7853981633974483]\n# [-2.356194490192345 -2.356194490192345]\n# High Symmetry Points: M.C4, Z_0.C1, X.C2, Z_1.C1, Sigma_0.C1, None_0.C1, None_1.C1, Sigma_1.C1, Delta.C1, Sigma_2.C1, Gamma.C4,\n# Eccentricity: --\n\nCoordinates = [\n  [0.0, 0.0],\n  [2.0, -2.0],\n  [2.0, 0.0],\n  [2.0, 2.0],\n  [4.0, -2.0],\n  [4.0, 0.0],\n  [4.0, 2.0],\n  [6.0, 0.0],\n  [1.0, 0.0],\n  [3.0, -2.0],\n  [3.0, 0.0],\n  [3.0, 2.0],\n  [5.0, -2.0],\n  [5.0, 0.0],\n  [5.0, 2.0],\n  [7.0, 0.0],\n  [2.0, -1.0],\n  [2.0, 1.0],\n  [4.0, -3.0],\n  [4.0, -1.0],\n  [4.0, 1.0],\n  [4.0, 3.0],\n  [6.0, -1.0],\n  [6.0, 1.0],\n  [1.0, -1.0],\n  [1.0, 1.0],\n  [3.0, -3.0],\n  [3.0, -1.0],\n  [3.0, 1.0],\n  [3.0, 3.0],\n  [5.0, -1.0],\n  [5.0, 1.0]\n]\n\nInteractions = [\n  ['J1', 'SdotS', 0, 18],\n  ['J1', 'SdotS', 8, 25],\n  ['J1', 'SdotS', 25, 12],\n  ['J1', 'SdotS', 24, 8],\n  ['J1', 'SdotS', 2, 17],\n  ['J1', 'SdotS', 17, 3],\n  ['J1', 'SdotS', 3, 22],\n  ['J1', 'SdotS', 1, 16],\n  ['J1', 'SdotS', 16, 2],\n  ['J1', 'SdotS', 10, 28],\n  ['J1', 'SdotS', 28, 11],\n  ['J1', 'SdotS', 11, 29],\n  ['J1', 'SdotS', 29, 15],\n  ['J1', 'SdotS', 26, 9],\n  ['J1', 'SdotS', 9, 27],\n  ['J1', 'SdotS', 27, 10],\n  ['J1', 'SdotS', 5, 20],\n  ['J1', 'SdotS', 20, 6],\n  ['J1', 'SdotS', 6, 21],\n  ['J1', 'SdotS', 21, 0],\n  ['J1', 'SdotS', 18, 4],\n  ['J1', 'SdotS', 4, 19],\n  ['J1', 'SdotS', 19, 5],\n  ['J1', 'SdotS', 13, 31],\n  ['J1', 'SdotS', 31, 14],\n  ['J1', 'SdotS', 14, 24],\n  ['J1', 'SdotS', 12, 30],\n  ['J1', 'SdotS', 30, 13],\n  ['J1', 'SdotS', 7, 23],\n  ['J1', 'SdotS', 23, 1],\n  ['J1', 'SdotS', 22, 7],\n  ['J1', 'SdotS', 15, 26],\n  ['J1', 'SdotS', 0, 8],\n  ['J1', 'SdotS', 8, 2],\n  ['J1', 'SdotS', 25, 17],\n  ['J1', 'SdotS', 24, 16],\n  ['J1', 'SdotS', 2, 10],\n  ['J1', 'SdotS', 17, 28],\n  ['J1', 'SdotS', 3, 11],\n  ['J1', 'SdotS', 1, 9],\n  ['J1', 'SdotS', 16, 27],\n  ['J1', 'SdotS', 10, 5],\n  ['J1', 'SdotS', 28, 20],\n  ['J1', 'SdotS', 11, 6],\n  ['J1', 'SdotS', 29, 21],\n  ['J1', 'SdotS', 26, 18],\n  ['J1', 'SdotS', 9, 4],\n  ['J1', 'SdotS', 27, 19],\n  ['J1', 'SdotS', 5, 13],\n  ['J1', 'SdotS', 20, 31],\n  ['J1', 'SdotS', 6, 14],\n  ['J1', 'SdotS', 21, 24],\n  ['J1', 'SdotS', 18, 25],\n  ['J1', 'SdotS', 4, 12],\n  ['J1', 'SdotS', 19, 30],\n  ['J1', 'SdotS', 13, 7],\n  ['J1', 'SdotS', 31, 23],\n  ['J1', 'SdotS', 14, 1],\n  ['J1', 'SdotS', 12, 3],\n  ['J1', 'SdotS', 30, 22],\n  ['J1', 'SdotS', 7, 15],\n  ['J1', 'SdotS', 23, 26],\n  ['J1', 'SdotS', 22, 29],\n  ['J1', 'SdotS', 15, 0],\n  ['J2', 'SdotS', 0, 25],\n  ['J2', 'SdotS', 8, 17],\n  ['J2', 'SdotS', 25, 3],\n  ['J2', 'SdotS', 24, 2],\n  ['J2', 'SdotS', 2, 28],\n  ['J2', 'SdotS', 17, 11],\n  ['J2', 'SdotS', 3, 29],\n  ['J2', 'SdotS', 1, 27],\n  ['J2', 'SdotS', 16, 10],\n  ['J2', 'SdotS', 10, 20],\n  ['J2', 'SdotS', 28, 6],\n  ['J2', 'SdotS', 11, 21],\n  ['J2', 'SdotS', 29, 0],\n  ['J2', 'SdotS', 26, 4],\n  ['J2', 'SdotS', 9, 19],\n  ['J2', 'SdotS', 27, 5],\n  ['J2', 'SdotS', 5, 31],\n  ['J2', 'SdotS', 20, 14],\n  ['J2', 'SdotS', 6, 24],\n  ['J2', 'SdotS', 21, 8],\n  ['J2', 'SdotS', 18, 12],\n  ['J2', 'SdotS', 4, 30],\n  ['J2', 'SdotS', 19, 13],\n  ['J2', 'SdotS', 13, 23],\n  ['J2', 'SdotS', 31, 1],\n  ['J2', 'SdotS', 14, 16],\n  ['J2', 'SdotS', 12, 22],\n  ['J2', 'SdotS', 30, 7],\n  ['J2', 'SdotS', 7, 26],\n  ['J2', 'SdotS', 23, 9],\n  ['J2', 'SdotS', 22, 15],\n  ['J2', 'SdotS', 15, 18],\n  ['J2', 'SdotS', 0, 24],\n  ['J2', 'SdotS', 8, 16],\n  ['J2', 'SdotS', 25, 2],\n  ['J2', 'SdotS', 24, 1],\n  ['J2', 'SdotS', 2, 27],\n  ['J2', 'SdotS', 17, 10],\n  ['J2', 'SdotS', 3, 28],\n  ['J2', 'SdotS', 1, 26],\n  ['J2', 'SdotS', 16, 9],\n  ['J2', 'SdotS', 10, 19],\n  ['J2', 'SdotS', 28, 5],\n  ['J2', 'SdotS', 11, 20],\n  ['J2', 'SdotS', 29, 6],\n  ['J2', 'SdotS', 26, 0],\n  ['J2', 'SdotS', 9, 18],\n  ['J2', 'SdotS', 27, 4],\n  ['J2', 'SdotS', 5, 30],\n  ['J2', 'SdotS', 20, 13],\n  ['J2', 'SdotS', 6, 31],\n  ['J2', 'SdotS', 21, 14],\n  ['J2', 'SdotS', 18, 8],\n  ['J2', 'SdotS', 4, 25],\n  ['J2', 'SdotS', 19, 12],\n  ['J2', 'SdotS', 13, 22],\n  ['J2', 'SdotS', 31, 7],\n  ['J2', 'SdotS', 14, 23],\n  ['J2', 'SdotS', 12, 17],\n  ['J2', 'SdotS', 30, 3],\n  ['J2', 'SdotS', 7, 29],\n  ['J2', 'SdotS', 23, 15],\n  ['J2', 'SdotS', 22, 11],\n  ['J2', 'SdotS', 15, 21]\n]\n\nSymmetries = [\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],\n  [1, 0, 4, 5, 2, 3, 7, 6, 9, 8, 12, 13, 10, 11, 15, 14, 18, 19, 16, 17, 22, 23, 20, 21, 26, 27, 24, 25, 30, 31, 28, 29],\n  [2, 4, 5, 6, 3, 7, 1, 0, 10, 12, 13, 14, 11, 15, 9, 8, 19, 20, 17, 22, 23, 16, 21, 18, 27, 28, 25, 30, 31, 24, 29, 26],\n  [3, 5, 6, 0, 7, 1, 2, 4, 11, 13, 14, 8, 15, 9, 10, 12, 20, 21, 22, 23, 16, 17, 18, 19, 28, 29, 30, 31, 24, 25, 26, 27],\n  [4, 2, 3, 7, 5, 6, 0, 1, 12, 10, 11, 15, 13, 14, 8, 9, 17, 22, 19, 20, 21, 18, 23, 16, 25, 30, 27, 28, 29, 26, 31, 24],\n  [5, 3, 7, 1, 6, 0, 4, 2, 13, 11, 15, 9, 14, 8, 12, 10, 22, 23, 20, 21, 18, 19, 16, 17, 30, 31, 28, 29, 26, 27, 24, 25],\n  [6, 7, 1, 2, 0, 4, 5, 3, 14, 15, 9, 10, 8, 12, 13, 11, 23, 16, 21, 18, 19, 20, 17, 22, 31, 24, 29, 26, 27, 28, 25, 30],\n  [7, 6, 0, 4, 1, 2, 3, 5, 15, 14, 8, 12, 9, 10, 11, 13, 21, 18, 23, 16, 17, 22, 19, 20, 29, 26, 31, 24, 25, 30, 27, 28],\n  [0, 3, 4, 1, 7, 5, 2, 6, 18, 22, 19, 16, 23, 20, 17, 21, 12, 9, 15, 13, 10, 8, 14, 11, 25, 26, 29, 30, 27, 24, 31, 28],\n  [1, 5, 2, 0, 6, 3, 4, 7, 16, 20, 17, 18, 21, 22, 19, 23, 10, 8, 14, 11, 12, 9, 15, 13, 27, 24, 31, 28, 25, 26, 29, 30],\n  [2, 6, 3, 4, 0, 7, 5, 1, 17, 21, 22, 19, 18, 23, 20, 16, 11, 12, 8, 15, 13, 10, 9, 14, 28, 25, 24, 29, 30, 27, 26, 31],\n  [3, 0, 7, 5, 4, 1, 6, 2, 22, 18, 23, 20, 19, 16, 21, 17, 15, 13, 12, 9, 14, 11, 10, 8, 29, 30, 25, 26, 31, 28, 27, 24],\n  [4, 7, 5, 2, 1, 6, 3, 0, 19, 23, 20, 17, 16, 21, 22, 18, 13, 10, 9, 14, 11, 12, 8, 15, 30, 27, 26, 31, 28, 25, 24, 29],\n  [5, 1, 6, 3, 2, 0, 7, 4, 20, 16, 21, 22, 17, 18, 23, 19, 14, 11, 10, 8, 15, 13, 12, 9, 31, 28, 27, 24, 29, 30, 25, 26],\n  [6, 2, 0, 7, 3, 4, 1, 5, 21, 17, 18, 23, 22, 19, 16, 20, 8, 15, 11, 12, 9, 14, 13, 10, 24, 29, 28, 25, 26, 31, 30, 27],\n  [7, 4, 1, 6, 5, 2, 0, 3, 23, 19, 16, 21, 20, 17, 18, 22, 9, 14, 13, 10, 8, 15, 11, 12, 26, 31, 30, 27, 24, 29, 28, 25],\n  [0, 1, 7, 3, 6, 5, 4, 2, 15, 14, 13, 12, 11, 10, 9, 8, 23, 22, 21, 20, 19, 18, 17, 16, 26, 29, 24, 31, 30, 25, 28, 27],\n  [1, 0, 6, 5, 7, 3, 2, 4, 14, 15, 11, 10, 13, 12, 8, 9, 21, 20, 23, 22, 17, 16, 19, 18, 24, 31, 26, 29, 28, 27, 30, 25],\n  [2, 4, 0, 6, 1, 7, 3, 5, 8, 9, 15, 11, 14, 13, 12, 10, 18, 21, 16, 23, 22, 17, 20, 19, 25, 24, 27, 26, 29, 28, 31, 30],\n  [3, 5, 4, 0, 2, 1, 7, 6, 12, 10, 9, 15, 8, 14, 13, 11, 19, 18, 17, 16, 23, 22, 21, 20, 30, 25, 28, 27, 26, 29, 24, 31],\n  [4, 2, 1, 7, 0, 6, 5, 3, 9, 8, 14, 13, 15, 11, 10, 12, 16, 23, 18, 21, 20, 19, 22, 17, 27, 26, 25, 24, 31, 30, 29, 28],\n  [5, 3, 2, 1, 4, 0, 6, 7, 10, 12, 8, 14, 9, 15, 11, 13, 17, 16, 19, 18, 21, 20, 23, 22, 28, 27, 30, 25, 24, 31, 26, 29],\n  [6, 7, 3, 2, 5, 4, 0, 1, 11, 13, 12, 8, 10, 9, 15, 14, 22, 17, 20, 19, 18, 21, 16, 23, 29, 28, 31, 30, 25, 24, 27, 26],\n  [7, 6, 5, 4, 3, 2, 1, 0, 13, 11, 10, 9, 12, 8, 14, 15, 20, 19, 22, 17, 16, 23, 18, 21, 31, 30, 29, 28, 27, 26, 25, 24],\n  [0, 3, 6, 1, 2, 5, 7, 4, 21, 17, 20, 23, 16, 19, 22, 18, 11, 14, 8, 10, 13, 15, 9, 12, 29, 24, 25, 28, 31, 26, 27, 30],\n  [1, 5, 7, 0, 4, 3, 6, 2, 23, 19, 22, 21, 18, 17, 20, 16, 13, 15, 9, 12, 11, 14, 8, 10, 31, 26, 27, 30, 29, 24, 25, 28],\n  [2, 6, 1, 4, 5, 7, 0, 3, 16, 20, 23, 18, 19, 22, 21, 17, 14, 9, 10, 13, 15, 8, 12, 11, 24, 27, 28, 31, 26, 25, 30, 29],\n  [3, 0, 2, 5, 6, 1, 4, 7, 17, 21, 16, 19, 20, 23, 18, 22, 8, 10, 11, 14, 9, 12, 13, 15, 25, 28, 29, 24, 27, 30, 31, 26],\n  [4, 7, 0, 2, 3, 6, 1, 5, 18, 22, 21, 16, 17, 20, 23, 19, 15, 8, 12, 11, 14, 9, 10, 13, 26, 25, 30, 29, 24, 27, 28, 31],\n  [5, 1, 4, 3, 7, 0, 2, 6, 19, 23, 18, 17, 22, 21, 16, 20, 9, 12, 13, 15, 8, 10, 11, 14, 27, 30, 31, 26, 25, 28, 29, 24],\n  [6, 2, 5, 7, 1, 4, 3, 0, 20, 16, 19, 22, 23, 18, 17, 21, 10, 13, 14, 9, 12, 11, 15, 8, 28, 31, 24, 27, 30, 29, 26, 25],\n  [7, 4, 3, 6, 0, 2, 5, 1, 22, 18, 17, 20, 21, 16, 19, 23, 12, 11, 15, 8, 10, 13, 14, 9, 30, 29, 26, 25, 28, 31, 24, 27],\n  [8, 9, 10, 11, 12, 13, 14, 15, 2, 4, 5, 6, 3, 7, 1, 0, 27, 28, 25, 30, 31, 24, 29, 26, 16, 17, 18, 19, 20, 21, 22, 23],\n  [9, 8, 12, 13, 10, 11, 15, 14, 4, 2, 3, 7, 5, 6, 0, 1, 25, 30, 27, 28, 29, 26, 31, 24, 18, 19, 16, 17, 22, 23, 20, 21],\n  [10, 12, 13, 14, 11, 15, 9, 8, 5, 3, 7, 1, 6, 0, 4, 2, 30, 31, 28, 29, 26, 27, 24, 25, 19, 20, 17, 22, 23, 16, 21, 18],\n  [11, 13, 14, 8, 15, 9, 10, 12, 6, 7, 1, 2, 0, 4, 5, 3, 31, 24, 29, 26, 27, 28, 25, 30, 20, 21, 22, 23, 16, 17, 18, 19],\n  [12, 10, 11, 15, 13, 14, 8, 9, 3, 5, 6, 0, 7, 1, 2, 4, 28, 29, 30, 31, 24, 25, 26, 27, 17, 22, 19, 20, 21, 18, 23, 16],\n  [13, 11, 15, 9, 14, 8, 12, 10, 7, 6, 0, 4, 1, 2, 3, 5, 29, 26, 31, 24, 25, 30, 27, 28, 22, 23, 20, 21, 18, 19, 16, 17],\n  [14, 15, 9, 10, 8, 12, 13, 11, 1, 0, 4, 5, 2, 3, 7, 6, 26, 27, 24, 25, 30, 31, 28, 29, 23, 16, 21, 18, 19, 20, 17, 22],\n  [15, 14, 8, 12, 9, 10, 11, 13, 0, 1, 2, 3, 4, 5, 6, 7, 24, 25, 26, 27, 28, 29, 30, 31, 21, 18, 23, 16, 17, 22, 19, 20],\n  [16, 20, 17, 18, 21, 22, 19, 23, 2, 6, 3, 4, 0, 7, 5, 1, 28, 25, 24, 29, 30, 27, 26, 31, 10, 8, 14, 11, 12, 9, 15, 13],\n  [17, 21, 22, 19, 18, 23, 20, 16, 3, 0, 7, 5, 4, 1, 6, 2, 29, 30, 25, 26, 31, 28, 27, 24, 11, 12, 8, 15, 13, 10, 9, 14],\n  [18, 22, 19, 16, 23, 20, 17, 21, 4, 7, 5, 2, 1, 6, 3, 0, 30, 27, 26, 31, 28, 25, 24, 29, 12, 9, 15, 13, 10, 8, 14, 11],\n  [19, 23, 20, 17, 16, 21, 22, 18, 5, 1, 6, 3, 2, 0, 7, 4, 31, 28, 27, 24, 29, 30, 25, 26, 13, 10, 9, 14, 11, 12, 8, 15],\n  [20, 16, 21, 22, 17, 18, 23, 19, 6, 2, 0, 7, 3, 4, 1, 5, 24, 29, 28, 25, 26, 31, 30, 27, 14, 11, 10, 8, 15, 13, 12, 9],\n  [21, 17, 18, 23, 22, 19, 16, 20, 0, 3, 4, 1, 7, 5, 2, 6, 25, 26, 29, 30, 27, 24, 31, 28, 8, 15, 11, 12, 9, 14, 13, 10],\n  [22, 18, 23, 20, 19, 16, 21, 17, 7, 4, 1, 6, 5, 2, 0, 3, 26, 31, 30, 27, 24, 29, 28, 25, 15, 13, 12, 9, 14, 11, 10, 8],\n  [23, 19, 16, 21, 20, 17, 18, 22, 1, 5, 2, 0, 6, 3, 4, 7, 27, 24, 31, 28, 25, 26, 29, 30, 9, 14, 13, 10, 8, 15, 11, 12],\n  [8, 9, 15, 11, 14, 13, 12, 10, 0, 1, 7, 3, 6, 5, 4, 2, 26, 29, 24, 31, 30, 25, 28, 27, 18, 21, 16, 23, 22, 17, 20, 19],\n  [9, 8, 14, 13, 15, 11, 10, 12, 1, 0, 6, 5, 7, 3, 2, 4, 24, 31, 26, 29, 28, 27, 30, 25, 16, 23, 18, 21, 20, 19, 22, 17],\n  [10, 12, 8, 14, 9, 15, 11, 13, 2, 4, 0, 6, 1, 7, 3, 5, 25, 24, 27, 26, 29, 28, 31, 30, 17, 16, 19, 18, 21, 20, 23, 22],\n  [11, 13, 12, 8, 10, 9, 15, 14, 3, 5, 4, 0, 2, 1, 7, 6, 30, 25, 28, 27, 26, 29, 24, 31, 22, 17, 20, 19, 18, 21, 16, 23],\n  [12, 10, 9, 15, 8, 14, 13, 11, 4, 2, 1, 7, 0, 6, 5, 3, 27, 26, 25, 24, 31, 30, 29, 28, 19, 18, 17, 16, 23, 22, 21, 20],\n  [13, 11, 10, 9, 12, 8, 14, 15, 5, 3, 2, 1, 4, 0, 6, 7, 28, 27, 30, 25, 24, 31, 26, 29, 20, 19, 22, 17, 16, 23, 18, 21],\n  [14, 15, 11, 10, 13, 12, 8, 9, 6, 7, 3, 2, 5, 4, 0, 1, 29, 28, 31, 30, 25, 24, 27, 26, 21, 20, 23, 22, 17, 16, 19, 18],\n  [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16],\n  [16, 20, 23, 18, 19, 22, 21, 17, 1, 5, 7, 0, 4, 3, 6, 2, 31, 26, 27, 30, 29, 24, 25, 28, 14, 9, 10, 13, 15, 8, 12, 11],\n  [17, 21, 16, 19, 20, 23, 18, 22, 2, 6, 1, 4, 5, 7, 0, 3, 24, 27, 28, 31, 26, 25, 30, 29, 8, 10, 11, 14, 9, 12, 13, 15],\n  [18, 22, 21, 16, 17, 20, 23, 19, 0, 3, 6, 1, 2, 5, 7, 4, 29, 24, 25, 28, 31, 26, 27, 30, 15, 8, 12, 11, 14, 9, 10, 13],\n  [19, 23, 18, 17, 22, 21, 16, 20, 4, 7, 0, 2, 3, 6, 1, 5, 26, 25, 30, 29, 24, 27, 28, 31, 9, 12, 13, 15, 8, 10, 11, 14],\n  [20, 16, 19, 22, 23, 18, 17, 21, 5, 1, 4, 3, 7, 0, 2, 6, 27, 30, 31, 26, 25, 28, 29, 24, 10, 13, 14, 9, 12, 11, 15, 8],\n  [21, 17, 20, 23, 16, 19, 22, 18, 6, 2, 5, 7, 1, 4, 3, 0, 28, 31, 24, 27, 30, 29, 26, 25, 11, 14, 8, 10, 13, 15, 9, 12],\n  [22, 18, 17, 20, 21, 16, 19, 23, 3, 0, 2, 5, 6, 1, 4, 7, 25, 28, 29, 24, 27, 30, 31, 26, 12, 11, 15, 8, 10, 13, 14, 9],\n  [23, 19, 22, 21, 18, 17, 20, 16, 7, 4, 3, 6, 0, 2, 5, 1, 30, 29, 26, 25, 28, 31, 24, 27, 13, 15, 9, 12, 11, 14, 8, 10],\n  [16, 18, 19, 20, 17, 22, 23, 21, 27, 25, 30, 31, 28, 29, 26, 24, 4, 5, 2, 3, 7, 1, 6, 0, 9, 10, 8, 12, 13, 14, 11, 15],\n  [17, 19, 20, 21, 22, 23, 16, 18, 28, 30, 31, 24, 29, 26, 27, 25, 5, 6, 3, 7, 1, 2, 0, 4, 10, 11, 12, 13, 14, 8, 15, 9],\n  [18, 16, 17, 22, 19, 20, 21, 23, 25, 27, 28, 29, 30, 31, 24, 26, 2, 3, 4, 5, 6, 0, 7, 1, 8, 12, 9, 10, 11, 15, 13, 14],\n  [19, 17, 22, 23, 20, 21, 18, 16, 30, 28, 29, 26, 31, 24, 25, 27, 3, 7, 5, 6, 0, 4, 1, 2, 12, 13, 10, 11, 15, 9, 14, 8],\n  [20, 22, 23, 16, 21, 18, 19, 17, 31, 29, 26, 27, 24, 25, 30, 28, 7, 1, 6, 0, 4, 5, 2, 3, 13, 14, 11, 15, 9, 10, 8, 12],\n  [21, 23, 16, 17, 18, 19, 20, 22, 24, 26, 27, 28, 25, 30, 31, 29, 1, 2, 0, 4, 5, 6, 3, 7, 14, 8, 15, 9, 10, 11, 12, 13],\n  [22, 20, 21, 18, 23, 16, 17, 19, 29, 31, 24, 25, 26, 27, 28, 30, 6, 0, 7, 1, 2, 3, 4, 5, 11, 15, 13, 14, 8, 12, 9, 10],\n  [23, 21, 18, 19, 16, 17, 22, 20, 26, 24, 25, 30, 27, 28, 29, 31, 0, 4, 1, 2, 3, 7, 5, 6, 15, 9, 14, 8, 12, 13, 10, 11],\n  [8, 11, 12, 9, 15, 13, 10, 14, 25, 29, 30, 27, 26, 31, 28, 24, 3, 4, 0, 7, 5, 2, 1, 6, 17, 18, 21, 22, 19, 16, 23, 20],\n  [9, 13, 10, 8, 14, 11, 12, 15, 27, 31, 28, 25, 24, 29, 30, 26, 5, 2, 1, 6, 3, 4, 0, 7, 19, 16, 23, 20, 17, 18, 21, 22],\n  [10, 14, 11, 12, 8, 15, 13, 9, 28, 24, 29, 30, 25, 26, 31, 27, 6, 3, 2, 0, 7, 5, 4, 1, 20, 17, 16, 21, 22, 19, 18, 23],\n  [11, 8, 15, 13, 12, 9, 14, 10, 29, 25, 26, 31, 30, 27, 24, 28, 0, 7, 3, 4, 1, 6, 5, 2, 21, 22, 17, 18, 23, 20, 19, 16],\n  [12, 15, 13, 10, 9, 14, 11, 8, 30, 26, 31, 28, 27, 24, 29, 25, 7, 5, 4, 1, 6, 3, 2, 0, 22, 19, 18, 23, 20, 17, 16, 21],\n  [13, 9, 14, 11, 10, 8, 15, 12, 31, 27, 24, 29, 28, 25, 26, 30, 1, 6, 5, 2, 0, 7, 3, 4, 23, 20, 19, 16, 21, 22, 17, 18],\n  [14, 10, 8, 15, 11, 12, 9, 13, 24, 28, 25, 26, 29, 30, 27, 31, 2, 0, 6, 3, 4, 1, 7, 5, 16, 21, 20, 17, 18, 23, 22, 19],\n  [15, 12, 9, 14, 13, 10, 8, 11, 26, 30, 27, 24, 31, 28, 25, 29, 4, 1, 7, 5, 2, 0, 6, 3, 18, 23, 22, 19, 16, 21, 20, 17],\n  [16, 18, 21, 20, 23, 22, 17, 19, 24, 26, 29, 28, 31, 30, 25, 27, 0, 6, 1, 7, 3, 2, 5, 4, 8, 14, 9, 15, 11, 10, 13, 12],\n  [17, 19, 18, 21, 16, 23, 22, 20, 25, 27, 26, 29, 24, 31, 30, 28, 4, 0, 2, 1, 7, 3, 6, 5, 12, 8, 10, 9, 15, 11, 14, 13],\n  [18, 16, 23, 22, 21, 20, 19, 17, 26, 24, 31, 30, 29, 28, 27, 25, 1, 7, 0, 6, 5, 4, 3, 2, 9, 15, 8, 14, 13, 12, 11, 10],\n  [19, 17, 16, 23, 18, 21, 20, 22, 27, 25, 24, 31, 26, 29, 28, 30, 2, 1, 4, 0, 6, 5, 7, 3, 10, 9, 12, 8, 14, 13, 15, 11],\n  [20, 22, 17, 16, 19, 18, 21, 23, 28, 30, 25, 24, 27, 26, 29, 31, 3, 2, 5, 4, 0, 6, 1, 7, 11, 10, 13, 12, 8, 14, 9, 15],\n  [21, 23, 22, 17, 20, 19, 18, 16, 29, 31, 30, 25, 28, 27, 26, 24, 7, 3, 6, 5, 4, 0, 2, 1, 15, 11, 14, 13, 12, 8, 10, 9],\n  [22, 20, 19, 18, 17, 16, 23, 21, 30, 28, 27, 26, 25, 24, 31, 29, 5, 4, 3, 2, 1, 7, 0, 6, 13, 12, 11, 10, 9, 15, 8, 14],\n  [23, 21, 20, 19, 22, 17, 16, 18, 31, 29, 28, 27, 30, 25, 24, 26, 6, 5, 7, 3, 2, 1, 4, 0, 14, 13, 15, 11, 10, 9, 12, 8],\n  [8, 11, 14, 9, 10, 13, 15, 12, 24, 28, 31, 26, 27, 30, 29, 25, 6, 1, 2, 5, 7, 0, 4, 3, 21, 16, 17, 20, 23, 18, 19, 22],\n  [9, 13, 15, 8, 12, 11, 14, 10, 26, 30, 29, 24, 25, 28, 31, 27, 7, 0, 4, 3, 6, 1, 2, 5, 23, 18, 19, 22, 21, 16, 17, 20],\n  [10, 14, 9, 12, 13, 15, 8, 11, 27, 31, 26, 25, 30, 29, 24, 28, 1, 4, 5, 7, 0, 2, 3, 6, 16, 19, 20, 23, 18, 17, 22, 21],\n  [11, 8, 10, 13, 14, 9, 12, 15, 28, 24, 27, 30, 31, 26, 25, 29, 2, 5, 6, 1, 4, 3, 7, 0, 17, 20, 21, 16, 19, 22, 23, 18],\n  [12, 15, 8, 10, 11, 14, 9, 13, 25, 29, 24, 27, 28, 31, 26, 30, 0, 2, 3, 6, 1, 4, 5, 7, 18, 17, 22, 21, 16, 19, 20, 23],\n  [13, 9, 12, 11, 15, 8, 10, 14, 30, 26, 25, 28, 29, 24, 27, 31, 4, 3, 7, 0, 2, 5, 6, 1, 19, 22, 23, 18, 17, 20, 21, 16],\n  [14, 10, 13, 15, 9, 12, 11, 8, 31, 27, 30, 29, 26, 25, 28, 24, 5, 7, 1, 4, 3, 6, 0, 2, 20, 23, 16, 19, 22, 21, 18, 17],\n  [15, 12, 11, 14, 8, 10, 13, 9, 29, 25, 28, 31, 24, 27, 30, 26, 3, 6, 0, 2, 5, 7, 1, 4, 22, 21, 18, 17, 20, 23, 16, 19],\n  [24, 26, 27, 28, 25, 30, 31, 29, 16, 18, 19, 20, 17, 22, 23, 21, 9, 10, 8, 12, 13, 14, 11, 15, 1, 2, 0, 4, 5, 6, 3, 7],\n  [25, 27, 28, 29, 30, 31, 24, 26, 17, 19, 20, 21, 22, 23, 16, 18, 10, 11, 12, 13, 14, 8, 15, 9, 2, 3, 4, 5, 6, 0, 7, 1],\n  [26, 24, 25, 30, 27, 28, 29, 31, 18, 16, 17, 22, 19, 20, 21, 23, 8, 12, 9, 10, 11, 15, 13, 14, 0, 4, 1, 2, 3, 7, 5, 6],\n  [27, 25, 30, 31, 28, 29, 26, 24, 19, 17, 22, 23, 20, 21, 18, 16, 12, 13, 10, 11, 15, 9, 14, 8, 4, 5, 2, 3, 7, 1, 6, 0],\n  [28, 30, 31, 24, 29, 26, 27, 25, 20, 22, 23, 16, 21, 18, 19, 17, 13, 14, 11, 15, 9, 10, 8, 12, 5, 6, 3, 7, 1, 2, 0, 4],\n  [29, 31, 24, 25, 26, 27, 28, 30, 21, 23, 16, 17, 18, 19, 20, 22, 14, 8, 15, 9, 10, 11, 12, 13, 6, 0, 7, 1, 2, 3, 4, 5],\n  [30, 28, 29, 26, 31, 24, 25, 27, 22, 20, 21, 18, 23, 16, 17, 19, 11, 15, 13, 14, 8, 12, 9, 10, 3, 7, 5, 6, 0, 4, 1, 2],\n  [31, 29, 26, 27, 24, 25, 30, 28, 23, 21, 18, 19, 16, 17, 22, 20, 15, 9, 14, 8, 12, 13, 10, 11, 7, 1, 6, 0, 4, 5, 2, 3],\n  [24, 28, 25, 26, 29, 30, 27, 31, 8, 11, 12, 9, 15, 13, 10, 14, 17, 18, 21, 22, 19, 16, 23, 20, 2, 0, 6, 3, 4, 1, 7, 5],\n  [25, 29, 30, 27, 26, 31, 28, 24, 12, 15, 13, 10, 9, 14, 11, 8, 22, 19, 18, 23, 20, 17, 16, 21, 3, 4, 0, 7, 5, 2, 1, 6],\n  [26, 30, 27, 24, 31, 28, 25, 29, 9, 13, 10, 8, 14, 11, 12, 15, 19, 16, 23, 20, 17, 18, 21, 22, 4, 1, 7, 5, 2, 0, 6, 3],\n  [27, 31, 28, 25, 24, 29, 30, 26, 10, 14, 11, 12, 8, 15, 13, 9, 20, 17, 16, 21, 22, 19, 18, 23, 5, 2, 1, 6, 3, 4, 0, 7],\n  [28, 24, 29, 30, 25, 26, 31, 27, 11, 8, 15, 13, 12, 9, 14, 10, 21, 22, 17, 18, 23, 20, 19, 16, 6, 3, 2, 0, 7, 5, 4, 1],\n  [29, 25, 26, 31, 30, 27, 24, 28, 15, 12, 9, 14, 13, 10, 8, 11, 18, 23, 22, 19, 16, 21, 20, 17, 0, 7, 3, 4, 1, 6, 5, 2],\n  [30, 26, 31, 28, 27, 24, 29, 25, 13, 9, 14, 11, 10, 8, 15, 12, 23, 20, 19, 16, 21, 22, 17, 18, 7, 5, 4, 1, 6, 3, 2, 0],\n  [31, 27, 24, 29, 28, 25, 26, 30, 14, 10, 8, 15, 11, 12, 9, 13, 16, 21, 20, 17, 18, 23, 22, 19, 1, 6, 5, 2, 0, 7, 3, 4],\n  [24, 26, 29, 28, 31, 30, 25, 27, 21, 23, 22, 17, 20, 19, 18, 16, 15, 11, 14, 13, 12, 8, 10, 9, 0, 6, 1, 7, 3, 2, 5, 4],\n  [25, 27, 26, 29, 24, 31, 30, 28, 18, 16, 23, 22, 21, 20, 19, 17, 9, 15, 8, 14, 13, 12, 11, 10, 4, 0, 2, 1, 7, 3, 6, 5],\n  [26, 24, 31, 30, 29, 28, 27, 25, 23, 21, 20, 19, 22, 17, 16, 18, 14, 13, 15, 11, 10, 9, 12, 8, 1, 7, 0, 6, 5, 4, 3, 2],\n  [27, 25, 24, 31, 26, 29, 28, 30, 16, 18, 21, 20, 23, 22, 17, 19, 8, 14, 9, 15, 11, 10, 13, 12, 2, 1, 4, 0, 6, 5, 7, 3],\n  [28, 30, 25, 24, 27, 26, 29, 31, 17, 19, 18, 21, 16, 23, 22, 20, 12, 8, 10, 9, 15, 11, 14, 13, 3, 2, 5, 4, 0, 6, 1, 7],\n  [29, 31, 30, 25, 28, 27, 26, 24, 22, 20, 19, 18, 17, 16, 23, 21, 13, 12, 11, 10, 9, 15, 8, 14, 7, 3, 6, 5, 4, 0, 2, 1],\n  [30, 28, 27, 26, 25, 24, 31, 29, 19, 17, 16, 23, 18, 21, 20, 22, 10, 9, 12, 8, 14, 13, 15, 11, 5, 4, 3, 2, 1, 7, 0, 6],\n  [31, 29, 28, 27, 30, 25, 24, 26, 20, 22, 17, 16, 19, 18, 21, 23, 11, 10, 13, 12, 8, 14, 9, 15, 6, 5, 7, 3, 2, 1, 4, 0],\n  [24, 28, 31, 26, 27, 30, 29, 25, 14, 10, 13, 15, 9, 12, 11, 8, 20, 23, 16, 19, 22, 21, 18, 17, 6, 1, 2, 5, 7, 0, 4, 3],\n  [25, 29, 24, 27, 28, 31, 26, 30, 8, 11, 14, 9, 10, 13, 15, 12, 21, 16, 17, 20, 23, 18, 19, 22, 0, 2, 3, 6, 1, 4, 5, 7],\n  [26, 30, 29, 24, 25, 28, 31, 27, 15, 12, 11, 14, 8, 10, 13, 9, 22, 21, 18, 17, 20, 23, 16, 19, 7, 0, 4, 3, 6, 1, 2, 5],\n  [27, 31, 26, 25, 30, 29, 24, 28, 9, 13, 15, 8, 12, 11, 14, 10, 23, 18, 19, 22, 21, 16, 17, 20, 1, 4, 5, 7, 0, 2, 3, 6],\n  [28, 24, 27, 30, 31, 26, 25, 29, 10, 14, 9, 12, 13, 15, 8, 11, 16, 19, 20, 23, 18, 17, 22, 21, 2, 5, 6, 1, 4, 3, 7, 0],\n  [29, 25, 28, 31, 24, 27, 30, 26, 11, 8, 10, 13, 14, 9, 12, 15, 17, 20, 21, 16, 19, 22, 23, 18, 3, 6, 0, 2, 5, 7, 1, 4],\n  [30, 26, 25, 28, 29, 24, 27, 31, 12, 15, 8, 10, 11, 14, 9, 13, 18, 17, 22, 21, 16, 19, 20, 23, 4, 3, 7, 0, 2, 5, 6, 1],\n  [31, 27, 30, 29, 26, 25, 28, 24, 13, 9, 12, 11, 15, 8, 10, 14, 19, 22, 23, 18, 17, 20, 21, 16, 5, 7, 1, 4, 3, 6, 0, 2]\n]\n\n# Irreducible representations\n[Gamma.C4.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C4.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C4.Ea]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C4.Eb]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Delta.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [1.5707963267948966, 0.0000000000000000]\n\n[M.C4.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[M.C4.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[M.C4.Ea]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[M.C4.Eb]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[None0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [0.0000000000000003, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865467, 0.7071067811865483],\n  [-0.7071067811865485, -0.7071067811865466],\n  [0.7071067811865466, -0.7071067811865485],\n  [0.7071067811865486, 0.7071067811865466],\n  [-0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865467, 0.7071067811865483],\n  [-0.7071067811865471, -0.7071067811865479],\n  [0.7071067811865466, -0.7071067811865485],\n  [0.7071067811865472, 0.7071067811865478],\n  [-0.7071067811865465, 0.7071067811865486],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [0.0000000000000003, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-0.0000000000000022, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000005]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [2.3561944901923448, 0.7853981633974483]\n\n[None1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865467, 0.7071067811865483],\n  [0.7071067811865477, 0.7071067811865474],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865486, 0.7071067811865466],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865485, -0.7071067811865466],\n  [-0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865471, -0.7071067811865479],\n  [-0.7071067811865467, 0.7071067811865483],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865465, 0.7071067811865486],\n  [0.7071067811865472, 0.7071067811865478],\n  [-1.0000000000000000, 0.0000000000000001],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000003, 1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000005],\n  [-0.0000000000000022, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [2.3561944901923448, -0.7853981633974483]\n\n[Sigma0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865477, 0.7071067811865474],\n  [0.7071067811865466, -0.7071067811865485],\n  [0.7071067811865483, 0.7071067811865467],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865477, 0.7071067811865474],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865474, -0.7071067811865477],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000006, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000023, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [2.3561944901923448, 2.3561944901923448]\n\n[Sigma1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [1.5707963267948966, 1.5707963267948966]\n\n[Sigma2.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.7071067811865476, 0.7071067811865475],\n  [0.7071067811865476, 0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865477, -0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865476, 0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865476, 0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [0.7853981633974483, 0.7853981633974483]\n\n[X.C2.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119]\nmomentum = [3.1415926535897931, 0.0000000000000000]\n\n[X.C2.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000006]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119]\nmomentum = [3.1415926535897931, 0.0000000000000000]\n\n[Z0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [-0.0000000000000010, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [3.1415926535897931, 1.5707963267948966]\n\n[Z1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000009],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000010, 1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [3.1415926535897931, -1.5707963267948966]\n</code></pre> <p>To run the above C++ code with the toml file, one needs to execute the following command </p> <p><pre><code>./build/main n_sites n_up kname J1 J2 seed\n</code></pre> where the n_sites, n_up, kname, J1, and seed are to be replaced by their values such as 32, 16, Gamma.C4.A, 1.00, 0.1, 1, respectively. Once the code has been run for various values of \\(J_2/J_1\\), the spectrum can be immediately plotted from the eigenvalues saved in the .h5 files.</p> <p>The expectation value of an observable \\(\\mathcal{O}\\) in the canonical ensemble is</p> \\[ \\langle \\mathcal{O} \\rangle = \\frac{\\text{Tr}\\left(e^{-\\beta \\mathcal{H}} \\mathcal{O}\\right)}{\\mathcal{Z}}, \\] <p>where \\(\\beta\\) is the inverse temperature and \\(\\mathcal{Z} = \\text{Tr}\\left(e^{-\\beta \\mathcal{H}}\\right)\\). We approximate the trace stochastically using a set of \\(R\\) random vectors \\(|r\\rangle\\), leading to</p> \\[ \\langle \\mathcal{O} \\rangle \\approx \\frac{N_{st}}{\\mathcal{Z}R}\\sum_{r=1}^R\\sum_{j=0}^M e^{-\\beta\\epsilon_j^r}\\langle r|\\psi_j^r\\rangle \\langle \\psi_j^r|\\mathcal{O}|r\\rangle, \\] <p>and </p> \\[ \\mathcal{Z} \\approx \\frac{N_{st}}{R}\\sum_{r=1}^R\\sum_{j=0}^M e^{-\\beta\\epsilon_j^r}|\\langle r|\\psi_j^r\\rangle|^2 \\] <p>where \\(|r\\rangle\\) seves as intial vectors for the Lanczos iteration, resulting in \\(M\\) eigenvalues \\(\\epsilon_j^r\\) with corresponding \\(|\\psi_j^r\\rangle\\) [3], and \\(N_{st}\\) is the total number of many-body states in the Hilbert space. Once the Lanczos basis \\(V\\) and the \\(M\\times M\\) tridiagonal matrix  \\(T = V^\\dagger \\mathcal{H} V\\) is constructed from \\(|r\\rangle\\), \\(\\langle r|\\psi_j^r \\rangle\\) is just the first component of the \\(j\\)-th eigenvector of \\(T\\).</p> <p>Thus, the algorithm performs the following steps:</p> <ol> <li> <p>Generate the Lanczos Basis: Obtain the elements of the tridiagonal matrix \\(T\\) from each random state \\(|r\\rangle\\).</p> </li> <li> <p>Compute thermodynamic quantities: To obtain the specific heat,  $$    C = \\beta^2\\left[\\langle \\mathcal{H}^2 \\rangle - \\langle \\mathcal{H} \\rangle^2\\right], $$ we need to evaluate</p> </li> </ol> \\[    \\langle \\mathcal{H} \\rangle \\approx \\frac{N_{st}}{\\mathcal{Z}R}\\sum_{r=1}^R\\sum_{j=0}^M e^{-\\beta\\epsilon_j^r}|\\langle r|\\psi_j^r\\rangle|^2 \\epsilon_j^r, \\\\[2exm]     \\langle \\mathcal{H}^2 \\rangle \\approx \\frac{N_{st}}{\\mathcal{Z}R}\\sum_{r=1}^R\\sum_{j=0}^M e^{-\\beta\\epsilon_j^r}|\\langle r|\\psi_j^r\\rangle|^2 (\\epsilon_j^r)^2. \\] <p>This part could be done in the post-processing. Similarly, one can obtain magnetic susceptibility  $$    \\chi = \\frac{1}{N}\\beta\\left[\\langle S_z^2 \\rangle - \\langle S_z \\rangle^2\\right], $$ where \\(N\\) is the number of sites, by computing</p> \\[    \\langle S_z \\rangle \\approx \\frac{N_{st}}{\\mathcal{Z}R}\\sum_{r=1}^R\\sum_{j=0}^M e^{-\\beta\\epsilon_j^r}|\\langle r|\\psi_j^r\\rangle|^2 S_z, \\\\[2exm]     \\langle S_z^2 \\rangle \\approx \\frac{N_{st}}{\\mathcal{Z}R}\\sum_{r=1}^R\\sum_{j=0}^M e^{-\\beta\\epsilon_j^r}|\\langle r|\\psi_j^r\\rangle|^2 S_z^2. \\] <p>Note that above we used \\(\\langle \\psi_j^r|S_z|r\\rangle = \\langle \\psi_j^r|r\\rangle S_z\\) because our Hamiltonian is \\(S_z\\) symmetric, and we use Lanczos algorithm per \\(S_z\\) sector.</p> <p>Finally, from the partition function \\(\\mathcal{Z}\\) and \\(\\langle\\mathcal{H}\\rangle\\), one can directly compute entropy using the formula</p> \\[ s = \\frac{1}{N}(\\log(\\mathcal{Z})+\\beta\\langle(\\mathcal{H}-E_0)\\rangle), \\] <p>where \\(N\\) is the number of sites and \\(E_0\\) is the ground state energy. A typical plot of entropy as a funtion of temperature is shown in the figure below  The two subfigures are plotted to show typical behaviors at low and high temperatures. The subplot on the right shows that high temperture entropy satuarates to \\(s_{T\\rightarrow \\infty} =\\ln(2)\\). The subplot on the left shows that for very low temperature, entropy value obtained using the method mentioned above can be negative [4].</p> <p>Once we obtain magnetic susceptibility and entropy, we can also plot the Wilson ratio [5]</p> \\[ R(T) = \\frac{4\\pi^2 T \\chi(T)}{3s(T)}. \\] <p>For antiferromagnets the effective magnon excitations lead to \\(s\\propto T^2\\) for low \\(T\\), and \\(\\chi(T\\rightarrow 0)&gt;0\\) due to contribution of the spin fluctuations transverse to the the magnetic order; hence \\(R(T\\rightarrow 0) \\rightarrow \\infty\\). Below we show the plot of Wilson ration vs. temperature for several values of \\(J_2/J_1\\)  Note that each curve is cut off on the left at some \\(T\\). This is because one can expect that results reach the \\(N\\rightarrow \\infty\\) validity only for \\(\\mathcal{Z}&gt;\\mathcal{Z}^*\\gg 1\\). In reality, we set cut-off of \\(\\mathcal{Z}^* = 10\\), and only plot data for temperatures at which \\(\\mathcal{Z}&gt;10\\) [5]. However, even with this cutoff, we can see that for small \\(J_2/J_1 = 0.1, 0.3\\) (N\u00e9el antiferromagnet) and large \\(J_2/J_1 =0.9,1.0\\) (stripe antiferromagnet) , the Wilson ratio curve goes upward as temperature is lowered for small \\(T\\). For \\(J_2/J_1 = 0.5, 0.7\\), where the transition occurs, the Wilson ratio keeps decreasing as temperature is decreased.</p> <p>All the thermodynamic quantities mentioned above can be plotted using the Julia script below</p> Julia <pre><code>using LinearAlgebra\nusing Plots\nusing Combinatorics\n# using BenchmarkTools\nusing Kronecker\nusing LaTeXStrings\n# using Arpack\n# using KernelDensity\nusing Interpolations\nusing SparseArrays\n# using ArnoldiMethod\n# using KrylovKit\nusing JLD2\nusing HDF5\nusing Printf\n\nplot_font = \"Computer Modern\"\ndefault(\n    fontfamily=plot_font,\n    linewidth=2, \n    framestyle=:box, \n    # xtickfont=font(18),\n    label=nothing\n    # ytickfont=font(18),\n    # legendfont=font(18)\n)\n\n\n\nn_sites=32\nn_seeds = 1\nks=[\"Gamma.C4.A\", \"Gamma.C4.B\", \"Gamma.C4.Ea\", \"Gamma.C4.Eb\", \"M.C4.A\", \"M.C4.B\", \"M.C4.Ea\", \"M.C4.Eb\", \"X.C2.A\", \"X.C2.B\", \"Delta.C1.A\", \"None0.C1.A\", \"None1.C1.A\", \"Sigma0.C1.A\", \"Sigma1.C1.A\", \"Sigma2.C1.A\", \"Z0.C1.A\"]\nkmult=[1,1,1,1,1,1,1,1,2,2,4,4,4,4,4,4,4]\nseeds = [i for i=2:2]\nn_ups = [i for i=0:div(n_sites,2)]\n\nJ1=1.00\nJ2s=[i/10. for i=0:10]\nJchi = 0.0\n\ntemps = collect(range(0.01, 100, length=400))#2.5\n\nmkpath(\"./data\")\nmkpath(\"./plot-therm\")\nmkpath(\"./plot-therm/spec-heat/\")\nmkpath(\"./plot-therm/susceptibility/\")\nmkpath(\"./plot-therm/entropy/\")\nmkpath(\"./plot-therm/partition/\")\n\n\nfor J2 = J2s\n    plot(title=L\"J_2/J_1 = \"*string(J2))\n    SpecHeat = zeros(n_seeds,length(temps))\n    partitions = zeros(n_seeds,length(temps))\n    Susceptibility = zeros(n_seeds,length(temps))\n    Energy = zeros(n_seeds,length(temps))\n    Entropy = zeros(n_seeds,length(temps))\n    n_seed=0\n    for seed = seeds\n        n_seed+=1\n        f = h5open(@sprintf(\"outfile.square.%d.J1.%.2f.J2.%.2f.Jchi.%.2f.nup.%d.k.%s.seed.%d.h5\",n_sites,J1,J2,Jchi,div(n_sites,2),\"Gamma.C4.A\",seed), \"r\")\n        eig0 = read(f[\"Eigenvalues\"])[1] # this is the ground state energy\n        for ntemp = 1:length(temps)\n            temp = temps[ntemp]\n            partition = 0.0\n            energy = 0.0\n            energy2 =0.0\n            sz2 =0.0\n            # entropy = 0.0\n            for nk = 1:length(ks)\n                for n_up = n_ups\n                    factor =2.0\n                    if n_up == div(n_sites,2)\n                        factor=1.0\n                    end\n                    f = h5open(@sprintf(\"/home/ssarkar/research/ChiralSpinHall/MyThirdCode/outfiles/seed.%d/outfile.square.%d.J1.%.2f.J2.%.2f.Jchi.%.2f.nup.%d.k.%s.seed.%d.h5\",seed,n_sites,J1,J2,Jchi,n_up,ks[nk],seed), \"r\")\n                    alphas = read(f[\"Alphas\"])\n                    betas = read(f[\"Betas\"])\n                    dims = read(f[\"Dimension\"])\n                    tmat = SymTridiagonal(alphas, betas[1:length(alphas)-1])\n                    if length(alphas)==1\n                        partition += exp(-(alphas[1]-eig0)/temp)*kmult[nk]*factor\n                        energy += alphas[1]*exp(-(alphas[1]-eig0)/temp)*kmult[nk]*factor\n                        energy2 += alphas[1]^2*exp(-(alphas[1]-eig0)/temp)*kmult[nk]*factor\n                    elseif length(alphas)&gt;1\n                        F = eigen(tmat)\n                        eig = F.values\n                        vecs = F.vectors\n                        partition += dims*sum([exp(-(eig[m]-eig0)/temp)*vecs[1,m]^2 for m=1:length(eig)])*kmult[nk]*factor\n                        energy += dims*sum([eig[m]*exp(-(eig[m]-eig0)/temp)*vecs[1,m]^2 for m=1:length(eig)])*kmult[nk]*factor\n                        energy2 += dims*sum([eig[m]^2*exp(-(eig[m]-eig0)/temp)*vecs[1,m]^2 for m=1:length(eig)])*kmult[nk]*factor\n                        sz2 += dims*sum([(n_up-n_sites/2)^2*exp(-(eig[m]-eig0)/temp)*vecs[1,m]^2 for m=1:length(eig)])*kmult[nk]*factor\n                    end\n                end\n            end\n            SpecHeat[n_seed,ntemp] = (energy2/partition-(energy/partition)^2)/temp^2\n            partitions[n_seed,ntemp] = partition\n            Susceptibility[n_seed,ntemp] = sz2/partition/temp/n_sites\n            Energy[n_seed,ntemp] = (energy/partition-eig0)\n            Entropy[n_seed,ntemp] = (log(partition)+(energy/partition-eig0)/temp)/n_sites\n        end\n        plot!(temps,SpecHeat[n_seed,:],left_margin=15Plots.mm,bottom_margin=10Plots.mm,xlabel=L\"T/J_1\",ylabel=L\"C_v\")\n    end\n    savefig(@sprintf(\"plot-therm/spec-heat/outfile.square.%d.J1.%.2f.J2.%.2f.png\",n_sites,J1,J2))\n    plot(title=L\"J_2/J_1 = \"*string(J2))\n    n_seed=0\n    for seed = seeds\n        n_seed+=1\n        plot!(temps,partitions[n_seed,:],left_margin=20Plots.mm,bottom_margin=10Plots.mm,xlabel=L\"T/J_1\",ylabel=L\"Z\")\n    end\n    savefig(@sprintf(\"plot-therm/partition/outfile.square.%d.J1.%.2f.J2.%.2f.png\",n_sites,J1,J2))\n    plot(title=L\"J_2/J_1 = \"*string(J2))\n    n_seed=0\n    for seed = seeds\n        n_seed+=1\n        plot!(temps[1:200],Susceptibility[n_seed,1:200], xlims=(1e-2, temps[200]), ylims=(1e-5, 1.2e-1),left_margin=20Plots.mm,bottom_margin=10Plots.mm,xlabel=L\"T/J_1\",ylabel=L\"\\chi\")\n    end\n    savefig(@sprintf(\"plot-therm/susceptibility/outfile.square.%d.J1.%.2f.J2.%.2f..png\",n_sites,J1,J2))\n    plot(title=L\"J_2/J_1 = \"*string(J2))\n    n_seed=0\n    for seed = seeds\n        n_seed+=1\n        plot!(temps[1:200],Entropy[n_seed,1:200], xlims=(1e-2, temps[200]),left_margin=20Plots.mm,bottom_margin=10Plots.mm,xlabel=L\"T/J_1\",ylabel=L\"s\")\n    end\n    savefig(@sprintf(\"plot-therm/entropy/outfile.square.%d.J1.%.2f.J2.%.2f.png\",n_sites,J1,J2))\n    fid = h5open(@sprintf(\"data/outfile.square.%d.J1.%.2f.J2.%.2f.h5\",n_sites,J1,J2),\"w\")\n    fid[\"SpecHeat\"] = SpecHeat\n    fid[\"partitions\"] = partitions\n    fid[\"Susceptibility\"] = Susceptibility\n    fid[\"Energy\"] = Energy\n    fid[\"Entropy\"] = Entropy\n    close(fid)\nend\n\n\n\nplot()\nlet n_seed = 0\n    for seed = seeds\n        n_seed+=1\n        for J2 = [i/10. for i=[1,3,5,7,9,10]]\n            fid = h5open(@sprintf(\"data/outfile.square.%d.J1.%.2f.J2.%.2f.h5\",n_sites,J1,J2),\"r\")\n            entropy = read(fid[\"Entropy\"]);\n            susceptibility = read(fid[\"Susceptibility\"])\n            partitions=read(fid[\"partitions\"])\n            id=1\n            j=1\n            while partitions[n_seed,j]&lt;10\n                j=j+1\n            end\n            id=j\n            wlratio = 4*pi^2*(temps.*susceptibility[n_seed,:])./(3*entropy[n_seed,:])\n            plot!(temps[id:200],wlratio[id:200], xlims=(1e-2, temps[200]),ylims=(0.0,3.0),left_margin=20Plots.mm,bottom_margin=10Plots.mm,xlabel=L\"T\",ylabel=L\"\\mathrm{Wilson\\ ratio\\ }R\",label=L\"J_2 = \"*string(J2), dpi=1000)\n        end\n        savefig(@sprintf(\"plot-therm/WR.square.%d.J1.%.2f.Jchi.%.2f.png\",n_sites,J1,Jchi))\n    end\nend\n</code></pre>"},{"location":"examples/square_J1_J2-WilsonRatio/#references","title":"References","text":"<p>[1] S. Sugiura and A. Shimizu, Thermal Pure Quantum States at Finite Temperature, Phys. Rev. Lett. 108, 240401 (2012).</p> <p>[2] Zhang, X. T., Huang, Y., Wu, H. Q., Sheng, D. N., and Gong, S. S. Physical Review B, 109(12), 125146 (2024).</p> <p>[3] Prelov\u0161ek, P., and J. Bon\u010da. \"Ground state and finite temperature Lanczos methods.\" Strongly Correlated Systems: Numerical Methods (2013): 1-30.</p> <p>[4] Morita, Katsuhiro, and Takami Tohyama. \"Finite-temperature properties of the Kitaev-Heisenberg models on kagome and triangular lattices studied by improved finite-temperature Lanczos methods.\" Phys. Rev. Res. 2, 013205 (2020).</p> <p>[5] Prelov\u0161ek, P., K. Morita, T. Tohyama, and J. Herbrych. \"Vanishing Wilson ratio as the hallmark of quantum spin-liquid models.\" Phys. Rev. Res. 2, no. 2 (2020): 023024.</p>"},{"location":"examples/tJ_conductivity/","title":"Optical conductivity \\(t\\)-\\(J\\) model","text":"<p>Author Martin Ulaga</p> <p>Uses the Lanczos algorithm[1] to calculate the conductivity of the planar \\(t\\)-\\(J\\) model with one hole. See also the documentation page for the spin structure factor. The ground state conductivity is geven by the current autocorrelator</p> \\[     T\\sigma(\\omega)=-i\\int dt e^{-i\\omega t}\\langle  J(t)J\\rangle. \\] <p>The plotting script includes a simple benchmark exploring the role of the number of Lanczos iterations on the result.</p> <p></p>"},{"location":"examples/tJ_conductivity/#example-code","title":"Example code","text":"JuliaC++ <pre><code>    using XDiag\n    using HDF5\n\n    function main()\n      say_hello()\n\n      # IO\n      latticeInput = \"../../misc/data/square.16.tJ.toml\"\n      lfile = FileToml(latticeInput)\n\n      filename = \"../../misc/data/examples_output/tJ_conductivity_jll.h5\"\n      outfile = h5open(filename, \"w\")\n\n      # Lanczos parameters\n      precision = 0.0 # turns off precision checking\n      maxiters = 200\n\n      # Define the model\n      N = 16\n      nup = 8\n      ndn = 7 # one hole\n      ops = read_opsum(lfile, \"Interactions\")\n      t = 1.0\n      J = 0.3\n      ops[\"T\"] = t\n      ops[\"J\"] = J\n      @show(ops)\n      irrep = read_representation(lfile, \"Gamma.C1.A\")\n\n      # compute groundstate\n      println(\"Computing ground state ...\")\n      block = tJ(N, nup, ndn, irrep)\n      e0, gs = eig0(ops, block)\n      println(\"done.\")\n      println(\"Ground state energy: $e0\")\n      outfile[\"e0\"] = e0\n\n      current = symmetrize(1.0 * im * Op(\"Hop\", [1, 2]), irrep)\n      Av = apply(current, gs)\n      @show nrm = norm(Av)\n      Av /= nrm\n\n      res = eigvals_lanczos_inplace(ops, Av; neigvals=1, precision=precision, max_iterations=maxiters)\n      @show res.eigenvalues[1]\n      outfile[\"norm\"] = nrm\n      outfile[\"alphas\"] = res.alphas\n      outfile[\"betas\"] = res.betas\n      outfile[\"eigs\"] = res.eigenvalues\n    end\n\n    main()\n</code></pre> <pre><code>    #include &lt;xdiag/all.hpp&gt;\n\n    using namespace xdiag;\n    using namespace arma;\n    using fmt::format;\n    using namespace std::complex_literals;\n\n    int main() try {\n      say_hello();\n      set_verbosity(0);\n      // IO\n      std::string latticeInput =\n          XDIAG_DIRECTORY \"/misc/data/square.16.tJ.toml\";\n      auto lfile = FileToml(latticeInput);\n\n      std::string filename =\n          XDIAG_DIRECTORY \"/misc/data/examples_output/tJ_conductivity.h5\";\n      auto outfile = FileH5(filename, \"w!\");\n\n      // Lanczos parameters\n      auto precision = 0; // turns off convergence checking\n      auto maxiters = 200;\n\n      // Define the model\n      int N = 16;\n      int nup = 8;\n      int ndn = 7; // one hole\n      auto ops = read_opsum(lfile, \"Interactions\");\n      auto t = 1.;\n      auto J = 0.3;\n      ops[\"T\"] = t;\n      ops[\"J\"] = J;\n      XDIAG_SHOW(ops);\n\n      auto irrep = read_representation(lfile, \"Gamma.C1.A\");\n\n      // compute groundstate\n      Log(\"computing ground state\");\n      Log(\"Computing ground state ...\");\n      auto block = tJ(N, nup, ndn, irrep);\n      XDIAG_SHOW(block);\n      auto [e0, gs] = eig0(ops, block);\n      Log(\"Ground state energy: {:.12f}\", e0);\n      outfile[\"e0\"] = e0;\n\n      // create &amp; apply current operator\n      Log(\"applying curr. operator\");\n      auto current = symmetrize(1i * Op(\"Hop\", {0, 1}),\n                                irrep);\n      // XDIAG_SHOW(current);\n      auto Av = apply(current, gs);\n      auto nrm = norm(Av);\n      Av /= nrm;\n      XDIAG_SHOW(nrm);\n      outfile[\"norm\"] = nrm;\n\n      // second run\n      Log(\"second Laczos run on A|gs&gt;\");\n      auto res = eigvals_lanczos_inplace(ops, Av, 1, precision, maxiters);\n      XDIAG_SHOW(res.eigenvalues(0));\n      outfile[\"alphas\"] = res.alphas;\n      outfile[\"betas\"] = res.betas;\n      outfile[\"eigs\"] = res.eigenvalues;\n\n    } catch (Error e) {\n      error_trace(e);\n    }\n</code></pre>"},{"location":"examples/tJ_conductivity/#plotting-script","title":"Plotting script","text":"Julia <pre><code>    using XDiag\n    using LinearAlgebra\n    using HDF5\n    using Plots\n    using IterTools\n\n    # pythonplot()\n\n    function poles_weights(outfile::String; M::Int64=-1)\n        e0 = h5read(outfile, \"e0\")\n        nrm, alphas, betas, eigs = h5read.((outfile,), [\"norm\", \"alphas\", \"betas\", \"eigs\"])\n        if M &gt; 0\n            try\n                alphas = alphas[1:M]\n                betas = betas[1:M]\n            catch e\n                println(e)\n            end\n        end\n        tmat = SymTridiagonal(alphas, betas)\n        es, evecs = eigen(tmat)\n        # @show es[1], eigs[1]\n\n        poles = es .- e0\n        weights = evecs[1, :] .^ 2 .* nrm^2\n        sortdisp(poles, weights/nrm^2)\n        return poles, weights\n    end\n\n    function spectrum(poles::Vector{Float64}, weights::Vector{Float64},\n        omegas::Vector{Float64}, eta::Float64=0.1; cutoff::Float64=0.0, filter::Float64=1e-6)\n        fpoles = [poles[i] for i in 1:length(weights) if abs(weights[i]) &gt; filter]\n        fweights = [weights[i] for i in 1:length(weights) if abs(weights[i]) &gt; filter]\n        diffs = omegas .- fpoles'\n        gaussians = exp.(-(diffs ./ (2.0 * eta)) .^ 2.0) ./ (eta * sqrt(2.0 * pi))\n        if abs(cutoff) &gt; 1e-12\n            idxs = findall(abs.(fpoles) .&gt; cutoff)\n            s = zeros(length(omegas))\n            for idx in idxs\n                s += gaussians[:, idx] * fweights[idx]\n            end\n            return s\n        else\n            return gaussians * fweights\n        end\n    end\n\n    function sortdisp(p,w;max=10)\n        upto=min(max,length(p))\n        display([p[sortperm(w,rev=true)][1:upto] sort(w,rev=true)[1:upto]])\n    end\n\n    let\n        source = \"../../misc/data/examples_output/tJ_conductivity_jll.h5\"\n        omegas = collect(range(0., 10.0, length=40000))\n        # eta = omegas[2]-omegas[1]\n        eta = 0.1\n        fig = plot()\n        for M in [30, 50, 100, 200]\n            p, w = poles_weights(source; M=M)\n            s = spectrum(p, w, omegas, eta)\n            plot!(omegas, s, label=\"M=$M\")\n        end\n        savefig(fig, \"cond_jll.pdf\")\n    end\n</code></pre>"},{"location":"examples/tJ_conductivity/#references","title":"References","text":"<p>[1]  Prelov\u0161ek, P., &amp; Bon\u010da, J. (2013). Ground state and finite temperature Lanczos methods. Strongly Correlated Systems: Numerical Methods, 1-30.</p>"},{"location":"examples/tj_distributed_time_evolve/","title":"\\(t\\)-\\(J\\) distributed time evolution","text":""},{"location":"examples/tos_ahm/","title":"Tower Of States attractive Hubbard model","text":"<p>Author Hannes Karlsson</p> <p>We perform a tower of states (TOS) analysis [1],[2] on the attractive Hubbard model on a square lattice. The (particle-hole symmetric) model can be written as $$     \\mathcal{H} = -t\\sum_{\\langle i j \\rangle} c_i^{\\dagger} c_j - U\\sum_{i} (n_{i\\uparrow}-\\frac{1}{2})(n_{i\\downarrow}-\\frac{1}{2}). $$</p> <p>The attractive Hubbard model is known to display a superconducting ground state, which in mean-field theory is well described by a fermionic U\\((1)\\) coherent state $$     \\ket{\\psi} = \\prod_{k} (u_k + v_k c_{k\\uparrow}^\\dagger c_{-k\\downarrow}^\\dagger)\\ket{0}, $$ i.e, the ground state is degenerate in the number of particle pairs. We thus expect that in the superfluid state, in the neighbourhood of the most favourable particle number (determined by the chemical potential), there will be a tower of almost degenerate energy states, containing different number of superconducting pairs, but otherwise the same.</p> <p>To perform the TOS analysis, we gather the eigenvalues using either full exact diagonalization (ED) or the Lanczos algorithm in each symmetry sector, defined by the particle number. Here we use the Lanczos algorithm with \\(3\\) eigenvalues well converged.</p> <p></p> <p>As we can see in the spectra above (computed for a \\(4\\times 4\\) lattice), for large enough values of \\(U\\), the ground state energy is almost degenerate in the different particle number sectors, providing strong evidence for U\\((1)\\) spontaneous symmetry breaking.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n  int Lx = 4;\n  int Ly = 4;\n  int Nmin = 4;\n  int Nmax = 2 * Lx * Ly - 4;\n  std::vector&lt;double&gt; Us = {0.0, -2.0, -10.0};\n\n  for (double U : Us) {\n\n    // Construct Hamiltonian\n    auto ops = OpSum();\n\n    ops += \"U\" * Op(\"HubbardU\"); // apply Hubbard interaction to all sites\n\n    for (int x = 0; x &lt; Lx; x++) {\n      for (int y = 0; y &lt; Ly; y++) {\n        int s = x * Ly + y;\n        int sx = ((x + 1) % Lx) * Ly + y;\n        int sy = x * Ly + (y + 1) % Ly;\n\n        ops += \"t\" * Op(\"Hop\", {s, sx}); // hopping in x-direction\n        ops += \"t\" * Op(\"Hop\", {s, sy}); // hopping in y-direction\n        ops += \"mu\" * Op(\"Ntot\", s);     // chemical potential\n      }\n    }\n    ops[\"t\"] = 1;\n    ops[\"mu\"] = -U / 2;\n    ops[\"U\"] = U;\n\n    for (int N = Nmin; N &lt;= Nmax; N += 2) {\n      int nup = N / 2;\n      int ndn = N / 2;\n      auto block = Electron(Lx * Ly, nup, ndn); // create Hilbert space\n\n      auto res = eigs_lanczos(ops, block, 3);\n\n      std::string outfile = fmt::format(\n          \"data/tos_ahm/U({})_N({})_Lx({})_Ly({}).h5\", U, N, Lx, Ly);\n      auto f = FileH5(outfile, \"w!\");\n      f[\"spectrum\"] = res.eigenvalues;\n    }\n  }\n  return 0;\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing HDF5\n\n\"\"\"Struct for lattice sites\"\"\"\nstruct LatticeBond\n    s1::Int64\n    x1::Float64\n    y1::Float64\n    s2::Int64\n    x2::Float64\n    y2::Float64\nend\n\n\"\"\"Returns list of all bonds on the square lattice\"\"\"\nfunction square_lattice(Lx::Int,Ly::Int;xperiodic=true,yperiodic=true)\n\n    bonds = Vector{LatticeBond}()\n\n    for x1 in 1:Lx, y1 in 1:Ly\n        s1 = (x1-1)*Ly+y1\n        for (x2,y2) in [( mod(x1,Lx)+1, y1 ),( x1, mod(y1,Ly)+1 )]\n            s2 = (x2-1)*Ly+y2\n            set = reduce(hcat,[[s1,x1,y1],[s2,x2,y2]])\n            set = set[:,sortperm(set[1,:])]     # sort according to s1 and s2\n            b = LatticeBond(set[:,1]...,set[:,2]...)\n            push!(bonds,b)\n        end\n    end\n    return bonds\nend\n\n\"\"\"Returns the Hamiltonian for the Hubbard model\"\"\"\nfunction ham(U::Float64,Lx::Int64,Ly::Int64)\n\n    lattice = square_lattice(Lx,Ly)\n    ops = OpSum()\n\n    for b in lattice # hopping term\n        ops += \"t\" * Op(\"Hop\", [b.s1,b.s2])     # both for spin up and down\n    end\n\n    ops += \"U\" * Op(\"HubbardU\")     # applies Hubbard interaction over the entire lattice\n    for i in 1:Lx*Ly\n        ops += \"mu\" * Op(\"Ntot\",i)     # chemical potential\n    end\n\n    ops[\"t\"] = 1.0\n    ops[\"U\"] = U\n    ops[\"mu\"] = -U/2\n\n    return ops\n\nend\n\nfunction main(U::Float64,Lx::Int64,Ly::Int64,Ns::StepRange{Int64, Int64})\n\n    for N in Ns\n\n        ops = ham(U,Lx,Ly) # create the Hamiltonian\n        nup = N%2 == 0 ? N \u00f7 2 : (N+1) \u00f7 2\n        ndn = N%2 == 0 ? N \u00f7 2 : (N-1) \u00f7 2\n\n        block = Electron(Lx*Ly, nup, ndn)   # create Hilbert space\n        res = eigs_lanczos(ops, block, neigvals = 3)\n        eigs = res.eigenvalues\n\n        filename = \"data/tos_ahm/U($U)_N($N)_Lx($Lx)_Ly($Ly).h5\"\n\n        h5open(filename,\"w\") do f\n            write(f,\"spectrum\",eigs)\n        end\n\n    end\n\nend\n\nUs = [0.0,-2.0,-10.0]\nLx, Ly = (4,4)\nNmin = 4\nNmax = 2*Lx*Ly - 4\nNs = Nmin:2:Nmax\n\nsay_hello()\nfor U in Us\n    println(\"Now doing U=$U\")\n    main(U,Lx,Ly,Ns)\nend\n</code></pre>"},{"location":"examples/tos_ahm/#references","title":"references","text":"<p>[1] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p> <p>[3] Alexander Wietek, Michael Schuler and Andreas M. L\u00e4uchli, Studying Continuous Symmetry Breaking using Energy Level Spectroscopy, arXiv:1704.08622 (2017).</p>"},{"location":"examples/tos_alpha_xx/","title":"Tower Of States \\(\\alpha \\text{XX}\\) model","text":"<p>Author Rafael Soares</p> <p>We perform a tower of states (TOS) analizes [1] of the \\(\\alpha \\text{XX}\\) model [2]. This model consists of an array of \\(N\\) spin-\\(\\frac{1}{2}\\) sites with long-range \\(\\text{XY}\\)  couplings that decay as a power law with exponent \\(\\alpha\\), $$     \\mathcal{H} = -\\dfrac{J}{2} \\sum_{i&lt;j} \\dfrac{S^+_iS^-_j+S^-_iS^+_j}{|i - j|^\\alpha}. $$</p> <p>The TOS analysis provides strong evidence for spontaneous symmetry breaking (SSB) in the thermodynamic limit, as the ground state of a finite system is completely symmetric. The spectrum of the \\(\\alpha \\text{XX}\\) model can be labeled by total magnetization since \\(\\left[\\mathcal{H}, S^z \\right]=0\\). </p> <p>To perform the TOS analysis, we gather the eigenvalues using either full exact diagonalization (ED) or the Lanczos algorithm in each symmetry sector.</p> <p></p> <p>In the figure above for \\(\\alpha=1\\), the lowest energy in each \\(S^z\\) sector clear forms a tower of states. These energies scale as \\(\\propto 1 / N\\), so in the thermodynamic limit there the collapse of the tower of states forming a highly degenerate ground state manifold [3]. As such, in the thermodynamic limit SSB occurs. In contrast, for a finite system the ground state always lies in \\(S^z=0\\), and so it is symemtric (it is also an eigenstate of the Hamiltonian's symmetry). </p> <p>SSB does not occur for all values of \\(\\alpha\\). For example, when \\(\\alpha \\rightarrow +\\infty\\), the system becomes a one-dimensional \\(\\text{XX}\\) spin chain with only short-range interactions. In this case, the ground state is always in the \\(S^z=0\\) sector.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\nusing namespace xdiag;\n\nint main() {\n  int Nsites = 14;    // total number of sites\n  double alpha = 1.0; // Exponent power-law decay\n\n  auto ops = OpSum(); // create OpSum\n\n  for (int i = 0; i &lt; Nsites; i++) {\n    for (int j = i + 1; j &lt; Nsites; j++) {\n      double J = -1.0 / (sqrt(Nsites) * pow(abs((double)(i - j)), alpha));\n      ops += J * Op(\"Exchange\", {i, j});\n    }\n  }\n\n  // Diagonalize in each magnetization sector using FullED\n  int total_eigen = pow(2, Nsites);\n  arma::mat energies = arma::mat(\n      total_eigen, 2,\n      arma::fill::zeros); // Collect the energies with the number of spins up.\n  arma::vec eig;\n\n  int count = 0;\n  for (int nup = 0; nup &lt;= Nsites; nup++) {\n    auto block = Spinhalf(Nsites, nup);\n    arma::mat H = matrix(ops, block);\n    eig_sym(eig, H);\n    for (int j = 0; j &lt; eig.n_elem; j++) {\n      energies(count, 0) = nup;    // Magnetization sector\n      energies(count, 1) = eig(j); // Energy eigenvalue\n      count++;\n    }\n  }\n  // Construct the filename\n  std::string flstring = \"energies_tos_XXmodel.Nsites.\" +\n                         std::to_string(Nsites) + \".alpha\" +\n                         std::to_string((double)alpha) + \".outfile.h5\";\n\n  auto save_fl = FileH5(flstring, \"w!\");\n  save_fl[\"energies\"] = energies;\n  return 0;\n}\n</code></pre> <pre><code>using XDiag\nusing LinearAlgebra\nusing Printf\nusing HDF5\n\nfunction main()\n    Nsites = 24 ## Number of Sites \n    alpha = 1.0 ## Exponent power-law decay\n    ops = OpSum() ## create OpSum\n\n    for i in 1:Nsites\n        for j in (i+1):Nsites\n        J = -1.0 / (sqrt(Nsites) * (abs(i - j))^(alpha))\n        ops += J * Op(\"Exchange\", [i, j])\n        end\n    end\n\n    energies = Vector{Float64}[] ## Collect the energies\n\n    Diagonalize in each magnetization sector using FullED\n    for nup in 0:Nsites\n        block = Spinhalf(Nsites, nup)\n        H = matrix(ops, block)\n        eig = eigvals(Hermitian(H))\n        for e0 in eig\n            push!(energies, [nup, e0])\n        end\n    end\n\n    #Diagonalize in each magnetization sector using Lanczos to get the first few eigenvalues\n    # for nup in 0:Nsites\n    #     block = Spinhalf(Nsites, nup)\n    #     r = eigvals_lanczos(ops, block, neigvals = 1);\n    #     for e0 in r.eigenvalues\n    #         push!(energies, [nup, e0])\n    #     end\n    # end\n\n    filename = @sprintf(\"energies_tos_XXmodel.Nsites.%d.alpha.%d.outfile.h5\", Nsites, alpha)\n    h5open(filename, \"w\") do file\n        write(file, \"energies\", hcat(energies...))\n    end\nend\n\nmain()\n</code></pre>"},{"location":"examples/tos_alpha_xx/#references","title":"references","text":"<p>[1] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p> <p>[2] Tommaso Comparin, Fabio Mezzacapo and Tommaso Roscilde, Robust spin squeezing from the tower of states of U(1)-symmetric spin Hamiltonians, Phys. Rev. A 105, 02262 (2022)</p> <p>[3] Alexander Wietek, Michael Schuler and Andreas M. L\u00e4uchli, Studying Continuous Symmetry Breaking using Energy Level Spectroscopy, arXiv:1704.08622 (2017).</p>"},{"location":"examples/tos_quad_kagome/","title":"Extended kagome lattice antiferromagnet","text":"<p>Author Siddhartha Sarkar</p> <p>We consider kagome lattice with the following Hamiltonian</p> \\[ \\mathcal{H} = J_1\\sum_{\\langle i,j\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j+J_2\\sum_{\\langle \\langle i,j\\rangle\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j+J_3\\sum_{\\langle \\langle\\langle i,j\\rangle\\rangle\\rangle_h} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>where \\(\\boldsymbol{S}_i\\) are spin \\(1/2\\) operators, \\(\\langle \\dots \\rangle\\) and \\(\\langle\\langle \\dots \\rangle\\rangle\\) denote sum over nearest and next-nearest neighbor sites, and \\(\\langle \\langle\\langle\\dots\\rangle\\rangle\\rangle_h\\) denote sum over third-nearest-neighbor sites [2]. This model host plethora of interesting phases for different parameter regimes. Here we we will be interested in the parameter values \\(J_2/J_1 =-1.0\\) and \\(J_3/J_1=-2.0\\), for which it was predicted in [2] that the ground state has spin-nematic character, of quadrupolar type. Tower of state analysis [1] provides a strong evidence for this type of spontaneous symmetry breaking (SSB) in the thermodynamic limit, as the ground state of a finite system is completely symmetric. The spectrum of this model can be labeled by total magnetization since \\([\\mathcal{H},S_z]=0\\) (in fact the Hamiltonian is \\(SU(2)\\), and hence the spectrum can be labeled by \\(S^2\\) and \\(S_z\\); but for obtaining the eigen-spectrum, we only use \\(S_z\\)).</p> <p>To perform the TOS analysis, we converged the lowest-lying eigenvalues using the Lanczos algorithm in each symmetry sector (labeled by \\(S_z\\), momentum, and little group irreducible representations at each momentum) for a \\(C_6\\) symmetric system with \\(N=36\\) sites (\\(12\\) unit cells and \\(3\\) spins per unit cell). The \\(36\\)-site kagome lattice and the momentum points in the Brillouin zone are shown in the figure below.</p> <p> In the left figure above, the twelve triangles show the 12 unit cells. In the right figure above, the different momentum points are shown; there are three \\(M\\) points (related by \\(C_3\\) with each other), two \\(K\\) points (related by \\(C_2\\)), six \\(Z\\) points (related by \\(C_6\\)), and one \\(\\Gamma\\) point. We plot the spectrum vs \\(S_z\\) in the figure below.</p> <p></p> <p>The momenta and the irrep labels of the eigenstates are shown with markers. The degeneracies at different \\(S_z\\) gives total quantum of number \\(S\\). Odd-\\(S\\) sectors are not present in the low-energy tower of states, indicating a quadrupolar spin-nematic phase [2].</p> <p>The C++ script used to obtain the eigen spectra is given below</p> C++ <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nint main(int argc, char **argv) {\n  using namespace xdiag;\n  using namespace arma;\n  using fmt::format;\n\n  say_hello();\n\n  // Parse input arguments\n  assert(argc == 8);\n  int n_sites = atoi(argv[1]);              // number of sites\n  int n_up = atoi(argv[2]);                 // number of upspins\n  std::string kname = std::string(argv[3]); // momentum k\n  double J1 = atof(argv[4]);\n  double J2 = atof(argv[5]);\n  double J3 = atof(argv[6]);\n  int seed = atoi(argv[7]);\n\n  Log(\"Diagonalizing H in block nup: {}, k: {}\", n_up, kname);\n\n  auto lfile = FileToml(format(\"kagome.{}.J1J2J3.pbc.toml\", n_sites));\n  std::string ofilename = format(\n      \"outfile.kagome.{}.J1.{:.2f}.J2.{:.2f}.J3.{:.2f}.nup.{}.k.{}.seed.{}.h5\",\n      n_sites, J1, J2, J3, n_up, kname, seed);\n  auto ofile = FileH5(ofilename, \"w!\");\n\n  xdiag::OpSum ops = read_opsum(lfile, \"Interactions\");\n  ops[\"J1\"] = J1;\n  ops[\"J2\"] = J2;\n  ops[\"J3\"] = J3;\n  auto irrep = read_representation(lfile, kname);\n\n  Log(\"Creating block ...\");\n  tic();\n  auto block = Spinhalf(n_sites, n_up, irrep);\n  toc();\n  Log(\"Dimension: {}\", block.size());\n\n  Log(\"Running Lanczos ...\");\n  tic();\n  int n_eig_to_converge = 2;\n  int max_iterations = 100;\n  auto tmat = eigvals_lanczos(ops, block, n_eig_to_converge, 1e-12,\n                              max_iterations, 1e-7, seed);\n  toc();\n\n  ofile[\"Alphas\"] = tmat.alphas;\n  ofile[\"Betas\"] = tmat.betas;\n  ofile[\"Eigenvalues\"] = tmat.eigenvalues;\n  ofile[\"Dimension\"] = block.size();\n\n  return EXIT_SUCCESS;\n}\n</code></pre> <p>The interactions terms and the symmetry representation inputs are given in the following TOML file:</p> toml <pre><code># This modelfile was created with the following properties:\n# Basis coordinates: ((-0.75, -0.4330127018922193), (-0.25, -0.4330127018922193), (-0.5, 0.))\n# Lattice vectors: a1=(1.0, 0.0), a2=(-0.5, 0.8660254037844386)\n# Simulation torus vectors: t1=(3.0, -1.7320508075688772), t2=(0.0, 3.4641016151377544)\n# Simulation torus matrix: ((2, -2), (2, 4))\n# Symmetry center: (0.0, 0.0)\n# Lattice Point Group: C6\n# Lattice Space Group (infinite Lattice): C6\n# K points (K wedge marked with *):\n# [-2.0943951023931953 0.0] \n# [-1.0471975511965976 1.813799364234218] \n# [0. 3.627598728468436] *\n# [-1.0471975511965976  -1.813799364234218] \n# [0. 0.0] *\n# [1.0471975511965976 1.813799364234218] *\n# [2.094395102393195 3.627598728468436] *\n# [1.0471975511965976 -1.813799364234218]\n# [2.094395102393195 0.0]\n# [3.141592653589793 1.813799364234218] \n# [3.141592653589793 -1.813799364234218] \n# [4.18879020478639 0.0]\n# High Symmetry Points: Gamma.C6, K.C3, M.C2, Z.C1,\n# Eccentricity: --\n\nCoordinates = [\n  [-1.25, -1.299038105676658],\n  [-0.75, -1.299038105676658],\n  [-1.0, -0.8660254037844386],\n  [-0.25, -1.299038105676658], \n  [0.25, -1.299038105676658], \n  [0.0, -0.8660254037844386], \n  [0.75, -1.299038105676658], \n  [1.25, -1.299038105676658], \n  [1.0, -0.8660254037844386], \n  [-1.75, -0.4330127018922193], \n  [-1.25, -0.4330127018922193], \n  [-1.5, 0.0],\n  [-0.75, -0.4330127018922193], \n  [-0.25, -0.4330127018922193], \n  [-0.5, 0.0], \n  [0.25, -0.4330127018922193], \n  [0.75, -0.4330127018922193], \n  [0.5, 0.0], \n  [1.25, -0.4330127018922193], \n  [1.75, -0.4330127018922193], \n  [1.5, 0.0], \n  [-1.25, 0.4330127018922193], \n  [-0.75, 0.4330127018922193], \n  [-1.0, 0.8660254037844386], \n  [-0.25, 0.4330127018922193], \n  [0.25, 0.4330127018922193], \n  [0.0, 0.8660254037844386], \n  [0.75, 0.4330127018922193], \n  [1.25, 0.4330127018922193], \n  [1.0, 0.8660254037844386], \n  [-0.75, 1.299038105676658], \n  [-0.25, 1.299038105676658], \n  [-0.5, 1.7320508075688772], \n  [0.25, 1.299038105676658], \n  [0.75, 1.299038105676658], \n  [0.5, 1.7320508075688772]\n]\n\nInteractions = [\n    ['J1', 'SdotS', 0, 1], \n    ['J1', 'SdotS', 1, 2], \n    ['J1', 'SdotS', 2, 0], \n    ['J1', 'SdotS', 3, 4], \n    ['J1', 'SdotS', 4, 5], \n    ['J1', 'SdotS', 5, 3], \n    ['J1', 'SdotS', 6, 7], \n    ['J1', 'SdotS', 7, 8], \n    ['J1', 'SdotS', 8, 6], \n    ['J1', 'SdotS', 9, 10], \n    ['J1', 'SdotS', 10, 11], \n    ['J1', 'SdotS', 11, 9], \n    ['J1', 'SdotS', 12, 13], \n    ['J1', 'SdotS', 13, 14], \n    ['J1', 'SdotS', 14, 12], \n    ['J1', 'SdotS', 15, 16], \n    ['J1', 'SdotS', 16, 17], \n    ['J1', 'SdotS', 17, 15], \n    ['J1', 'SdotS', 18, 19], \n    ['J1', 'SdotS', 19, 20], \n    ['J1', 'SdotS', 20, 18], \n    ['J1', 'SdotS', 21, 22], \n    ['J1', 'SdotS', 22, 23], \n    ['J1', 'SdotS', 23, 21], \n    ['J1', 'SdotS', 24, 25], \n    ['J1', 'SdotS', 25, 26], \n    ['J1', 'SdotS', 26, 24], \n    ['J1', 'SdotS', 27, 28], \n    ['J1', 'SdotS', 28, 29], \n    ['J1', 'SdotS', 29, 27], \n    ['J1', 'SdotS', 30, 31], \n    ['J1', 'SdotS', 31, 32], \n    ['J1', 'SdotS', 32, 30], \n    ['J1', 'SdotS', 33, 34], \n    ['J1', 'SdotS', 34, 35], \n    ['J1', 'SdotS', 35, 33], \n    ['J1', 'SdotS', 20, 0], \n    ['J1', 'SdotS', 32, 3], \n    ['J1', 'SdotS', 35, 6], \n    ['J1', 'SdotS', 29, 9], \n    ['J1', 'SdotS', 2, 12], \n    ['J1', 'SdotS', 5, 15], \n    ['J1', 'SdotS', 8, 18], \n    ['J1', 'SdotS', 11, 21], \n    ['J1', 'SdotS', 14, 24], \n    ['J1', 'SdotS', 17, 27], \n    ['J1', 'SdotS', 23, 30], \n    ['J1', 'SdotS', 26, 33], \n    ['J1', 'SdotS', 3, 1], \n    ['J1', 'SdotS', 6, 4], \n    ['J1', 'SdotS', 21, 7], \n    ['J1', 'SdotS', 12, 10], \n    ['J1', 'SdotS', 15, 13], \n    ['J1', 'SdotS', 18, 16], \n    ['J1', 'SdotS', 30, 19], \n    ['J1', 'SdotS', 24, 22], \n    ['J1', 'SdotS', 27, 25], \n    ['J1', 'SdotS', 0, 28], \n    ['J1', 'SdotS', 33, 31], \n    ['J1', 'SdotS', 9, 34], \n    ['J1', 'SdotS', 10, 2], \n    ['J1', 'SdotS', 13, 5], \n    ['J1', 'SdotS', 16, 8], \n    ['J1', 'SdotS', 7, 11], \n    ['J1', 'SdotS', 22, 14], \n    ['J1', 'SdotS', 25, 17], \n    ['J1', 'SdotS', 28, 20], \n    ['J1', 'SdotS', 19, 23], \n    ['J1', 'SdotS', 31, 26], \n    ['J1', 'SdotS', 34, 29], \n    ['J1', 'SdotS', 1, 32], \n    ['J1', 'SdotS', 4, 35],\n    ['J2', 'SdotS', 19, 0], \n    ['J2', 'SdotS', 31, 3], \n    ['J2', 'SdotS', 34, 6], \n    ['J2', 'SdotS', 28, 9], \n    ['J2', 'SdotS', 1, 12], \n    ['J2', 'SdotS', 4, 15], \n    ['J2', 'SdotS', 7, 18], \n    ['J2', 'SdotS', 10, 21], \n    ['J2', 'SdotS', 13, 24], \n    ['J2', 'SdotS', 16, 27], \n    ['J2', 'SdotS', 22, 30], \n    ['J2', 'SdotS', 25, 33], \n    ['J2', 'SdotS', 10, 0], \n    ['J2', 'SdotS', 13, 3], \n    ['J2', 'SdotS', 16, 6], \n    ['J2', 'SdotS', 7, 9], \n    ['J2', 'SdotS', 22, 12], \n    ['J2', 'SdotS', 25, 15], \n    ['J2', 'SdotS', 28, 18], \n    ['J2', 'SdotS', 19, 21], \n    ['J2', 'SdotS', 31, 24], \n    ['J2', 'SdotS', 34, 27], \n    ['J2', 'SdotS', 1, 30], \n    ['J2', 'SdotS', 4, 33], \n    ['J2', 'SdotS', 20, 1], \n    ['J2', 'SdotS', 32, 4], \n    ['J2', 'SdotS', 35, 7], \n    ['J2', 'SdotS', 29, 10], \n    ['J2', 'SdotS', 2, 13], \n    ['J2', 'SdotS', 5, 16], \n    ['J2', 'SdotS', 8, 19], \n    ['J2', 'SdotS', 11, 22], \n    ['J2', 'SdotS', 14, 25], \n    ['J2', 'SdotS', 17, 28], \n    ['J2', 'SdotS', 23, 31], \n    ['J2', 'SdotS', 26, 34], \n    ['J2', 'SdotS', 5, 1], \n    ['J2', 'SdotS', 8, 4], \n    ['J2', 'SdotS', 23, 7], \n    ['J2', 'SdotS', 14, 10], \n    ['J2', 'SdotS', 17, 13], \n    ['J2', 'SdotS', 20, 16], \n    ['J2', 'SdotS', 32, 19], \n    ['J2', 'SdotS', 26, 22], \n    ['J2', 'SdotS', 29, 25], \n    ['J2', 'SdotS', 2, 28], \n    ['J2', 'SdotS', 35, 31], \n    ['J2', 'SdotS', 11, 34], \n    ['J2', 'SdotS', 3, 2], \n    ['J2', 'SdotS', 6, 5], \n    ['J2', 'SdotS', 21, 8], \n    ['J2', 'SdotS', 12, 11], \n    ['J2', 'SdotS', 15, 14], \n    ['J2', 'SdotS', 18, 17], \n    ['J2', 'SdotS', 30, 20], \n    ['J2', 'SdotS', 24, 23], \n    ['J2', 'SdotS', 27, 26], \n    ['J2', 'SdotS', 0, 29], \n    ['J2', 'SdotS', 33, 32], \n    ['J2', 'SdotS', 9, 35], \n    ['J2', 'SdotS', 9, 2], \n    ['J2', 'SdotS', 12, 5], \n    ['J2', 'SdotS', 15, 8], \n    ['J2', 'SdotS', 6, 11], \n    ['J2', 'SdotS', 21, 14], \n    ['J2', 'SdotS', 24, 17], \n    ['J2', 'SdotS', 27, 20], \n    ['J2', 'SdotS', 18, 23], \n    ['J2', 'SdotS', 30, 26], \n    ['J2', 'SdotS', 33, 29], \n    ['J2', 'SdotS', 0, 32], \n    ['J2', 'SdotS', 3, 35],\n    ['J3', 'SdotS', 9, 0], \n    ['J3', 'SdotS', 12, 3], \n    ['J3', 'SdotS', 15, 6], \n    ['J3', 'SdotS', 6, 9], \n    ['J3', 'SdotS', 21, 12], \n    ['J3', 'SdotS', 24, 15], \n    ['J3', 'SdotS', 27, 18], \n    ['J3', 'SdotS', 18, 21], \n    ['J3', 'SdotS', 30, 24], \n    ['J3', 'SdotS', 33, 27], \n    ['J3', 'SdotS', 0, 30], \n    ['J3', 'SdotS', 3, 33], \n    ['J3', 'SdotS', 13, 1], \n    ['J3', 'SdotS', 16, 4], \n    ['J3', 'SdotS', 19, 7], \n    ['J3', 'SdotS', 22, 10], \n    ['J3', 'SdotS', 25, 13], \n    ['J3', 'SdotS', 28, 16], \n    ['J3', 'SdotS', 1, 19], \n    ['J3', 'SdotS', 31, 22], \n    ['J3', 'SdotS', 34, 25], \n    ['J3', 'SdotS', 10, 28], \n    ['J3', 'SdotS', 4, 31], \n    ['J3', 'SdotS', 7, 34], \n    ['J3', 'SdotS', 5, 2], \n    ['J3', 'SdotS', 8, 5], \n    ['J3', 'SdotS', 23, 8], \n    ['J3', 'SdotS', 14, 11], \n    ['J3', 'SdotS', 17, 14], \n    ['J3', 'SdotS', 20, 17], \n    ['J3', 'SdotS', 32, 20], \n    ['J3', 'SdotS', 26, 23], \n    ['J3', 'SdotS', 29, 26], \n    ['J3', 'SdotS', 2, 29], \n    ['J3', 'SdotS', 35, 32], \n    ['J3', 'SdotS', 11, 35]\n]\n\n\nSymmetries = [\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], \n  [3, 4, 5, 6, 7, 8, 21, 22, 23, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30, 31, 32, 24, 25, 26, 27, 28, 29, 0, 1, 2, 33, 34, 35, 9, 10, 11], \n  [6, 7, 8, 21, 22, 23, 24, 25, 26, 15, 16, 17, 18, 19, 20, 30, 31, 32, 33, 34, 35, 27, 28, 29, 0, 1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14], \n  [9, 10, 11, 12, 13, 14, 15, 16, 17, 6, 7, 8, 21, 22, 23, 24, 25, 26, 27, 28, 29, 18, 19, 20, 30, 31, 32, 33, 34, 35, 0, 1, 2, 3, 4, 5], \n  [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 0, 1, 2, 30, 31, 32, 33, 34, 35, 9, 10, 11, 3, 4, 5, 6, 7, 8], \n  [15, 16, 17, 18, 19, 20, 30, 31, 32, 24, 25, 26, 27, 28, 29, 0, 1, 2, 3, 4, 5, 33, 34, 35, 9, 10, 11, 12, 13, 14, 6, 7, 8, 21, 22, 23], \n  [18, 19, 20, 30, 31, 32, 33, 34, 35, 27, 28, 29, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 21, 22, 23, 24, 25, 26], \n  [21, 22, 23, 24, 25, 26, 27, 28, 29, 18, 19, 20, 30, 31, 32, 33, 34, 35, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 13, 14, 15, 16, 17], \n  [24, 25, 26, 27, 28, 29, 0, 1, 2, 30, 31, 32, 33, 34, 35, 9, 10, 11, 12, 13, 14, 3, 4, 5, 6, 7, 8, 21, 22, 23, 15, 16, 17, 18, 19, 20], \n  [27, 28, 29, 0, 1, 2, 3, 4, 5, 33, 34, 35, 9, 10, 11, 12, 13, 14, 15, 16, 17, 6, 7, 8, 21, 22, 23, 24, 25, 26, 18, 19, 20, 30, 31, 32], \n  [30, 31, 32, 33, 34, 35, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 21, 22, 23, 12, 13, 14, 15, 16, 17, 18, 19, 20, 24, 25, 26, 27, 28, 29], \n  [33, 34, 35, 9, 10, 11, 12, 13, 14, 3, 4, 5, 6, 7, 8, 21, 22, 23, 24, 25, 26, 15, 16, 17, 18, 19, 20, 30, 31, 32, 27, 28, 29, 0, 1, 2], \n  [35, 6, 4, 8, 18, 16, 20, 0, 28, 32, 3, 1, 5, 15, 13, 17, 27, 25, 29, 9, 34, 2, 12, 10, 14, 24, 22, 26, 33, 31, 11, 21, 7, 23, 30, 19], \n  [11, 21, 7, 23, 30, 19, 32, 3, 1, 35, 6, 4, 8, 18, 16, 20, 0, 28, 2, 12, 10, 5, 15, 13, 17, 27, 25, 29, 9, 34, 14, 24, 22, 26, 33, 31], \n  [14, 24, 22, 26, 33, 31, 35, 6, 4, 11, 21, 7, 23, 30, 19, 32, 3, 1, 5, 15, 13, 8, 18, 16, 20, 0, 28, 2, 12, 10, 17, 27, 25, 29, 9, 34], \n  [5, 15, 13, 17, 27, 25, 29, 9, 34, 2, 12, 10, 14, 24, 22, 26, 33, 31, 35, 6, 4, 11, 21, 7, 23, 30, 19, 32, 3, 1, 8, 18, 16, 20, 0, 28], \n  [8, 18, 16, 20, 0, 28, 2, 12, 10, 5, 15, 13, 17, 27, 25, 29, 9, 34, 11, 21, 7, 14, 24, 22, 26, 33, 31, 35, 6, 4, 23, 30, 19, 32, 3, 1], \n  [23, 30, 19, 32, 3, 1, 5, 15, 13, 8, 18, 16, 20, 0, 28, 2, 12, 10, 14, 24, 22, 17, 27, 25, 29, 9, 34, 11, 21, 7, 26, 33, 31, 35, 6, 4], \n  [26, 33, 31, 35, 6, 4, 8, 18, 16, 23, 30, 19, 32, 3, 1, 5, 15, 13, 17, 27, 25, 20, 0, 28, 2, 12, 10, 14, 24, 22, 29, 9, 34, 11, 21, 7], \n  [17, 27, 25, 29, 9, 34, 11, 21, 7, 14, 24, 22, 26, 33, 31, 35, 6, 4, 8, 18, 16, 23, 30, 19, 32, 3, 1, 5, 15, 13, 20, 0, 28, 2, 12, 10], \n  [20, 0, 28, 2, 12, 10, 14, 24, 22, 17, 27, 25, 29, 9, 34, 11, 21, 7, 23, 30, 19, 26, 33, 31, 35, 6, 4, 8, 18, 16, 32, 3, 1, 5, 15, 13], \n  [32, 3, 1, 5, 15, 13, 17, 27, 25, 20, 0, 28, 2, 12, 10, 14, 24, 22, 26, 33, 31, 29, 9, 34, 11, 21, 7, 23, 30, 19, 35, 6, 4, 8, 18, 16], \n  [29, 9, 34, 11, 21, 7, 23, 30, 19, 26, 33, 31, 35, 6, 4, 8, 18, 16, 20, 0, 28, 32, 3, 1, 5, 15, 13, 17, 27, 25, 2, 12, 10, 14, 24, 22], \n  [2, 12, 10, 14, 24, 22, 26, 33, 31, 29, 9, 34, 11, 21, 7, 23, 30, 19, 32, 3, 1, 35, 6, 4, 8, 18, 16, 20, 0, 28, 5, 15, 13, 17, 27, 25], \n  [19, 20, 18, 28, 29, 27, 34, 35, 33, 7, 8, 6, 16, 17, 15, 25, 26, 24, 31, 32, 30, 4, 5, 3, 13, 14, 12, 22, 23, 21, 1, 2, 0, 10, 11, 9], \n  [31, 32, 30, 1, 2, 0, 10, 11, 9, 22, 23, 21, 19, 20, 18, 28, 29, 27, 34, 35, 33, 7, 8, 6, 16, 17, 15, 25, 26, 24, 4, 5, 3, 13, 14, 12], \n  [34, 35, 33, 4, 5, 3, 13, 14, 12, 25, 26, 24, 31, 32, 30, 1, 2, 0, 10, 11, 9, 22, 23, 21, 19, 20, 18, 28, 29, 27, 7, 8, 6, 16, 17, 15], \n  [28, 29, 27, 34, 35, 33, 4, 5, 3, 16, 17, 15, 25, 26, 24, 31, 32, 30, 1, 2, 0, 13, 14, 12, 22, 23, 21, 19, 20, 18, 10, 11, 9, 7, 8, 6], \n  [1, 2, 0, 10, 11, 9, 7, 8, 6, 19, 20, 18, 28, 29, 27, 34, 35, 33, 4, 5, 3, 16, 17, 15, 25, 26, 24, 31, 32, 30, 13, 14, 12, 22, 23, 21], \n  [4, 5, 3, 13, 14, 12, 22, 23, 21, 31, 32, 30, 1, 2, 0, 10, 11, 9, 7, 8, 6, 19, 20, 18, 28, 29, 27, 34, 35, 33, 16, 17, 15, 25, 26, 24], \n  [7, 8, 6, 16, 17, 15, 25, 26, 24, 34, 35, 33, 4, 5, 3, 13, 14, 12, 22, 23, 21, 31, 32, 30, 1, 2, 0, 10, 11, 9, 19, 20, 18, 28, 29, 27], \n  [10, 11, 9, 7, 8, 6, 16, 17, 15, 28, 29, 27, 34, 35, 33, 4, 5, 3, 13, 14, 12, 25, 26, 24, 31, 32, 30, 1, 2, 0, 22, 23, 21, 19, 20, 18], \n  [13, 14, 12, 22, 23, 21, 19, 20, 18, 1, 2, 0, 10, 11, 9, 7, 8, 6, 16, 17, 15, 28, 29, 27, 34, 35, 33, 4, 5, 3, 25, 26, 24, 31, 32, 30], \n  [16, 17, 15, 25, 26, 24, 31, 32, 30, 4, 5, 3, 13, 14, 12, 22, 23, 21, 19, 20, 18, 1, 2, 0, 10, 11, 9, 7, 8, 6, 28, 29, 27, 34, 35, 33], \n  [22, 23, 21, 19, 20, 18, 28, 29, 27, 10, 11, 9, 7, 8, 6, 16, 17, 15, 25, 26, 24, 34, 35, 33, 4, 5, 3, 13, 14, 12, 31, 32, 30, 1, 2, 0], \n  [25, 26, 24, 31, 32, 30, 1, 2, 0, 13, 14, 12, 22, 23, 21, 19, 20, 18, 28, 29, 27, 10, 11, 9, 7, 8, 6, 16, 17, 15, 34, 35, 33, 4, 5, 3], \n  [9, 34, 29, 33, 31, 26, 30, 19, 23, 0, 28, 20, 27, 25, 17, 24, 22, 14, 21, 7, 11, 18, 16, 8, 15, 13, 5, 12, 10, 2, 6, 4, 35, 3, 1, 32], \n  [12, 10, 2, 9, 34, 29, 33, 31, 26, 3, 1, 32, 0, 28, 20, 27, 25, 17, 24, 22, 14, 30, 19, 23, 18, 16, 8, 15, 13, 5, 21, 7, 11, 6, 4, 35], \n  [15, 13, 5, 12, 10, 2, 9, 34, 29, 6, 4, 35, 3, 1, 32, 0, 28, 20, 27, 25, 17, 33, 31, 26, 30, 19, 23, 18, 16, 8, 24, 22, 14, 21, 7, 11], \n  [6, 4, 35, 3, 1, 32, 0, 28, 20, 9, 34, 29, 33, 31, 26, 30, 19, 23, 18, 16, 8, 27, 25, 17, 24, 22, 14, 21, 7, 11, 15, 13, 5, 12, 10, 2], \n  [21, 7, 11, 6, 4, 35, 3, 1, 32, 12, 10, 2, 9, 34, 29, 33, 31, 26, 30, 19, 23, 0, 28, 20, 27, 25, 17, 24, 22, 14, 18, 16, 8, 15, 13, 5], \n  [24, 22, 14, 21, 7, 11, 6, 4, 35, 15, 13, 5, 12, 10, 2, 9, 34, 29, 33, 31, 26, 3, 1, 32, 0, 28, 20, 27, 25, 17, 30, 19, 23, 18, 16, 8], \n  [27, 25, 17, 24, 22, 14, 21, 7, 11, 18, 16, 8, 15, 13, 5, 12, 10, 2, 9, 34, 29, 6, 4, 35, 3, 1, 32, 0, 28, 20, 33, 31, 26, 30, 19, 23], \n  [18, 16, 8, 15, 13, 5, 12, 10, 2, 21, 7, 11, 6, 4, 35, 3, 1, 32, 0, 28, 20, 9, 34, 29, 33, 31, 26, 30, 19, 23, 27, 25, 17, 24, 22, 14], \n  [30, 19, 23, 18, 16, 8, 15, 13, 5, 24, 22, 14, 21, 7, 11, 6, 4, 35, 3, 1, 32, 12, 10, 2, 9, 34, 29, 33, 31, 26, 0, 28, 20, 27, 25, 17], \n  [33, 31, 26, 30, 19, 23, 18, 16, 8, 27, 25, 17, 24, 22, 14, 21, 7, 11, 6, 4, 35, 15, 13, 5, 12, 10, 2, 9, 34, 29, 3, 1, 32, 0, 28, 20], \n  [0, 28, 20, 27, 25, 17, 24, 22, 14, 30, 19, 23, 18, 16, 8, 15, 13, 5, 12, 10, 2, 21, 7, 11, 6, 4, 35, 3, 1, 32, 9, 34, 29, 33, 31, 26], \n  [3, 1, 32, 0, 28, 20, 27, 25, 17, 33, 31, 26, 30, 19, 23, 18, 16, 8, 15, 13, 5, 24, 22, 14, 21, 7, 11, 6, 4, 35, 12, 10, 2, 9, 34, 29], \n  [32, 30, 31, 23, 21, 22, 11, 9, 10, 35, 33, 34, 26, 24, 25, 14, 12, 13, 2, 0, 1, 29, 27, 28, 17, 15, 16, 5, 3, 4, 20, 18, 19, 8, 6, 7], \n  [35, 33, 34, 26, 24, 25, 14, 12, 13, 11, 9, 10, 29, 27, 28, 17, 15, 16, 5, 3, 4, 2, 0, 1, 20, 18, 19, 8, 6, 7, 32, 30, 31, 23, 21, 22], \n  [11, 9, 10, 29, 27, 28, 17, 15, 16, 14, 12, 13, 2, 0, 1, 20, 18, 19, 8, 6, 7, 5, 3, 4, 32, 30, 31, 23, 21, 22, 35, 33, 34, 26, 24, 25], \n  [2, 0, 1, 20, 18, 19, 8, 6, 7, 5, 3, 4, 32, 30, 31, 23, 21, 22, 11, 9, 10, 35, 33, 34, 26, 24, 25, 14, 12, 13, 29, 27, 28, 17, 15, 16], \n  [5, 3, 4, 32, 30, 31, 23, 21, 22, 8, 6, 7, 35, 33, 34, 26, 24, 25, 14, 12, 13, 11, 9, 10, 29, 27, 28, 17, 15, 16, 2, 0, 1, 20, 18, 19], \n  [8, 6, 7, 35, 33, 34, 26, 24, 25, 23, 21, 22, 11, 9, 10, 29, 27, 28, 17, 15, 16, 14, 12, 13, 2, 0, 1, 20, 18, 19, 5, 3, 4, 32, 30, 31], \n  [23, 21, 22, 11, 9, 10, 29, 27, 28, 26, 24, 25, 14, 12, 13, 2, 0, 1, 20, 18, 19, 17, 15, 16, 5, 3, 4, 32, 30, 31, 8, 6, 7, 35, 33, 34], \n  [14, 12, 13, 2, 0, 1, 20, 18, 19, 17, 15, 16, 5, 3, 4, 32, 30, 31, 23, 21, 22, 8, 6, 7, 35, 33, 34, 26, 24, 25, 11, 9, 10, 29, 27, 28], \n  [17, 15, 16, 5, 3, 4, 32, 30, 31, 20, 18, 19, 8, 6, 7, 35, 33, 34, 26, 24, 25, 23, 21, 22, 11, 9, 10, 29, 27, 28, 14, 12, 13, 2, 0, 1], \n  [20, 18, 19, 8, 6, 7, 35, 33, 34, 32, 30, 31, 23, 21, 22, 11, 9, 10, 29, 27, 28, 26, 24, 25, 14, 12, 13, 2, 0, 1, 17, 15, 16, 5, 3, 4], \n  [26, 24, 25, 14, 12, 13, 2, 0, 1, 29, 27, 28, 17, 15, 16, 5, 3, 4, 32, 30, 31, 20, 18, 19, 8, 6, 7, 35, 33, 34, 23, 21, 22, 11, 9, 10], \n  [29, 27, 28, 17, 15, 16, 5, 3, 4, 2, 0, 1, 20, 18, 19, 8, 6, 7, 35, 33, 34, 32, 30, 31, 23, 21, 22, 11, 9, 10, 26, 24, 25, 14, 12, 13], \n  [7, 11, 21, 10, 2, 12, 1, 32, 3, 19, 23, 30, 22, 14, 24, 13, 5, 15, 4, 35, 6, 31, 26, 33, 25, 17, 27, 16, 8, 18, 34, 29, 9, 28, 20, 0], \n  [22, 14, 24, 13, 5, 15, 4, 35, 6, 31, 26, 33, 25, 17, 27, 16, 8, 18, 7, 11, 21, 34, 29, 9, 28, 20, 0, 19, 23, 30, 10, 2, 12, 1, 32, 3], \n  [25, 17, 27, 16, 8, 18, 7, 11, 21, 34, 29, 9, 28, 20, 0, 19, 23, 30, 22, 14, 24, 10, 2, 12, 1, 32, 3, 31, 26, 33, 13, 5, 15, 4, 35, 6], \n  [16, 8, 18, 7, 11, 21, 10, 2, 12, 28, 20, 0, 19, 23, 30, 22, 14, 24, 13, 5, 15, 1, 32, 3, 31, 26, 33, 25, 17, 27, 4, 35, 6, 34, 29, 9], \n  [19, 23, 30, 22, 14, 24, 13, 5, 15, 1, 32, 3, 31, 26, 33, 25, 17, 27, 16, 8, 18, 4, 35, 6, 34, 29, 9, 28, 20, 0, 7, 11, 21, 10, 2, 12], \n  [31, 26, 33, 25, 17, 27, 16, 8, 18, 4, 35, 6, 34, 29, 9, 28, 20, 0, 19, 23, 30, 7, 11, 21, 10, 2, 12, 1, 32, 3, 22, 14, 24, 13, 5, 15], \n  [34, 29, 9, 28, 20, 0, 19, 23, 30, 7, 11, 21, 10, 2, 12, 1, 32, 3, 31, 26, 33, 22, 14, 24, 13, 5, 15, 4, 35, 6, 25, 17, 27, 16, 8, 18], \n  [28, 20, 0, 19, 23, 30, 22, 14, 24, 10, 2, 12, 1, 32, 3, 31, 26, 33, 25, 17, 27, 13, 5, 15, 4, 35, 6, 34, 29, 9, 16, 8, 18, 7, 11, 21], \n  [1, 32, 3, 31, 26, 33, 25, 17, 27, 13, 5, 15, 4, 35, 6, 34, 29, 9, 28, 20, 0, 16, 8, 18, 7, 11, 21, 10, 2, 12, 19, 23, 30, 22, 14, 24], \n  [4, 35, 6, 34, 29, 9, 28, 20, 0, 16, 8, 18, 7, 11, 21, 10, 2, 12, 1, 32, 3, 19, 23, 30, 22, 14, 24, 13, 5, 15, 31, 26, 33, 25, 17, 27], \n  [10, 2, 12, 1, 32, 3, 31, 26, 33, 22, 14, 24, 13, 5, 15, 4, 35, 6, 34, 29, 9, 25, 17, 27, 16, 8, 18, 7, 11, 21, 28, 20, 0, 19, 23, 30], \n  [13, 5, 15, 4, 35, 6, 34, 29, 9, 25, 17, 27, 16, 8, 18, 7, 11, 21, 10, 2, 12, 28, 20, 0, 19, 23, 30, 22, 14, 24, 1, 32, 3, 31, 26, 33]\n]\n\n# Irreducible representations\n[Gamma.C6.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C6.B]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C6.E1a]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C6.E1b]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C6.E2a]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [0.5000000000000001, 0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-1.0, 0.0],\n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C6.E2b]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [0.5000000000000001, -0.8660254037844386], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-0.49999999999999983, -0.8660254037844387], \n  [-1.0, 0.0],\n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [-0.5000000000000001, 0.8660254037844386], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387], \n  [0.49999999999999983, 0.8660254037844387]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[K.C3.A]\ncharacters = [\n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5, 0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [-0.5, -0.8660254037844386], \n  [1.0, 0.0]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]\nmomentum = [2.0943951023931953, 3.627598728468436]\n\n[K.C3.Ea]\ncharacters = [\n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]\nmomentum = [2.0943951023931953, 3.627598728468436]\n\n[K.C3.Eb]\ncharacters = [\n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-0.5000000000000001, -0.8660254037844386], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-0.49999999999999983, 0.8660254037844387]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]\nmomentum = [2.0943951023931953, 3.627598728468436]\n\n[M.C2.A]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]\nmomentum = [0.0, 3.627598728468436]\n\n[M.C2.B]\ncharacters = [\n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [-1.0, 0.0], \n  [1.0, 0.0], \n  [1.0, 0.0]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]\nmomentum = [0.0, 3.627598728468436]\n\n[Z.C1.A]\ncharacters = [\n  [1.0, 0.0], \n  [0.5000000000000001, 0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [0.5000000000000001, 0.8660254037844386], \n  [-0.49999999999999983, 0.8660254037844387], \n  [-1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [-1.0, 0.0], \n  [-0.5000000000000001, -0.8660254037844386], \n  [0.49999999999999983, -0.8660254037844387], \n  [0.49999999999999983, -0.8660254037844387], \n  [1.0, 0.0]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nmomentum = [1.0471975511965976, 1.813799364234218]\n</code></pre> <p>To run the above C++ code with the toml file, one needs to execute the following command </p> <p><pre><code>./build/main n_sites n_up kname J1 J2 J3 seed\n</code></pre> where the n_sites, n_up, kname, J1, and seed are to be replaced by their values such as 32, 16, Gamma.C6.A, 1.00, -1.00, -2.00, 1, respectively. The Julia code below was used to generate the plot above from the data obtaining running the above code.</p> <p>Plotting Script</p> Julia <pre><code>using LinearAlgebra\nusing Plots\nusing Combinatorics\n# using BenchmarkTools\nusing Kronecker\nusing LaTeXStrings\nusing Arpack\n# using KernelDensity\nusing Interpolations\nusing SparseArrays\n# using ArnoldiMethod\nusing KrylovKit\nusing JLD2\nusing HDF5\nusing Printf\nplot_font = \"Computer Modern\"\ndefault(\n    fontfamily=plot_font,\n    linewidth=2, \n    framestyle=:box, \n    # xtickfont=font(18),\n    label=nothing,\n    left_margin=8Plots.mm,\n    bottom_margin=2Plots.mm\n    # ytickfont=font(18),\n    # legendfont=font(18)\n)\ncolors = palette(:default)#palette(:thermal,length(14:div(n_sites,2))+1)\nmarkers = filter((m-&gt;begin\n                m in Plots.supported_markers()\n            end), Plots._shape_keys)\n\n\nn_sites=36\nn_seeds = 1\nks=[\"Gamma.C6.A\", \"Gamma.C6.B\", \"Gamma.C6.E1a\", \"Gamma.C6.E1b\", \"Gamma.C6.E2a\", \"Gamma.C6.E2b\", \"K.C3.A\", \"K.C3.Ea\", \"K.C3.Eb\", \"M.C2.A\", \"M.C2.B\"]#, \"Z.C1.A\", \"Delta.C1.A\", \"Sigma.C1.A\", \"Z0.C1.A\", \"Z1.C1.A\"]\nksl=[\"\u0393.C6.A\", \"\u0393.C6.B\", \"\u0393.C6.E1a\", \"\u0393.C6.E1b\", \"\u0393.C6.E2a\", \"\u0393.C6.E2b\", \"K.C3.A\", \"K.C3.Ea\", \"K.C3.Eb\", \"M.C2.A\", \"M.C2.B\"]\nseeds = [i for i=1:n_seeds]\nnup_start=10\nn_ups = [i for i=nup_start:(div(n_sites,2))]#\n\nJ1=1.00\nJ2=-1.0\nJ3=-2.0\nn_eigs = 10\n\nfor seed in seeds\n    plot(xlabel=L\"S_z\",ylabel=L\"E/J_1\",ylims=(-0.02,1),xlims=(-0.1,10),dpi=400,xticks=(0:2:10,[string(i) for i=0:2:10]))\n    mineig = 0\n    eigvs = []\n    Sz = []\n    f = h5open(@sprintf(\"outfile.kagome.%d.J1.%.2f.J2.%.2f.J3.%.2f.nup.%d.k.%s.seed.%d.h5\",n_sites,J1,J2,J3,div(n_sites,2),\"Gamma.C6.A\",seed), \"r\")\n    mineig = read(f[\"Eigenvalues\"])[1]\n    for n_up=n_ups\n        c=0\n        for k in ks\n            c=c+1\n            f = h5open(@sprintf(\"outfile.kagome.%d.J1.%.2f.J2.%.2f.J3.%.2f.nup.%d.k.%s.seed.%d.h5\",n_sites,J1,J2,J3,n_up,k,seed), \"r\")\n            eig = read(f[\"Eigenvalues\"])[1:n_eigs].-mineig\n            sz=abs(n_up- n_sites / 2)*[1 for i=1:n_eigs]\n            if n_up==nup_start\n                plot!(sz,eig,seriestype=:scatter,m=markers[c],mc=colors[c],label=ksl[c])\n            else\n                plot!(sz,eig,seriestype=:scatter,m=markers[c],mc=colors[c],primary=false)\n            end\n            close(f)\n        end\n    end\n    savefig(@sprintf(\"outfile.kagome.%d.J1.%.2f.J2.%.2f.J3.%.2f.seed.%d-n.png\",n_sites,J1,J2,J3,seed))\nend\n</code></pre>"},{"location":"examples/tos_quad_kagome/#references","title":"references","text":"<p>[1] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p> <p>[2] Wietek, Alexander, and Andreas M. L\u00e4uchli. \"Valence bond solid and possible deconfined quantum criticality in an extended kagome lattice Heisenberg antiferromagnet.\" Physical Review B 102.2 (2020): 020411</p>"},{"location":"examples/tos_square_Heisenberg/","title":"TOS Heisenberg model on a square lattice","text":"<p>Author Siddhartha Sarkar</p> <p>We perform a tower of states (TOS) analysis [1] of the Heisenberg model on a square lattice under periodic boundary condition. This model consists of spin \\(\\frac{1}{2}\\) sites at the vertices of square lattice with nearest-neighbor antiferromagnetic Heisenberg couplings such that the Hamiltonian has the form</p> \\[ \\mathcal{H} = J\\sum_{\\langle i,j\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>The TOS analysis provides strong evidence for spontaneous symmetry breaking (SSB) in the thermodynamic limit, as the ground state of a finite system is completely symmetric. </p> <p>The spectrum of this model can be labeled by total magnetization since \\([\\mathcal{H},S_z]=0\\) (in fact the Hamiltonian is \\(SU(2)\\), and hence the spectrum can be labeled by \\(S^2\\) and \\(S_z\\); but for obtaining the eigen-spectrum, we only use \\(S_z\\)). To perform the TOS analysis, we converged the lowest-lying eigenvalues using the Lanczos algorithm in each symmetry sector. We then determined the total spin quantum number, \\(S_{\\text{tot}}\\), by inspecting, for each energy level, the number of degenerate eigenstates; thus, \\(S_{\\text{tot}}\\) is given by the maximum \\(S_z\\). Finally, we plotted the energy spectra as a function of \\(S_{\\text{tot}}\\left(S_{\\text{tot}} + 1\\right)\\). </p> <p></p> <p>In the figure above, we show the energy spectra as a function of \\(S_{\\text{tot}}\\left(S_{\\text{tot}} + 1\\right)\\) for a \\(C_{4}\\) symmetric a system of \\(N=32\\) sites. In this case, the ground state exhibits a N\u00e9el order.</p> C++ <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nint main(int argc, char **argv) {\n  using namespace xdiag;\n  using namespace arma;\n  using fmt::format;\n\n  say_hello();\n\n  // Parse input arguments\n  assert(argc == 6);\n  int n_sites = atoi(argv[1]);              // number of sites\n  int n_up = atoi(argv[2]);                 // number of upspins\n  std::string kname = std::string(argv[3]); // momentum k\n  double J1 = atof(argv[4]);\n  int seed = atoi(argv[5]);\n\n  Log(\"Diagonalizing H in block nup: {}, k: {}\", n_up, kname);\n\n  auto lfile = FileToml(format(\"square.{}.J1.fsl.pbc.toml\", n_sites));\n  std::string ofilename =\n      format(\"outfile.square.{}.J1.{:.2f}.nup.{}.k.{}.seed.{}.h5\", n_sites, J1,\n             n_up, kname, seed);\n  auto ofile = FileH5(ofilename, \"w!\");\n\n  OpSum ops = read_opsum(lfile, \"Interactions\");\n  ops[\"J1\"] = J1;\n  auto irrep = read_representation(lfile, kname);\n\n  Log(\"Creating block ...\");\n  tic();\n  auto block = Spinhalf(n_sites, n_up, irrep);\n  toc();\n  Log(\"Dimension: {}\", block.size());\n\n  Log(\"Running Lanczos ...\");\n  tic();\n  int n_eig_to_converge = 2;\n  int max_iterations = 40;\n  auto tmat = eigvals_lanczos(ops, block, n_eig_to_converge, 1e-12,\n                              max_iterations, 1e-7, seed);\n  toc();\n\n  ofile[\"Alphas\"] = tmat.alphas;\n  ofile[\"Betas\"] = tmat.betas;\n  ofile[\"Eigenvalues\"] = tmat.eigenvalues;\n  ofile[\"Dimension\"] = block.size();\n\n  return EXIT_SUCCESS;\n}\n</code></pre> <p>The interactions terms and the symmetry representation inputs are given in the following TOML file:</p> toml <pre><code># This modelfile was created with the following properties:\n# Basis coordinates: (0.0, 0.0)\n# Lattice vectors: a1=(1.0, 0.0), a2=(0.0, 1.0)\n# Simulation torus vectors: t1=(4, 4), t2=(4, -4)\n# Simulation torus matrix: ((4, 4), (4, -4))\n# Symmetry center: (0.0, 0.0)\n# Lattice Point Group: D4\n# Lattice Space Group (infinite Lattice): D4\n# K points (K wedge marked with *):\n# [3.141592653589793 3.141592653589793] *\n# [3.141592653589793 1.5707963267948966] *\n# [3.141592653589793 0.0] *\n# [3.141592653589793 -1.5707963267948966] *\n# [2.356194490192345 2.356194490192345] *\n# [2.356194490192345 0.7853981633974483] *\n# [2.356194490192345 -0.7853981633974483] *\n# [2.356194490192345 -2.356194490192345]\n# [1.5707963267948966 3.141592653589793]\n# [1.5707963267948966 1.5707963267948966] *\n# [1.5707963267948966 0.0] *\n# [1.5707963267948966 -1.5707963267948966]\n# [0.7853981633974483 2.356194490192345]\n# [0.7853981633974483 0.7853981633974483] *\n# [0.7853981633974483 -0.7853981633974483]\n# [0.7853981633974483 -2.356194490192345]\n# [0.0 3.141592653589793]\n# [0.0 1.5707963267948966]\n# [0.0 0.0] *\n# [0.0 -1.5707963267948966]\n# [-0.7853981633974483 2.356194490192345]\n# [-0.7853981633974483 0.7853981633974483]\n# [-0.7853981633974483 -0.7853981633974483]\n# [-0.7853981633974483 -2.356194490192345]\n# [-1.5707963267948966 3.141592653589793]\n# [-1.5707963267948966 1.5707963267948966]\n# [-1.5707963267948966 0.0]\n# [-1.5707963267948966 -1.5707963267948966]\n# [-2.356194490192345 2.356194490192345]\n# [-2.356194490192345 0.7853981633974483]\n# [-2.356194490192345 -0.7853981633974483]\n# [-2.356194490192345 -2.356194490192345]\n# High Symmetry Points: M.C4, Z_0.C1, X.C2, Z_1.C1, Sigma_0.C1, None_0.C1, None_1.C1, Sigma_1.C1, Delta.C1, Sigma_2.C1, Gamma.C4,\n# Eccentricity: --\n\nCoordinates = [\n  [0.0, 0.0],\n  [2.0, -2.0],\n  [2.0, 0.0],\n  [2.0, 2.0],\n  [4.0, -2.0],\n  [4.0, 0.0],\n  [4.0, 2.0],\n  [6.0, 0.0],\n  [1.0, 0.0],\n  [3.0, -2.0],\n  [3.0, 0.0],\n  [3.0, 2.0],\n  [5.0, -2.0],\n  [5.0, 0.0],\n  [5.0, 2.0],\n  [7.0, 0.0],\n  [2.0, -1.0],\n  [2.0, 1.0],\n  [4.0, -3.0],\n  [4.0, -1.0],\n  [4.0, 1.0],\n  [4.0, 3.0],\n  [6.0, -1.0],\n  [6.0, 1.0],\n  [1.0, -1.0],\n  [1.0, 1.0],\n  [3.0, -3.0],\n  [3.0, -1.0],\n  [3.0, 1.0],\n  [3.0, 3.0],\n  [5.0, -1.0],\n  [5.0, 1.0]\n]\n\nInteractions = [\n  ['J1', 'SdotS', 0, 18],\n  ['J1', 'SdotS', 8, 25],\n  ['J1', 'SdotS', 25, 12],\n  ['J1', 'SdotS', 24, 8],\n  ['J1', 'SdotS', 2, 17],\n  ['J1', 'SdotS', 17, 3],\n  ['J1', 'SdotS', 3, 22],\n  ['J1', 'SdotS', 1, 16],\n  ['J1', 'SdotS', 16, 2],\n  ['J1', 'SdotS', 10, 28],\n  ['J1', 'SdotS', 28, 11],\n  ['J1', 'SdotS', 11, 29],\n  ['J1', 'SdotS', 29, 15],\n  ['J1', 'SdotS', 26, 9],\n  ['J1', 'SdotS', 9, 27],\n  ['J1', 'SdotS', 27, 10],\n  ['J1', 'SdotS', 5, 20],\n  ['J1', 'SdotS', 20, 6],\n  ['J1', 'SdotS', 6, 21],\n  ['J1', 'SdotS', 21, 0],\n  ['J1', 'SdotS', 18, 4],\n  ['J1', 'SdotS', 4, 19],\n  ['J1', 'SdotS', 19, 5],\n  ['J1', 'SdotS', 13, 31],\n  ['J1', 'SdotS', 31, 14],\n  ['J1', 'SdotS', 14, 24],\n  ['J1', 'SdotS', 12, 30],\n  ['J1', 'SdotS', 30, 13],\n  ['J1', 'SdotS', 7, 23],\n  ['J1', 'SdotS', 23, 1],\n  ['J1', 'SdotS', 22, 7],\n  ['J1', 'SdotS', 15, 26],\n  ['J1', 'SdotS', 0, 8],\n  ['J1', 'SdotS', 8, 2],\n  ['J1', 'SdotS', 25, 17],\n  ['J1', 'SdotS', 24, 16],\n  ['J1', 'SdotS', 2, 10],\n  ['J1', 'SdotS', 17, 28],\n  ['J1', 'SdotS', 3, 11],\n  ['J1', 'SdotS', 1, 9],\n  ['J1', 'SdotS', 16, 27],\n  ['J1', 'SdotS', 10, 5],\n  ['J1', 'SdotS', 28, 20],\n  ['J1', 'SdotS', 11, 6],\n  ['J1', 'SdotS', 29, 21],\n  ['J1', 'SdotS', 26, 18],\n  ['J1', 'SdotS', 9, 4],\n  ['J1', 'SdotS', 27, 19],\n  ['J1', 'SdotS', 5, 13],\n  ['J1', 'SdotS', 20, 31],\n  ['J1', 'SdotS', 6, 14],\n  ['J1', 'SdotS', 21, 24],\n  ['J1', 'SdotS', 18, 25],\n  ['J1', 'SdotS', 4, 12],\n  ['J1', 'SdotS', 19, 30],\n  ['J1', 'SdotS', 13, 7],\n  ['J1', 'SdotS', 31, 23],\n  ['J1', 'SdotS', 14, 1],\n  ['J1', 'SdotS', 12, 3],\n  ['J1', 'SdotS', 30, 22],\n  ['J1', 'SdotS', 7, 15],\n  ['J1', 'SdotS', 23, 26],\n  ['J1', 'SdotS', 22, 29],\n  ['J1', 'SdotS', 15, 0]\n]\n\nSymmetries = [\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],\n  [1, 0, 4, 5, 2, 3, 7, 6, 9, 8, 12, 13, 10, 11, 15, 14, 18, 19, 16, 17, 22, 23, 20, 21, 26, 27, 24, 25, 30, 31, 28, 29],\n  [2, 4, 5, 6, 3, 7, 1, 0, 10, 12, 13, 14, 11, 15, 9, 8, 19, 20, 17, 22, 23, 16, 21, 18, 27, 28, 25, 30, 31, 24, 29, 26],\n  [3, 5, 6, 0, 7, 1, 2, 4, 11, 13, 14, 8, 15, 9, 10, 12, 20, 21, 22, 23, 16, 17, 18, 19, 28, 29, 30, 31, 24, 25, 26, 27],\n  [4, 2, 3, 7, 5, 6, 0, 1, 12, 10, 11, 15, 13, 14, 8, 9, 17, 22, 19, 20, 21, 18, 23, 16, 25, 30, 27, 28, 29, 26, 31, 24],\n  [5, 3, 7, 1, 6, 0, 4, 2, 13, 11, 15, 9, 14, 8, 12, 10, 22, 23, 20, 21, 18, 19, 16, 17, 30, 31, 28, 29, 26, 27, 24, 25],\n  [6, 7, 1, 2, 0, 4, 5, 3, 14, 15, 9, 10, 8, 12, 13, 11, 23, 16, 21, 18, 19, 20, 17, 22, 31, 24, 29, 26, 27, 28, 25, 30],\n  [7, 6, 0, 4, 1, 2, 3, 5, 15, 14, 8, 12, 9, 10, 11, 13, 21, 18, 23, 16, 17, 22, 19, 20, 29, 26, 31, 24, 25, 30, 27, 28],\n  [0, 3, 4, 1, 7, 5, 2, 6, 18, 22, 19, 16, 23, 20, 17, 21, 12, 9, 15, 13, 10, 8, 14, 11, 25, 26, 29, 30, 27, 24, 31, 28],\n  [1, 5, 2, 0, 6, 3, 4, 7, 16, 20, 17, 18, 21, 22, 19, 23, 10, 8, 14, 11, 12, 9, 15, 13, 27, 24, 31, 28, 25, 26, 29, 30],\n  [2, 6, 3, 4, 0, 7, 5, 1, 17, 21, 22, 19, 18, 23, 20, 16, 11, 12, 8, 15, 13, 10, 9, 14, 28, 25, 24, 29, 30, 27, 26, 31],\n  [3, 0, 7, 5, 4, 1, 6, 2, 22, 18, 23, 20, 19, 16, 21, 17, 15, 13, 12, 9, 14, 11, 10, 8, 29, 30, 25, 26, 31, 28, 27, 24],\n  [4, 7, 5, 2, 1, 6, 3, 0, 19, 23, 20, 17, 16, 21, 22, 18, 13, 10, 9, 14, 11, 12, 8, 15, 30, 27, 26, 31, 28, 25, 24, 29],\n  [5, 1, 6, 3, 2, 0, 7, 4, 20, 16, 21, 22, 17, 18, 23, 19, 14, 11, 10, 8, 15, 13, 12, 9, 31, 28, 27, 24, 29, 30, 25, 26],\n  [6, 2, 0, 7, 3, 4, 1, 5, 21, 17, 18, 23, 22, 19, 16, 20, 8, 15, 11, 12, 9, 14, 13, 10, 24, 29, 28, 25, 26, 31, 30, 27],\n  [7, 4, 1, 6, 5, 2, 0, 3, 23, 19, 16, 21, 20, 17, 18, 22, 9, 14, 13, 10, 8, 15, 11, 12, 26, 31, 30, 27, 24, 29, 28, 25],\n  [0, 1, 7, 3, 6, 5, 4, 2, 15, 14, 13, 12, 11, 10, 9, 8, 23, 22, 21, 20, 19, 18, 17, 16, 26, 29, 24, 31, 30, 25, 28, 27],\n  [1, 0, 6, 5, 7, 3, 2, 4, 14, 15, 11, 10, 13, 12, 8, 9, 21, 20, 23, 22, 17, 16, 19, 18, 24, 31, 26, 29, 28, 27, 30, 25],\n  [2, 4, 0, 6, 1, 7, 3, 5, 8, 9, 15, 11, 14, 13, 12, 10, 18, 21, 16, 23, 22, 17, 20, 19, 25, 24, 27, 26, 29, 28, 31, 30],\n  [3, 5, 4, 0, 2, 1, 7, 6, 12, 10, 9, 15, 8, 14, 13, 11, 19, 18, 17, 16, 23, 22, 21, 20, 30, 25, 28, 27, 26, 29, 24, 31],\n  [4, 2, 1, 7, 0, 6, 5, 3, 9, 8, 14, 13, 15, 11, 10, 12, 16, 23, 18, 21, 20, 19, 22, 17, 27, 26, 25, 24, 31, 30, 29, 28],\n  [5, 3, 2, 1, 4, 0, 6, 7, 10, 12, 8, 14, 9, 15, 11, 13, 17, 16, 19, 18, 21, 20, 23, 22, 28, 27, 30, 25, 24, 31, 26, 29],\n  [6, 7, 3, 2, 5, 4, 0, 1, 11, 13, 12, 8, 10, 9, 15, 14, 22, 17, 20, 19, 18, 21, 16, 23, 29, 28, 31, 30, 25, 24, 27, 26],\n  [7, 6, 5, 4, 3, 2, 1, 0, 13, 11, 10, 9, 12, 8, 14, 15, 20, 19, 22, 17, 16, 23, 18, 21, 31, 30, 29, 28, 27, 26, 25, 24],\n  [0, 3, 6, 1, 2, 5, 7, 4, 21, 17, 20, 23, 16, 19, 22, 18, 11, 14, 8, 10, 13, 15, 9, 12, 29, 24, 25, 28, 31, 26, 27, 30],\n  [1, 5, 7, 0, 4, 3, 6, 2, 23, 19, 22, 21, 18, 17, 20, 16, 13, 15, 9, 12, 11, 14, 8, 10, 31, 26, 27, 30, 29, 24, 25, 28],\n  [2, 6, 1, 4, 5, 7, 0, 3, 16, 20, 23, 18, 19, 22, 21, 17, 14, 9, 10, 13, 15, 8, 12, 11, 24, 27, 28, 31, 26, 25, 30, 29],\n  [3, 0, 2, 5, 6, 1, 4, 7, 17, 21, 16, 19, 20, 23, 18, 22, 8, 10, 11, 14, 9, 12, 13, 15, 25, 28, 29, 24, 27, 30, 31, 26],\n  [4, 7, 0, 2, 3, 6, 1, 5, 18, 22, 21, 16, 17, 20, 23, 19, 15, 8, 12, 11, 14, 9, 10, 13, 26, 25, 30, 29, 24, 27, 28, 31],\n  [5, 1, 4, 3, 7, 0, 2, 6, 19, 23, 18, 17, 22, 21, 16, 20, 9, 12, 13, 15, 8, 10, 11, 14, 27, 30, 31, 26, 25, 28, 29, 24],\n  [6, 2, 5, 7, 1, 4, 3, 0, 20, 16, 19, 22, 23, 18, 17, 21, 10, 13, 14, 9, 12, 11, 15, 8, 28, 31, 24, 27, 30, 29, 26, 25],\n  [7, 4, 3, 6, 0, 2, 5, 1, 22, 18, 17, 20, 21, 16, 19, 23, 12, 11, 15, 8, 10, 13, 14, 9, 30, 29, 26, 25, 28, 31, 24, 27],\n  [8, 9, 10, 11, 12, 13, 14, 15, 2, 4, 5, 6, 3, 7, 1, 0, 27, 28, 25, 30, 31, 24, 29, 26, 16, 17, 18, 19, 20, 21, 22, 23],\n  [9, 8, 12, 13, 10, 11, 15, 14, 4, 2, 3, 7, 5, 6, 0, 1, 25, 30, 27, 28, 29, 26, 31, 24, 18, 19, 16, 17, 22, 23, 20, 21],\n  [10, 12, 13, 14, 11, 15, 9, 8, 5, 3, 7, 1, 6, 0, 4, 2, 30, 31, 28, 29, 26, 27, 24, 25, 19, 20, 17, 22, 23, 16, 21, 18],\n  [11, 13, 14, 8, 15, 9, 10, 12, 6, 7, 1, 2, 0, 4, 5, 3, 31, 24, 29, 26, 27, 28, 25, 30, 20, 21, 22, 23, 16, 17, 18, 19],\n  [12, 10, 11, 15, 13, 14, 8, 9, 3, 5, 6, 0, 7, 1, 2, 4, 28, 29, 30, 31, 24, 25, 26, 27, 17, 22, 19, 20, 21, 18, 23, 16],\n  [13, 11, 15, 9, 14, 8, 12, 10, 7, 6, 0, 4, 1, 2, 3, 5, 29, 26, 31, 24, 25, 30, 27, 28, 22, 23, 20, 21, 18, 19, 16, 17],\n  [14, 15, 9, 10, 8, 12, 13, 11, 1, 0, 4, 5, 2, 3, 7, 6, 26, 27, 24, 25, 30, 31, 28, 29, 23, 16, 21, 18, 19, 20, 17, 22],\n  [15, 14, 8, 12, 9, 10, 11, 13, 0, 1, 2, 3, 4, 5, 6, 7, 24, 25, 26, 27, 28, 29, 30, 31, 21, 18, 23, 16, 17, 22, 19, 20],\n  [16, 20, 17, 18, 21, 22, 19, 23, 2, 6, 3, 4, 0, 7, 5, 1, 28, 25, 24, 29, 30, 27, 26, 31, 10, 8, 14, 11, 12, 9, 15, 13],\n  [17, 21, 22, 19, 18, 23, 20, 16, 3, 0, 7, 5, 4, 1, 6, 2, 29, 30, 25, 26, 31, 28, 27, 24, 11, 12, 8, 15, 13, 10, 9, 14],\n  [18, 22, 19, 16, 23, 20, 17, 21, 4, 7, 5, 2, 1, 6, 3, 0, 30, 27, 26, 31, 28, 25, 24, 29, 12, 9, 15, 13, 10, 8, 14, 11],\n  [19, 23, 20, 17, 16, 21, 22, 18, 5, 1, 6, 3, 2, 0, 7, 4, 31, 28, 27, 24, 29, 30, 25, 26, 13, 10, 9, 14, 11, 12, 8, 15],\n  [20, 16, 21, 22, 17, 18, 23, 19, 6, 2, 0, 7, 3, 4, 1, 5, 24, 29, 28, 25, 26, 31, 30, 27, 14, 11, 10, 8, 15, 13, 12, 9],\n  [21, 17, 18, 23, 22, 19, 16, 20, 0, 3, 4, 1, 7, 5, 2, 6, 25, 26, 29, 30, 27, 24, 31, 28, 8, 15, 11, 12, 9, 14, 13, 10],\n  [22, 18, 23, 20, 19, 16, 21, 17, 7, 4, 1, 6, 5, 2, 0, 3, 26, 31, 30, 27, 24, 29, 28, 25, 15, 13, 12, 9, 14, 11, 10, 8],\n  [23, 19, 16, 21, 20, 17, 18, 22, 1, 5, 2, 0, 6, 3, 4, 7, 27, 24, 31, 28, 25, 26, 29, 30, 9, 14, 13, 10, 8, 15, 11, 12],\n  [8, 9, 15, 11, 14, 13, 12, 10, 0, 1, 7, 3, 6, 5, 4, 2, 26, 29, 24, 31, 30, 25, 28, 27, 18, 21, 16, 23, 22, 17, 20, 19],\n  [9, 8, 14, 13, 15, 11, 10, 12, 1, 0, 6, 5, 7, 3, 2, 4, 24, 31, 26, 29, 28, 27, 30, 25, 16, 23, 18, 21, 20, 19, 22, 17],\n  [10, 12, 8, 14, 9, 15, 11, 13, 2, 4, 0, 6, 1, 7, 3, 5, 25, 24, 27, 26, 29, 28, 31, 30, 17, 16, 19, 18, 21, 20, 23, 22],\n  [11, 13, 12, 8, 10, 9, 15, 14, 3, 5, 4, 0, 2, 1, 7, 6, 30, 25, 28, 27, 26, 29, 24, 31, 22, 17, 20, 19, 18, 21, 16, 23],\n  [12, 10, 9, 15, 8, 14, 13, 11, 4, 2, 1, 7, 0, 6, 5, 3, 27, 26, 25, 24, 31, 30, 29, 28, 19, 18, 17, 16, 23, 22, 21, 20],\n  [13, 11, 10, 9, 12, 8, 14, 15, 5, 3, 2, 1, 4, 0, 6, 7, 28, 27, 30, 25, 24, 31, 26, 29, 20, 19, 22, 17, 16, 23, 18, 21],\n  [14, 15, 11, 10, 13, 12, 8, 9, 6, 7, 3, 2, 5, 4, 0, 1, 29, 28, 31, 30, 25, 24, 27, 26, 21, 20, 23, 22, 17, 16, 19, 18],\n  [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16],\n  [16, 20, 23, 18, 19, 22, 21, 17, 1, 5, 7, 0, 4, 3, 6, 2, 31, 26, 27, 30, 29, 24, 25, 28, 14, 9, 10, 13, 15, 8, 12, 11],\n  [17, 21, 16, 19, 20, 23, 18, 22, 2, 6, 1, 4, 5, 7, 0, 3, 24, 27, 28, 31, 26, 25, 30, 29, 8, 10, 11, 14, 9, 12, 13, 15],\n  [18, 22, 21, 16, 17, 20, 23, 19, 0, 3, 6, 1, 2, 5, 7, 4, 29, 24, 25, 28, 31, 26, 27, 30, 15, 8, 12, 11, 14, 9, 10, 13],\n  [19, 23, 18, 17, 22, 21, 16, 20, 4, 7, 0, 2, 3, 6, 1, 5, 26, 25, 30, 29, 24, 27, 28, 31, 9, 12, 13, 15, 8, 10, 11, 14],\n  [20, 16, 19, 22, 23, 18, 17, 21, 5, 1, 4, 3, 7, 0, 2, 6, 27, 30, 31, 26, 25, 28, 29, 24, 10, 13, 14, 9, 12, 11, 15, 8],\n  [21, 17, 20, 23, 16, 19, 22, 18, 6, 2, 5, 7, 1, 4, 3, 0, 28, 31, 24, 27, 30, 29, 26, 25, 11, 14, 8, 10, 13, 15, 9, 12],\n  [22, 18, 17, 20, 21, 16, 19, 23, 3, 0, 2, 5, 6, 1, 4, 7, 25, 28, 29, 24, 27, 30, 31, 26, 12, 11, 15, 8, 10, 13, 14, 9],\n  [23, 19, 22, 21, 18, 17, 20, 16, 7, 4, 3, 6, 0, 2, 5, 1, 30, 29, 26, 25, 28, 31, 24, 27, 13, 15, 9, 12, 11, 14, 8, 10],\n  [16, 18, 19, 20, 17, 22, 23, 21, 27, 25, 30, 31, 28, 29, 26, 24, 4, 5, 2, 3, 7, 1, 6, 0, 9, 10, 8, 12, 13, 14, 11, 15],\n  [17, 19, 20, 21, 22, 23, 16, 18, 28, 30, 31, 24, 29, 26, 27, 25, 5, 6, 3, 7, 1, 2, 0, 4, 10, 11, 12, 13, 14, 8, 15, 9],\n  [18, 16, 17, 22, 19, 20, 21, 23, 25, 27, 28, 29, 30, 31, 24, 26, 2, 3, 4, 5, 6, 0, 7, 1, 8, 12, 9, 10, 11, 15, 13, 14],\n  [19, 17, 22, 23, 20, 21, 18, 16, 30, 28, 29, 26, 31, 24, 25, 27, 3, 7, 5, 6, 0, 4, 1, 2, 12, 13, 10, 11, 15, 9, 14, 8],\n  [20, 22, 23, 16, 21, 18, 19, 17, 31, 29, 26, 27, 24, 25, 30, 28, 7, 1, 6, 0, 4, 5, 2, 3, 13, 14, 11, 15, 9, 10, 8, 12],\n  [21, 23, 16, 17, 18, 19, 20, 22, 24, 26, 27, 28, 25, 30, 31, 29, 1, 2, 0, 4, 5, 6, 3, 7, 14, 8, 15, 9, 10, 11, 12, 13],\n  [22, 20, 21, 18, 23, 16, 17, 19, 29, 31, 24, 25, 26, 27, 28, 30, 6, 0, 7, 1, 2, 3, 4, 5, 11, 15, 13, 14, 8, 12, 9, 10],\n  [23, 21, 18, 19, 16, 17, 22, 20, 26, 24, 25, 30, 27, 28, 29, 31, 0, 4, 1, 2, 3, 7, 5, 6, 15, 9, 14, 8, 12, 13, 10, 11],\n  [8, 11, 12, 9, 15, 13, 10, 14, 25, 29, 30, 27, 26, 31, 28, 24, 3, 4, 0, 7, 5, 2, 1, 6, 17, 18, 21, 22, 19, 16, 23, 20],\n  [9, 13, 10, 8, 14, 11, 12, 15, 27, 31, 28, 25, 24, 29, 30, 26, 5, 2, 1, 6, 3, 4, 0, 7, 19, 16, 23, 20, 17, 18, 21, 22],\n  [10, 14, 11, 12, 8, 15, 13, 9, 28, 24, 29, 30, 25, 26, 31, 27, 6, 3, 2, 0, 7, 5, 4, 1, 20, 17, 16, 21, 22, 19, 18, 23],\n  [11, 8, 15, 13, 12, 9, 14, 10, 29, 25, 26, 31, 30, 27, 24, 28, 0, 7, 3, 4, 1, 6, 5, 2, 21, 22, 17, 18, 23, 20, 19, 16],\n  [12, 15, 13, 10, 9, 14, 11, 8, 30, 26, 31, 28, 27, 24, 29, 25, 7, 5, 4, 1, 6, 3, 2, 0, 22, 19, 18, 23, 20, 17, 16, 21],\n  [13, 9, 14, 11, 10, 8, 15, 12, 31, 27, 24, 29, 28, 25, 26, 30, 1, 6, 5, 2, 0, 7, 3, 4, 23, 20, 19, 16, 21, 22, 17, 18],\n  [14, 10, 8, 15, 11, 12, 9, 13, 24, 28, 25, 26, 29, 30, 27, 31, 2, 0, 6, 3, 4, 1, 7, 5, 16, 21, 20, 17, 18, 23, 22, 19],\n  [15, 12, 9, 14, 13, 10, 8, 11, 26, 30, 27, 24, 31, 28, 25, 29, 4, 1, 7, 5, 2, 0, 6, 3, 18, 23, 22, 19, 16, 21, 20, 17],\n  [16, 18, 21, 20, 23, 22, 17, 19, 24, 26, 29, 28, 31, 30, 25, 27, 0, 6, 1, 7, 3, 2, 5, 4, 8, 14, 9, 15, 11, 10, 13, 12],\n  [17, 19, 18, 21, 16, 23, 22, 20, 25, 27, 26, 29, 24, 31, 30, 28, 4, 0, 2, 1, 7, 3, 6, 5, 12, 8, 10, 9, 15, 11, 14, 13],\n  [18, 16, 23, 22, 21, 20, 19, 17, 26, 24, 31, 30, 29, 28, 27, 25, 1, 7, 0, 6, 5, 4, 3, 2, 9, 15, 8, 14, 13, 12, 11, 10],\n  [19, 17, 16, 23, 18, 21, 20, 22, 27, 25, 24, 31, 26, 29, 28, 30, 2, 1, 4, 0, 6, 5, 7, 3, 10, 9, 12, 8, 14, 13, 15, 11],\n  [20, 22, 17, 16, 19, 18, 21, 23, 28, 30, 25, 24, 27, 26, 29, 31, 3, 2, 5, 4, 0, 6, 1, 7, 11, 10, 13, 12, 8, 14, 9, 15],\n  [21, 23, 22, 17, 20, 19, 18, 16, 29, 31, 30, 25, 28, 27, 26, 24, 7, 3, 6, 5, 4, 0, 2, 1, 15, 11, 14, 13, 12, 8, 10, 9],\n  [22, 20, 19, 18, 17, 16, 23, 21, 30, 28, 27, 26, 25, 24, 31, 29, 5, 4, 3, 2, 1, 7, 0, 6, 13, 12, 11, 10, 9, 15, 8, 14],\n  [23, 21, 20, 19, 22, 17, 16, 18, 31, 29, 28, 27, 30, 25, 24, 26, 6, 5, 7, 3, 2, 1, 4, 0, 14, 13, 15, 11, 10, 9, 12, 8],\n  [8, 11, 14, 9, 10, 13, 15, 12, 24, 28, 31, 26, 27, 30, 29, 25, 6, 1, 2, 5, 7, 0, 4, 3, 21, 16, 17, 20, 23, 18, 19, 22],\n  [9, 13, 15, 8, 12, 11, 14, 10, 26, 30, 29, 24, 25, 28, 31, 27, 7, 0, 4, 3, 6, 1, 2, 5, 23, 18, 19, 22, 21, 16, 17, 20],\n  [10, 14, 9, 12, 13, 15, 8, 11, 27, 31, 26, 25, 30, 29, 24, 28, 1, 4, 5, 7, 0, 2, 3, 6, 16, 19, 20, 23, 18, 17, 22, 21],\n  [11, 8, 10, 13, 14, 9, 12, 15, 28, 24, 27, 30, 31, 26, 25, 29, 2, 5, 6, 1, 4, 3, 7, 0, 17, 20, 21, 16, 19, 22, 23, 18],\n  [12, 15, 8, 10, 11, 14, 9, 13, 25, 29, 24, 27, 28, 31, 26, 30, 0, 2, 3, 6, 1, 4, 5, 7, 18, 17, 22, 21, 16, 19, 20, 23],\n  [13, 9, 12, 11, 15, 8, 10, 14, 30, 26, 25, 28, 29, 24, 27, 31, 4, 3, 7, 0, 2, 5, 6, 1, 19, 22, 23, 18, 17, 20, 21, 16],\n  [14, 10, 13, 15, 9, 12, 11, 8, 31, 27, 30, 29, 26, 25, 28, 24, 5, 7, 1, 4, 3, 6, 0, 2, 20, 23, 16, 19, 22, 21, 18, 17],\n  [15, 12, 11, 14, 8, 10, 13, 9, 29, 25, 28, 31, 24, 27, 30, 26, 3, 6, 0, 2, 5, 7, 1, 4, 22, 21, 18, 17, 20, 23, 16, 19],\n  [24, 26, 27, 28, 25, 30, 31, 29, 16, 18, 19, 20, 17, 22, 23, 21, 9, 10, 8, 12, 13, 14, 11, 15, 1, 2, 0, 4, 5, 6, 3, 7],\n  [25, 27, 28, 29, 30, 31, 24, 26, 17, 19, 20, 21, 22, 23, 16, 18, 10, 11, 12, 13, 14, 8, 15, 9, 2, 3, 4, 5, 6, 0, 7, 1],\n  [26, 24, 25, 30, 27, 28, 29, 31, 18, 16, 17, 22, 19, 20, 21, 23, 8, 12, 9, 10, 11, 15, 13, 14, 0, 4, 1, 2, 3, 7, 5, 6],\n  [27, 25, 30, 31, 28, 29, 26, 24, 19, 17, 22, 23, 20, 21, 18, 16, 12, 13, 10, 11, 15, 9, 14, 8, 4, 5, 2, 3, 7, 1, 6, 0],\n  [28, 30, 31, 24, 29, 26, 27, 25, 20, 22, 23, 16, 21, 18, 19, 17, 13, 14, 11, 15, 9, 10, 8, 12, 5, 6, 3, 7, 1, 2, 0, 4],\n  [29, 31, 24, 25, 26, 27, 28, 30, 21, 23, 16, 17, 18, 19, 20, 22, 14, 8, 15, 9, 10, 11, 12, 13, 6, 0, 7, 1, 2, 3, 4, 5],\n  [30, 28, 29, 26, 31, 24, 25, 27, 22, 20, 21, 18, 23, 16, 17, 19, 11, 15, 13, 14, 8, 12, 9, 10, 3, 7, 5, 6, 0, 4, 1, 2],\n  [31, 29, 26, 27, 24, 25, 30, 28, 23, 21, 18, 19, 16, 17, 22, 20, 15, 9, 14, 8, 12, 13, 10, 11, 7, 1, 6, 0, 4, 5, 2, 3],\n  [24, 28, 25, 26, 29, 30, 27, 31, 8, 11, 12, 9, 15, 13, 10, 14, 17, 18, 21, 22, 19, 16, 23, 20, 2, 0, 6, 3, 4, 1, 7, 5],\n  [25, 29, 30, 27, 26, 31, 28, 24, 12, 15, 13, 10, 9, 14, 11, 8, 22, 19, 18, 23, 20, 17, 16, 21, 3, 4, 0, 7, 5, 2, 1, 6],\n  [26, 30, 27, 24, 31, 28, 25, 29, 9, 13, 10, 8, 14, 11, 12, 15, 19, 16, 23, 20, 17, 18, 21, 22, 4, 1, 7, 5, 2, 0, 6, 3],\n  [27, 31, 28, 25, 24, 29, 30, 26, 10, 14, 11, 12, 8, 15, 13, 9, 20, 17, 16, 21, 22, 19, 18, 23, 5, 2, 1, 6, 3, 4, 0, 7],\n  [28, 24, 29, 30, 25, 26, 31, 27, 11, 8, 15, 13, 12, 9, 14, 10, 21, 22, 17, 18, 23, 20, 19, 16, 6, 3, 2, 0, 7, 5, 4, 1],\n  [29, 25, 26, 31, 30, 27, 24, 28, 15, 12, 9, 14, 13, 10, 8, 11, 18, 23, 22, 19, 16, 21, 20, 17, 0, 7, 3, 4, 1, 6, 5, 2],\n  [30, 26, 31, 28, 27, 24, 29, 25, 13, 9, 14, 11, 10, 8, 15, 12, 23, 20, 19, 16, 21, 22, 17, 18, 7, 5, 4, 1, 6, 3, 2, 0],\n  [31, 27, 24, 29, 28, 25, 26, 30, 14, 10, 8, 15, 11, 12, 9, 13, 16, 21, 20, 17, 18, 23, 22, 19, 1, 6, 5, 2, 0, 7, 3, 4],\n  [24, 26, 29, 28, 31, 30, 25, 27, 21, 23, 22, 17, 20, 19, 18, 16, 15, 11, 14, 13, 12, 8, 10, 9, 0, 6, 1, 7, 3, 2, 5, 4],\n  [25, 27, 26, 29, 24, 31, 30, 28, 18, 16, 23, 22, 21, 20, 19, 17, 9, 15, 8, 14, 13, 12, 11, 10, 4, 0, 2, 1, 7, 3, 6, 5],\n  [26, 24, 31, 30, 29, 28, 27, 25, 23, 21, 20, 19, 22, 17, 16, 18, 14, 13, 15, 11, 10, 9, 12, 8, 1, 7, 0, 6, 5, 4, 3, 2],\n  [27, 25, 24, 31, 26, 29, 28, 30, 16, 18, 21, 20, 23, 22, 17, 19, 8, 14, 9, 15, 11, 10, 13, 12, 2, 1, 4, 0, 6, 5, 7, 3],\n  [28, 30, 25, 24, 27, 26, 29, 31, 17, 19, 18, 21, 16, 23, 22, 20, 12, 8, 10, 9, 15, 11, 14, 13, 3, 2, 5, 4, 0, 6, 1, 7],\n  [29, 31, 30, 25, 28, 27, 26, 24, 22, 20, 19, 18, 17, 16, 23, 21, 13, 12, 11, 10, 9, 15, 8, 14, 7, 3, 6, 5, 4, 0, 2, 1],\n  [30, 28, 27, 26, 25, 24, 31, 29, 19, 17, 16, 23, 18, 21, 20, 22, 10, 9, 12, 8, 14, 13, 15, 11, 5, 4, 3, 2, 1, 7, 0, 6],\n  [31, 29, 28, 27, 30, 25, 24, 26, 20, 22, 17, 16, 19, 18, 21, 23, 11, 10, 13, 12, 8, 14, 9, 15, 6, 5, 7, 3, 2, 1, 4, 0],\n  [24, 28, 31, 26, 27, 30, 29, 25, 14, 10, 13, 15, 9, 12, 11, 8, 20, 23, 16, 19, 22, 21, 18, 17, 6, 1, 2, 5, 7, 0, 4, 3],\n  [25, 29, 24, 27, 28, 31, 26, 30, 8, 11, 14, 9, 10, 13, 15, 12, 21, 16, 17, 20, 23, 18, 19, 22, 0, 2, 3, 6, 1, 4, 5, 7],\n  [26, 30, 29, 24, 25, 28, 31, 27, 15, 12, 11, 14, 8, 10, 13, 9, 22, 21, 18, 17, 20, 23, 16, 19, 7, 0, 4, 3, 6, 1, 2, 5],\n  [27, 31, 26, 25, 30, 29, 24, 28, 9, 13, 15, 8, 12, 11, 14, 10, 23, 18, 19, 22, 21, 16, 17, 20, 1, 4, 5, 7, 0, 2, 3, 6],\n  [28, 24, 27, 30, 31, 26, 25, 29, 10, 14, 9, 12, 13, 15, 8, 11, 16, 19, 20, 23, 18, 17, 22, 21, 2, 5, 6, 1, 4, 3, 7, 0],\n  [29, 25, 28, 31, 24, 27, 30, 26, 11, 8, 10, 13, 14, 9, 12, 15, 17, 20, 21, 16, 19, 22, 23, 18, 3, 6, 0, 2, 5, 7, 1, 4],\n  [30, 26, 25, 28, 29, 24, 27, 31, 12, 15, 8, 10, 11, 14, 9, 13, 18, 17, 22, 21, 16, 19, 20, 23, 4, 3, 7, 0, 2, 5, 6, 1],\n  [31, 27, 30, 29, 26, 25, 28, 24, 13, 9, 12, 11, 15, 8, 10, 14, 19, 22, 23, 18, 17, 20, 21, 16, 5, 7, 1, 4, 3, 6, 0, 2]\n]\n\n# Irreducible representations\n[Gamma.C4.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C4.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C4.Ea]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Gamma.C4.Eb]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [0.0000000000000000, 0.0000000000000000]\n\n[Delta.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [1.5707963267948966, 0.0000000000000000]\n\n[M.C4.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[M.C4.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[M.C4.Ea]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[M.C4.Eb]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000004, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [0.0000000000000009, 1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000001, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000006, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [-0.0000000000000009, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000000, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-0.0000000000000005, -1.0000000000000000],\n  [-0.0000000000000007, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000000, 1.0000000000000000],\n  [0.0000000000000002, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000],\n  [0.0000000000000005, 1.0000000000000000],\n  [0.0000000000000007, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127]\nmomentum = [3.1415926535897931, 3.1415926535897931]\n\n[None0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [0.0000000000000003, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865467, 0.7071067811865483],\n  [-0.7071067811865485, -0.7071067811865466],\n  [0.7071067811865466, -0.7071067811865485],\n  [0.7071067811865486, 0.7071067811865466],\n  [-0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865467, 0.7071067811865483],\n  [-0.7071067811865471, -0.7071067811865479],\n  [0.7071067811865466, -0.7071067811865485],\n  [0.7071067811865472, 0.7071067811865478],\n  [-0.7071067811865465, 0.7071067811865486],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [0.0000000000000003, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-0.0000000000000022, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000005]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [2.3561944901923448, 0.7853981633974483]\n\n[None1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865467, 0.7071067811865483],\n  [0.7071067811865477, 0.7071067811865474],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865486, 0.7071067811865466],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865485, -0.7071067811865466],\n  [-0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865471, -0.7071067811865479],\n  [-0.7071067811865467, 0.7071067811865483],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865465, 0.7071067811865486],\n  [0.7071067811865472, 0.7071067811865478],\n  [-1.0000000000000000, 0.0000000000000001],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000003, 1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, -0.0000000000000005],\n  [-0.0000000000000022, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [2.3561944901923448, -0.7853981633974483]\n\n[Sigma0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865477, 0.7071067811865474],\n  [0.7071067811865466, -0.7071067811865485],\n  [0.7071067811865483, 0.7071067811865467],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865477, 0.7071067811865474],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865477, 0.7071067811865474],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865466, -0.7071067811865485],\n  [-0.7071067811865474, -0.7071067811865477],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000006, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000023, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [2.3561944901923448, 2.3561944901923448]\n\n[Sigma1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [1.5707963267948966, 1.5707963267948966]\n\n[Sigma2.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.7071067811865476, 0.7071067811865475],\n  [0.7071067811865476, 0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865477, -0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865474, -0.7071067811865477],\n  [0.7071067811865476, 0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [0.7071067811865476, 0.7071067811865475],\n  [-0.7071067811865475, 0.7071067811865476],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [-0.7071067811865477, -0.7071067811865475],\n  [0.7071067811865474, -0.7071067811865477],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [1.0000000000000000, 0.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-0.0000000000000002, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [0.7853981633974483, 0.7853981633974483]\n\n[X.C2.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119]\nmomentum = [3.1415926535897931, 0.0000000000000000]\n\n[X.C2.B]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000009],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000007],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000006],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000006]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23, 32, 33, 34, 35, 36, 37, 38, 39, 48, 49, 50, 51, 52, 53, 54, 55, 64, 65, 66, 67, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 96, 97, 98, 99, 100, 101, 102, 103, 112, 113, 114, 115, 116, 117, 118, 119]\nmomentum = [3.1415926535897931, 0.0000000000000000]\n\n[Z0.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000005],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000009],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [-0.0000000000000010, 1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [3.1415926535897931, 1.5707963267948966]\n\n[Z1.C1.A]\ncharacters = [\n  [1.0000000000000000, 0.0000000000000000],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [-1.0000000000000000, 0.0000000000000001],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000001],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000004],\n  [1.0000000000000000, -0.0000000000000002],\n  [1.0000000000000000, -0.0000000000000007],\n  [-1.0000000000000000, 0.0000000000000006],\n  [1.0000000000000000, -0.0000000000000005],\n  [-1.0000000000000000, 0.0000000000000009],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000010, 1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [0.0000000000000001, 1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000],\n  [-0.0000000000000004, -1.0000000000000000],\n  [0.0000000000000003, 1.0000000000000000],\n  [-0.0000000000000002, -1.0000000000000000],\n  [-0.0000000000000024, -1.0000000000000000],\n  [0.0000000000000006, 1.0000000000000000]\n]\nallowed_symmetries = [0, 1, 2, 3, 4, 5, 6, 7, 32, 33, 34, 35, 36, 37, 38, 39, 64, 65, 66, 67, 68, 69, 70, 71, 96, 97, 98, 99, 100, 101, 102, 103]\nmomentum = [3.1415926535897931, -1.5707963267948966]\n</code></pre> <p>To run the above C++ code with the toml file, one needs to execute the following command </p> <p><pre><code>./build/main n_sites n_up kname J1 seed\n</code></pre> where the n_sites, n_up, kname, J1, and seed are to be replaced by their values such as 32, 16, Gamma.C4.A, 1.00, 1, respectively. The Julia code below was used to generate the plot above from the data obtaining running the above code.</p> <p>Plotting Script</p> Julia <pre><code>using LinearAlgebra\nusing Plots\nusing Combinatorics\n# using BenchmarkTools\nusing Kronecker\nusing LaTeXStrings\nusing Arpack\n# using KernelDensity\nusing Interpolations\nusing SparseArrays\n# using ArnoldiMethod\nusing KrylovKit\nusing JLD2\nusing HDF5\nusing Printf\nplot_font = \"Computer Modern\"\ndefault(\n    fontfamily=plot_font,\n    linewidth=2, \n    framestyle=:box, \n    # xtickfont=font(18),\n    label=nothing,\n    left_margin=4Plots.mm,\n    bottom_margin=2Plots.mm\n    # ytickfont=font(18),\n    # legendfont=font(18)\n)\n\n\n\nn_sites=32\nn_seeds = 1\nks=[\"Gamma.C4.A\", \"Gamma.C4.B\", \"Gamma.C4.Ea\", \"Gamma.C4.Eb\", \"M.C4.A\", \"M.C4.B\", \"M.C4.Ea\", \"M.C4.Eb\", \"X.C2.A\", \"X.C2.B\"]#, \"Delta.C1.A\", \"Sigma.C1.A\", \"Z0.C1.A\", \"Z1.C1.A\"]\nseeds = [i for i=1:n_seeds]\nnup_start=10\nn_ups = [i for i=nup_start:(div(n_sites,2))]\n\nJ1=1.00\nn_eigs = 10\n\n\nfor seed in seeds\n    plot()\n    mineig = 0\n    eigvs = []\n    for n_up=n_ups\n        for k in ks\n            f = h5open(@sprintf(\"outfile.square.%d.J1.%.2f.nup.%d.k.%s.seed.%d.h5\",n_sites,J1,n_up,k,seed), \"r\")\n            eig = read(f[\"Eigenvalues\"])[1:n_eigs]\n            eigvs = append!(eigvs,eig)\n            close(f)\n        end\n    end\n    mineig=minimum(eigvs)\n    eigvs = eigvs-mineig*ones(length(eigvs))\n    energies2 = round.(eigvs, digits=6)\n    E0 = unique(energies2)\n    sort!(E0)\n    Stot = similar(E0)\n    for i=1:length(E0)\n        mask = findall(x -&gt; x == E0[i], energies2)\n        Sz = abs.(div.(mask,length(ks)*n_eigs).+(nup_start) .- n_sites / 2)\n        vals = Sz .* (Sz .+ 1)\n        max_val, arg = findmax(vals)\n        Stot[i] =abs(max_val)\n    end\n    plot(Stot,E0,seriestype=:scatter,mc = :blue,legend=false,xlabel=L\"S_\\mathrm{tot}(S_{tot}+1)\",ylabel=L\"E/J_1\")\n    plot!(Stot,0.15*Stot,color = :black,legend=false,ylims=(0,10))\n    savefig(@sprintf(\"outfile.square.%d.J1.%.2f.seed.%d-n.pdf\",n_sites,J1,seed))\nend\n</code></pre>"},{"location":"examples/tos_square_Heisenberg/#references","title":"references","text":"<p>[1] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p>"},{"location":"examples/tos_triangular/","title":"Tower of State \\(J_1 - J_2\\) Model in the Triangular Lattice","text":"<p>Author Rafael Soares</p> <p>We perform a tower of states (TOS) analysis [1] of the \\(J_1-J_2\\) spin-\\(\\frac{1}{2}\\) Heisenberg model on the triangular lattice [2]. This model consists of spin-\\(\\frac{1}{2}\\) sites with nearest and next-nearest neighbor Heisenberg interactions,</p> \\[ \\mathcal{H} = J_1 \\sum_{\\langle i, j \\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j + J_2 \\sum_{\\langle\\langle i, j \\rangle\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>The TOS analysis provides strong evidence for spontaneous symmetry breaking (SSB) in the thermodynamic limit, since the ground state of a finite system is completely symmetric. The \\(J_1-J_2\\) Heisenberg model on the triangular lattice can stabilize different types of order depending on the ratio \\(J_2/J_1\\), which break the continuous SU(2) spin rotation symmetry.</p> <p>To perform the TOS analysis, we converged the lowest-lying eigenvalues using the Lanczos algorithm in each symmetry sector. We then determined the total spin quantum number, \\(S_{\\text{tot}}\\), by inspecting, for each energy level, the number of degenerate eigenstates; thus, \\(S_{\\text{tot}}\\) is given by the maximum \\(S^z\\). Finally, we plotted the energy spectra as a function of \\(S_{\\text{tot}}\\left(S_{\\text{tot}} + 1\\right)\\). </p> <p></p> <p>In the figure above, we show the energy spectra as a function of \\(S_{\\text{tot}}\\left(S_{\\text{tot}} + 1\\right)\\) for \\(J_2=0\\). In this case, the ground state exhibits a \\(120^\\circ\\) N\u00e9el order. As described in [2], group representation theory can be used to predict the quantum numbers in the spontaneous symmetry breaking phases. In this cases, the multiplicities of irreducible representations in the Anderson tower of states can be obtained. This can then be confirmed by the exact diagonalization results the plotting script given above also plots the multiplicites for some sectors. We stress that the results presented are for \\(N_{\\text{spins}} = 18\\) and, therefore, not all momenta in the first Brillouin zone can be resolved.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n\n  std::vector&lt;double&gt; energies;\n  std::vector&lt;std::string&gt; IrrepList;\n  std::vector&lt;int&gt; Szsector;\n  int Nsites = 18;\n  int numbeig = 6; // number of Eigenvalues to converge.\n\n  std::vector&lt;std::string&gt; Irreps = {\n      \"Gamma.C2.A\", \"Gamma.C2.B\", \"K0.C1.A\", \"K1.C1.A\", \"M.C2.A\",\n      \"M.C2.B\",     \"X0.C1.A\",    \"X1.C1.A\", \"X2.C1.A\", \"Z0.C1.A\",\n      \"Z1.C1.A\",    \"0.C1.A\",     \"1.C1.A\",  \"2.C1.A\"};\n\n  auto fl = FileToml(\"triangular.18.10418.J1J2.sublattices.tsl.toml\");\n\n  OpSum ops = read_opsum(fl, \"Interactions\");\n\n  // For this ratio, we are in the 120 phase\n  ops[\"J1\"] = 1.0;\n  ops[\"J2\"] = 0.0;\n\n  for (auto irrep : Irreps) {\n\n    auto irrep2 = read_representation(fl, irrep, \"Symmetries\");\n\n    for (int nup = 0; nup &lt;= Nsites; nup++) {\n      auto block = Spinhalf(Nsites, nup, irrep2);\n\n      auto res = eigvals_lanczos(ops, block, numbeig);\n      arma::vec eig0 = res.eigenvalues;\n\n      for (int i = 0; i &lt; eig0.n_elem; i++) {\n        energies.push_back(eig0[i]);\n        IrrepList.push_back(irrep);\n        Szsector.push_back(nup);\n      }\n    }\n  }\n\n  // Construct the filename\n  std::string flstring = \"energies_tower_of_states.triangular.Nsites.\" +\n                         std::to_string(Nsites) + \".outfile.txt\";\n  std::ofstream outfile(flstring);\n  for (int i = 0; i &lt; energies.size(); i++) {\n    outfile &lt;&lt; energies[i] &lt;&lt; \",\" &lt;&lt; Szsector[i] &lt;&lt; \",\" &lt;&lt; IrrepList[i] &lt;&lt; \"\\n\";\n  }\n  outfile.close();\n  return 0;\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <pre><code>using XDiag\nusing Printf\nusing HDF5\n\nfunction SpectrumSz()\n    energies = Vector{Float64}[] ## Collect the energies\n    IrrepList = Vector{String}[] ## Collect the energies\n    Nsites = 18\n    numbeig = 6 # number of lanczos vectors to converge\n\n    Irrep = []\n\n    fl = FileToml(\"triangular.18.10418.J1J2.sublattices.tsl.toml\") #TOML file with Shastry-Sutherland Interactions \n    ops = read_opsum(fl, \"Interactions\")\n    # Define couplings\n    ops[\"J1\"] = 1.0\n    ops[\"J2\"] = 0.0 #  For this ratio of couplings we are in the 120 phase.\n\n    Irreps =  [\"Gamma.C2.A\", \"Gamma.C2.B\", \"K0.C1.A\", \"K1.C1.A\", \"M.C2.A\", \"M.C2.B\", \"X0.C1.A\",\"X1.C1.A\",\"X2.C1.A\", \"Z0.C1.A\",\"Z1.C1.A\",\"0.C1.A\",\"1.C1.A\",\"2.C1.A\"]\n\n    # Loop different Irreps\n    for j in Irreps\n        irrep = read_representation(fl, j)\n        # Loop different total magnetization sector:\n        for nup in 0:Nsites\n            block = Spinhalf(Nsites, nup, irrep)\n            r = eigvals_lanczos(ops, block, neigvals=numbeig)\n            eig = r.eigenvalues\n            for i in 1:length(eig)\n                push!(energies, [nup, eig[i]])\n                push!(IrrepList,[j])\n            end\n        end\n    end\n\n    filename = @sprintf(\"energies_tower_of_states.triangular.Nsites.%d.outfile.h5\", Nsites)\n    h5open(filename, \"w\") do file\n        write(file, \"energies\", hcat(energies...))\n        write(file, \"irrep\", hcat(IrrepList...))\n    end\nend\n\nSpectrumSz()\n</code></pre> <p>Plotting Script</p> Julia <pre><code>using HDF5, CairoMakie\n\n# === Load Data ===\n# Open the HDF5 file and read datasets \"energies\" and \"irrep\"\ndata18 = h5open(\"energies_tower_of_states.triangular.Nsites.18.outfile.h5\", \"r\")\nAllEnergies = read(data18[\"energies\"])\nAllirreps = read(data18[\"irrep\"])[1,:]\nclose(data18)\n\n# === Function Definitions ===\n\n# Computes total spin values given energies and irreps.\nfunction get_STotal(energies, irreps, Nspins)\n    # In Julia the columns are 1-indexed; here column 2 corresponds to Python\u2019s energies[:,1]\n    energies2 = round.(energies[2, :], digits=8)\n    E0 = unique(energies2)\n    sort!(E0)\n    Stot = similar(E0)\n    Irreps_arr = Vector{Any}(undef, length(E0))\n\n    for (i, e0) in enumerate(E0)\n        mask = findall(x -&gt; x == e0, energies2)\n        # Column 1 of energies corresponds to Python\u2019s energies[:,0]\n        Sz = energies[1, mask] .- Nspins / 2\n        vals = Sz .* (Sz .+ 1)\n        max_val, arg = findmax(vals)\n        Stot[i] =abs(max_val)\n        # Get the corresponding irreps element.\n        Irreps_arr[i] = irreps[mask][arg]\n    end\n    return Stot, E0, Irreps_arr\nend\n\n# Extracts lower energy levels for a specified irreducible representation.\nfunction get_lower(Stotal, sortedEnergies, allenergies, IrrepList, IrreListAll, irr)\n    target = irr[1]\n    maskAll = findall(x -&gt; x == target, IrreListAll)\n\n    mask = findall(x -&gt; x == target, IrrepList)\n\n    energies2 = round.(allenergies[2, maskAll], digits=8)\n\n\n    St = round.(Stotal, digits=0)\n    # Consider only the entries corresponding to the target irreducible rep.\n    St_mask = St[mask]\n\n    St2 = sort(unique(St_mask))\n\n    E2 = sortedEnergies[mask]\n\n    Ef = zeros(length(St2), 2)\n\n    for (i, s) in enumerate(St2)\n        mask2 = findall(x -&gt; x == s, St_mask)\n\n        E_subset = E2[mask2]\n\n        Ef[i, 1] = minimum(E_subset)\n\n        multiplicity = findall(x -&gt; x == Ef[i, 1], energies2)\n\n        Ef[i, 2] = length(multiplicity)\n    end\n    return St2, Ef\nend\n\n\n\nfunction make_Plot()\n    # --- Compute Quantities ---\n    Nspins = 18\n    Stot, SEtot, SortedIr = get_STotal(AllEnergies, Allirreps,Nspins)\n\n    SGamma, EGamma = get_lower(Stot, SEtot, AllEnergies, SortedIr, Allirreps, [\"Gamma.C2.A\"])\n    SGammaB, EGammaB = get_lower(Stot, SEtot, AllEnergies, SortedIr, Allirreps, [\"Gamma.C2.B\"])\n    SGammaK, EGammaK = get_lower(Stot, SEtot, AllEnergies, SortedIr, Allirreps, [\"K0.C1.A\"])\n\n    # === Plotting ===\n    fig = Figure(ratio=1.618)\n    ax = Axis(fig[1, 1],\n        xlabel=L\"S_{\\text{total}}(S_{\\text{ total}}+1)\",\n        ylabel=L\"$(E - E_{\\text{GS} })/J_1$\" )\n\n    xlims!(ax, -0.5, 12.5),\n    ylims!(ax, -0.4, 5)\n    # Plot the reference line: Stot vs. 0.265*Stot\n    lines!(ax, Stot, 0.265 .* Stot, color=:black)\n\n    Egs = minimum(SEtot)\n    # Plot all energies shifted by the ground state energy.\n    scatter!(ax, Stot, SEtot .- Egs, color=:black, markersize=4)\n\n    maskA = [2, 4]  \n\n    print(SGamma)\n\n    scatter!(ax, SGamma[maskA], EGamma[maskA, 1] .- Egs,\n        marker=:utriangle, markersize=10,\n        label=L\"$\\Gamma.\\mathrm{C2.A}$\")\n    @info \"Multiplicity for Gamma.C2.A: $(EGamma[maskA, 2])\"\n\n    maskB = [1, 3, 4]  \n    scatter!(ax, SGammaB[maskB], EGammaB[maskB, 1] .- Egs,\n        marker=:utriangle, markersize=10,\n        label=L\"$\\Gamma.\\mathrm{C2.B}$\")\n    @info \"Multiplicity for Gamma.C2.B: $(EGammaB[maskB, 2])\"\n\n    maskC = [2, 3, 4]  \n    scatter!(ax, SGammaK[maskC], EGammaK[maskC, 1] .- Egs,\n        marker=:star5, markersize=10,\n        label=L\"$K_0.\\mathrm{C1.A}$\")\n\n    @info \"Multiplicity for K0.C1.A: $(EGammaK[maskC, 2])\"\n\n    text!(ax, L\"J_2=0\", position=(10, 4.5), align=(:left, :center))\n\n\n    axislegend(ax; framevisible=true, position=:rb, labelsize=15)\n    display(fig)\n\n    return nothing\nend\n\n\nmake_Plot()\n</code></pre>"},{"location":"examples/tos_triangular/#references","title":"references","text":"<p>[1] P. W. Anderson, An Approximate Quantum Theory of the Antiferromagnetic Ground State, Phys. Rev. 86, 694 (1952)</p> <p>[3] Alexander Wietek, Michael Schuler and Andreas M. L\u00e4uchli, Studying Continuous Symmetry Breaking using Energy Level Spectroscopy, arXiv:1704.08622 (2017).</p>"},{"location":"examples/tpq_shastry_sutherland/","title":"Shastry Sutherland Specific Heat with TPQ","text":"<p>Author Rafael Soares</p> <p>We use an ensemble of Thermal Pure Quantum (TPQ) states [1] to compute the total energy and specific heat as functions of temperature for the Shastry\u2013Sutherland model.</p> <p>The Shastry\u2013Sutherland model is a paradigmatic example of a frustrated two-dimensional antiferromagnetic spin system. It is widely used as a faithful representation of materials such as the frustrated quantum magnet \\(\\text{SrCu}_2(\\text{BO}_3)_2\\). On a square lattice, the model describes spin \\(-\\frac{1}{2}\\) magnetic moments interacting via Heisenberg antiferromagnetic couplings, as shown in following figure. </p> <p></p> <p>The Hamiltonian is given by</p> \\[ \\mathcal{H} = J \\sum_{\\langle i,j \\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j + J_D \\sum_{\\langle\\langle i,j \\rangle\\rangle} \\boldsymbol{S}_i \\cdot \\boldsymbol{S}_j. \\] <p>The expectation value of an observable \\(\\mathcal{O}\\) in the canonical ensemble is</p> \\[ \\langle \\mathcal{O} \\rangle = \\frac{\\text{Tr}\\left(e^{-\\beta \\mathcal{H}} \\mathcal{O}\\right)}{\\mathcal{Z}}, \\] <p>where \\(\\beta\\) is the inverse temperature and \\(\\mathcal{Z} = \\text{Tr}\\left(e^{-\\beta \\mathcal{H}}\\right)\\). We approximate the trace stochastically using a set of random vectors \\(\\{r_\\alpha\\}\\), leading to</p> <p>$$ \\langle \\mathcal{O} \\rangle \\approx \\sum_{\\alpha} \\frac{\\langle \\beta_\\alpha | \\mathcal{O} | \\beta_\\alpha \\rangle}{\\langle \\beta_\\alpha | \\beta_\\alpha \\rangle}, \\quad \\text{with } |\\beta_\\alpha\\rangle = e^{-\\beta \\mathcal{H}}|r_\\alpha\\rangle, $$ where $ |\\beta_\\alpha\\rangle$ is a TPQ state.</p> <p>We efficiently compute the TPQ state using the Lanczos basis [2], \\(V\\), constructed from \\(|r_\\alpha\\rangle\\). In this basis, the observable is approximated as</p> \\[ \\langle \\beta_\\alpha | \\mathcal{O} | \\beta_\\alpha \\rangle \\approx e_1^T\\, V\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, \\mathcal{O}\\, V\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, e_1, \\] <p>where \\(e_1^T = (1, 0, \\dots, 0)\\) and \\(T = V^\\dagger \\mathcal{H} V\\) is a tridiagonal matrix.</p> <p>Thus, for each random state, the algorithm performs the following steps:</p> <ol> <li> <p>Generate the Lanczos Basis: Obtain the elements of the tridiagonal matrix \\(T\\) from the state \\(|r_\\alpha\\rangle\\).</p> </li> <li> <p>Compute Observables: To obtain the specific heat,  $$    C = \\beta^2\\left[\\langle \\mathcal{H}^2 \\rangle - \\langle \\mathcal{H} \\rangle^2\\right], $$ we need to evaluate</p> </li> </ol> \\[    \\langle \\beta_\\alpha | \\mathcal{H} | \\beta_\\alpha \\rangle \\approx e_1^T\\, V\\, e^{-\\beta/2\\, T}\\, T\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, e_1, \\\\[2exm]     \\langle \\beta_\\alpha | \\mathcal{H}^2 | \\beta_\\alpha \\rangle \\approx e_1^T\\, V\\, e^{-\\beta/2\\, T}\\, T^2\\, e^{-\\beta/2\\, T}\\, V^\\dagger\\, e_1. \\] <p>This part could be done in the post-processing. The result is shown in the following figure,  The error bar was done using a Jackknife analysis.</p> C++Julia <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nconst int Nsites = 20; // Total number of sites in the Shastry-Sutherland model:\nconst int Rtqp = 5;    // Number of random vectors to be used in the algorithm\n\nusing namespace xdiag;\n\nauto fl = FileToml(\"shastry_sutherland_L_5_W_4.toml\"); // TOML file with the\n                                                       // list of interactions\n\nvoid Tqp_mag_sector(arma::mat &amp;Obser, arma::vec &amp;DBetas, OpSum &amp;H);\n\nint main() try {\n  // Read OpSum from file\n  OpSum ops = read_opsum(fl, \"Interactions\");\n\n  // Defines exchange coupling strenght -- This ratio of couplings corresponds\n  // to the dimmer phase.\n  ops[\"Jd\"] = 1.0;\n  ops[\"J\"] = 0.630;\n\n  // Linear Array with target temperatures\n  arma::vec Temp = arma::linspace&lt;arma::vec&gt;(0.01, 0.35, 64);\n\n  // Array to store the specific heat\n  arma::mat Obser = arma::mat(Temp.n_elem, 3, arma::fill::zeros);\n\n  Tqp_mag_sector(Obser, Temp, ops);\n\n  auto save_fl = FileH5(\"shastry_sutherland_L_5_W_4.h5\", \"w!\");\n  save_fl[\"Temp\"] = Temp;\n  save_fl[\"Observable\"] = Obser;\n\n  return 0;\n} catch (Error e) {\n  error_trace(e);\n}\n\nvoid Tqp_mag_sector(arma::mat &amp;Obser, arma::vec &amp;Temp, OpSum &amp;H) {\n  auto block =\n      Spinhalf(Nsites); // Create spin-1/2 block with conservation of Sz\n\n  arma::vec eigs;\n  arma::mat vecs;\n  for (int k = 0; k &lt; Rtqp;\n       k++) // #Perform the calculation for each random vector\n  {\n    auto res = eigvals_lanczos(\n        H, block, 1, 1e-12, 150, 1e-7,\n        k); // Perform the Lanczos interation starting from a random vector;\n\n    // This part can be done in the post-processing\n    arma::mat tmatrix = arma::diagmat(res.alphas);\n    tmatrix += arma::diagmat(res.betas.head(res.betas.size() - 1), 1) +\n               arma::diagmat(res.betas.head(res.betas.size() - 1), -1);\n\n    arma::eig_sym(eigs, vecs, tmatrix); // get eigenvector of T\n\n    for (int k = 0; k &lt; Temp.n_elem; k++) {\n      arma::vec psi1 = (arma::exp(-(eigs - eigs(0)) / (2.0 * Temp(k))) %\n                        arma::conj((vecs.row(0).t()))); // compute psi_1\n\n      Obser(k, 0) +=\n          arma::dot(psi1, psi1); // get norm factor for the partition function\n\n      Obser(k, 1) += arma::dot(psi1, eigs % psi1); // measure energy\n\n      Obser(k, 2) +=\n          arma::dot(psi1, eigs % eigs % psi1); // measure energy square\n    }\n  }\n}\n</code></pre> <pre><code>using LinearAlgebra, LinearAlgebra.LAPACK\nusing XDiag\nusing HDF5\nusing Printf\nconst Nsites = 20 # Total number of sites in the Shastry-Sutherland model:\nconst Rtqp = 2 # Number of random vectors to be used in the algorithm\n\nfunction Tqp_mag_sector(Obser::Matrix{Float64}, Temp::LinRange{Float64,Int64}, H::OpSum)\n\n    block = Spinhalf(Nsites) #Create spin-1/2 block with conservation of Sz\n\n    for k in 1:Rtqp #Perform the calculation for each random vector\n        res = eigvals_lanczos(H, block, neigvals=1, precision=1e-12, max_iterations=150, deflation_tol=1e-7, random_seed=k) # Perform the Lanczos interation starting from a random vector;\n\n        d = length(res.alphas)\n        vecs = Matrix{Float64}(I, d, d)\n        #This part can be done in the post-processing\n        (eigs, vecs) = LAPACK.stev!('V', res.alphas, res.betas)\n\n        for k in 1:length(Temp)\n            psi1 = exp.(-(eigs .- eigs[1]) ./ (2.0 .* Temp[k])) .* conj(vecs[1, :]) # compute psi_1\n\n            Obser[k, 1] += dot(psi1, psi1)# get norm factor for the partition function\n\n            Obser[k, 2] += dot(psi1, eigs .* psi1) # measure energy\n\n            Obser[k, 3] += dot(psi1, eigs .* (eigs .* psi1))# measure energy square\n        end\n    end\nend\n\nfunction main()\n\n\n    #Reads the file with the interactions\n    fl = FileToml(\"shastry_sutherland_L_5_W_4.toml\")\n    ops = read_opsum(fl, \"Interactions\")\n    #Defines exchange coupling strenght -- This ratio of couplings corresponds to the dimmer phase.\n    ops[\"Jd\"] = 1.0\n    ops[\"J\"] = 0.630\n\n    # Linear Array with target temperatures\n    Temp = LinRange(0.01, 0.35, 64)\n\n    # Array to store the average value of the observable \n    Obser = zeros(Float64, (length(Temp), 3))\n\n    Tqp_mag_sector(Obser, Temp, ops)\n\n    filename = @sprintf(\"shastry_sutherland_L_5_W_4.h5\")\n    h5open(filename, \"w\") do file\n        write(file, \"Temp\", collect(Temp))\n        write(file, \"Observable\", Obser)\n    end\nend\n\nmain()\n</code></pre> <p>The interactions terms for the Shastry Sutherland model with \\(L=5\\) and \\(W=4\\) sites is given in the following TOML file:</p> toml <pre><code># Interaction Shastry Sutherland with L=5 and W=4\nInteractions = [[\"J\", \"SdotS\", 0, 4], \n[\"J\", \"SdotS\", 0, 16], \n[\"J\", \"SdotS\", 0, 1], \n[\"J\", \"SdotS\", 0, 3], \n[\"J\", \"SdotS\", 1, 5], \n[\"J\", \"SdotS\", 1, 17], \n[\"J\", \"SdotS\", 1, 2], \n[\"J\", \"SdotS\", 2, 6], \n[\"J\", \"SdotS\", 2, 18], \n[\"J\", \"SdotS\", 2, 3], \n[\"J\", \"SdotS\", 3, 7], \n[\"J\", \"SdotS\", 3, 19], \n[\"J\", \"SdotS\", 4, 8], \n[\"J\", \"SdotS\", 4, 5], \n[\"J\", \"SdotS\", 4, 7], \n[\"J\", \"SdotS\", 5, 9], \n[\"J\", \"SdotS\", 5, 6], \n[\"J\", \"SdotS\", 6, 10],\n[\"J\", \"SdotS\", 6, 7], \n[\"J\", \"SdotS\", 7, 11], \n[\"J\", \"SdotS\", 8, 12], \n[\"J\", \"SdotS\", 8, 9], \n[\"J\", \"SdotS\", 8, 11], \n[\"J\", \"SdotS\", 9, 13], \n[\"J\", \"SdotS\", 9, 10], \n[\"J\", \"SdotS\", 10, 14],\n[\"J\", \"SdotS\", 10, 11], \n[\"J\", \"SdotS\", 11, 15], \n[\"J\", \"SdotS\", 12, 16], \n[\"J\", \"SdotS\", 12, 13], \n[\"J\", \"SdotS\", 12, 15], \n[\"J\", \"SdotS\", 13, 17], \n[\"J\", \"SdotS\", 13, 14], \n[\"J\", \"SdotS\", 14, 18], \n[\"J\", \"SdotS\", 14, 15], \n[\"J\", \"SdotS\", 15, 19], \n[\"J\", \"SdotS\", 16, 17], \n[\"J\", \"SdotS\", 16, 19], \n[\"J\", \"SdotS\", 17, 18], \n[\"J\", \"SdotS\", 18, 19], \n[\"Jd\", \"SdotS\", 0, 5], \n[\"Jd\", \"SdotS\", 6, 9], \n[\"Jd\", \"SdotS\", 2, 7], \n[\"Jd\", \"SdotS\", 4, 11], \n[\"Jd\", \"SdotS\", 8, 13], \n[\"Jd\", \"SdotS\", 14, 17], \n[\"Jd\", \"SdotS\", 10, 15], \n[\"Jd\", \"SdotS\", 12, 19], \n[\"Jd\", \"SdotS\", 1, 16], \n[\"Jd\", \"SdotS\", 3, 18]]\nN = [20]\n</code></pre>"},{"location":"examples/tpq_shastry_sutherland/#references","title":"References","text":"<p>[1] S. Sugiura and A. Shimizu, Thermal Pure Quantum States at Finite Temperature, Phys. Rev. Lett. 108, 240401 (2012).</p> <p>[2] Wietek, Alexander, Corboz, Philippe, Wessel, Stefan, Normand, B., Mila, Fr\\'ed\\'eric and Honecker, Andreas Thermodynamic properties of the Shastry-Sutherland model throughout the dimer-product phase, PhysRevResearch.103, 3038 (2019).</p>"}]}